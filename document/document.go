//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

/*

Package document provides creation, reading, and writing of ECMA 376 Open
Office XML documents.

Example:

	doc := document.New()
	para := doc.AddParagraph()
	run := para.AddRun()
	run.SetText("foo")
	doc.SaveToFile("foo.docx")
*/
package document

import (
	_cd "archive/zip"
	_cf "bytes"
	_bf "errors"
	_cfc "fmt"
	_e "github.com/unidoc/unioffice"
	_ga "github.com/unidoc/unioffice/color"
	_gc "github.com/unidoc/unioffice/common"
	_ba "github.com/unidoc/unioffice/common/tempstorage"
	_fg "github.com/unidoc/unioffice/measurement"
	_eff "github.com/unidoc/unioffice/schema/soo/dml"
	_ad "github.com/unidoc/unioffice/schema/soo/dml/picture"
	_bc "github.com/unidoc/unioffice/schema/soo/ofc/sharedTypes"
	_ef "github.com/unidoc/unioffice/schema/soo/pkg/relationships"
	_ec "github.com/unidoc/unioffice/schema/soo/wml"
	_gf "github.com/unidoc/unioffice/zippkg"
	_bg "image"
	_d "image/jpeg"
	_f "io"
	_c "log"
	_cb "math/rand"
	_ag "os"
	_bd "path/filepath"
	_g "strings"
	_a "unicode"
)

// RemoveRun removes a child run from a paragraph.
func (_babge Paragraph) RemoveRun(r Run) {
	for _, _bbcf := range _babge._bbee.EG_PContent {
		for _ddcc, _gcda := range _bbcf.EG_ContentRunContent {
			if _gcda.R == r._cbaga {
				copy(_bbcf.EG_ContentRunContent[_ddcc:], _bbcf.EG_ContentRunContent[_ddcc+1:])
				_bbcf.EG_ContentRunContent = _bbcf.EG_ContentRunContent[0 : len(_bbcf.EG_ContentRunContent)-1]
			}
			if _gcda.Sdt != nil && _gcda.Sdt.SdtContent != nil {
				for _afaae, _afbea := range _gcda.Sdt.SdtContent.EG_ContentRunContent {
					if _afbea.R == r._cbaga {
						copy(_gcda.Sdt.SdtContent.EG_ContentRunContent[_afaae:], _gcda.Sdt.SdtContent.EG_ContentRunContent[_afaae+1:])
						_gcda.Sdt.SdtContent.EG_ContentRunContent = _gcda.Sdt.SdtContent.EG_ContentRunContent[0 : len(_gcda.Sdt.SdtContent.EG_ContentRunContent)-1]
					}
				}
			}
		}
	}
}

func (_dda Run) newIC() *_ec.EG_RunInnerContent {
	_bdagd := _ec.NewEG_RunInnerContent()
	_dda._cbaga.EG_RunInnerContent = append(_dda._cbaga.EG_RunInnerContent, _bdagd)
	return _bdagd
}

// HasEndnotes returns a bool based on the presence or abscence of endnotes within
// the document.
func (_fag *Document) HasEndnotes() bool { return _fag._fgg != nil }

// Type returns the type of the field.
func (_gdeg FormField) Type() FormFieldType {
	if _gdeg._bef.TextInput != nil {
		return FormFieldTypeText
	} else if _gdeg._bef.CheckBox != nil {
		return FormFieldTypeCheckBox
	} else if _gdeg._bef.DdList != nil {
		return FormFieldTypeDropDown
	}
	return FormFieldTypeUnknown
}

// Footers returns the footers defined in the document.
func (_dfg *Document) Footers() []Footer {
	_cca := []Footer{}
	for _, _ggg := range _dfg._ead {
		_cca = append(_cca, Footer{_dfg, _ggg})
	}
	return _cca
}

// X returns the inner wrapped XML type.
func (_gcagd ParagraphProperties) X() *_ec.CT_PPr { return _gcagd._aeda }

// GetOrCreateCustomProperties returns the custom properties of the document (and if they not exist yet, creating them first)
func (_gacb *Document) GetOrCreateCustomProperties() _gc.CustomProperties {
	if _gacb.CustomProperties.X() == nil {
		_gacb.createCustomProperties()
	}
	return _gacb.CustomProperties
}

// AddTabStop adds a tab stop to the paragraph.  It controls the position of text when using Run.AddTab()
func (_acfb ParagraphProperties) AddTabStop(position _fg.Distance, justificaton _ec.ST_TabJc, leader _ec.ST_TabTlc) {
	if _acfb._aeda.Tabs == nil {
		_acfb._aeda.Tabs = _ec.NewCT_Tabs()
	}
	_fbaa := _ec.NewCT_TabStop()
	_fbaa.LeaderAttr = leader
	_fbaa.ValAttr = justificaton
	_fbaa.PosAttr.Int64 = _e.Int64(int64(position / _fg.Twips))
	_acfb._aeda.Tabs.Tab = append(_acfb._aeda.Tabs.Tab, _fbaa)
}

// FormFields extracts all of the fields from a document.  They can then be
// manipulated via the methods on the field and the document saved.
func (_cgcf *Document) FormFields() []FormField {
	_cag := []FormField{}
	for _, _afgf := range _cgcf.Paragraphs() {
		_efgd := _afgf.Runs()
		for _gcd, _fbe := range _efgd {
			for _, _fba := range _fbe._cbaga.EG_RunInnerContent {
				if _fba.FldChar == nil || _fba.FldChar.FfData == nil {
					continue
				}
				if _fba.FldChar.FldCharTypeAttr == _ec.ST_FldCharTypeBegin {
					if len(_fba.FldChar.FfData.Name) == 0 || _fba.FldChar.FfData.Name[0].ValAttr == nil {
						continue
					}
					_bbgb := FormField{_bef: _fba.FldChar.FfData}
					if _fba.FldChar.FfData.TextInput != nil {
						for _dcd := _gcd + 1; _dcd < len(_efgd)-1; _dcd++ {
							if len(_efgd[_dcd]._cbaga.EG_RunInnerContent) == 0 {
								continue
							}
							_gdg := _efgd[_dcd]._cbaga.EG_RunInnerContent[0]
							if _gdg.FldChar != nil && _gdg.FldChar.FldCharTypeAttr == _ec.ST_FldCharTypeSeparate {
								if len(_efgd[_dcd+1]._cbaga.EG_RunInnerContent) == 0 {
									continue
								}
								if _efgd[_dcd+1]._cbaga.EG_RunInnerContent[0].FldChar == nil {
									_bbgb._adbc = _efgd[_dcd+1]._cbaga.EG_RunInnerContent[0]
									break
								}
							}
						}
					}
					_cag = append(_cag, _bbgb)
				}
			}
		}
	}
	return _cag
}

// AddPageBreak adds a page break to a run.
func (_ebbd Run) AddPageBreak() {
	_aebgg := _ebbd.newIC()
	_aebgg.Br = _ec.NewCT_Br()
	_aebgg.Br.TypeAttr = _ec.ST_BrTypePage
}

// SetLeft sets the cell left margin
func (_agb CellMargins) SetLeft(d _fg.Distance) {
	_agb._cba.Left = _ec.NewCT_TblWidth()
	_fcf(_agb._cba.Left, d)
}

func (_dgff Document) mergeFields() []mergeFieldInfo {
	_daef := []Paragraph{}
	_dgcc := []mergeFieldInfo{}
	for _, _afaa := range _dgff.Tables() {
		for _, _ecdb := range _afaa.Rows() {
			for _, _ffg := range _ecdb.Cells() {
				_daef = append(_daef, _ffg.Paragraphs()...)
			}
		}
	}
	_daef = append(_daef, _dgff.Paragraphs()...)
	for _, _fbeg := range _daef {
		_fced := _fbeg.Runs()
		_edba := -1
		_gcdc := -1
		_beca := -1
		_ecbc := mergeFieldInfo{}
		for _, _ccbc := range _fbeg._bbee.EG_PContent {
			for _, _ffef := range _ccbc.FldSimple {
				if _g.Contains(_ffef.InstrAttr, "\u004d\u0045\u0052\u0047\u0045\u0046\u0049\u0045\u004c\u0044") {
					_gfgd := _cfffe(_ffef.InstrAttr)
					_gfgd._cdbee = true
					_gfgd._fagc = _fbeg
					_gfgd._edbgb = _ccbc
					_dgcc = append(_dgcc, _gfgd)
				}
			}
		}
		for _dadg := 0; _dadg < len(_fced); _dadg++ {
			_aagg := _fced[_dadg]
			for _, _cgge := range _aagg.X().EG_RunInnerContent {
				if _cgge.FldChar != nil {
					switch _cgge.FldChar.FldCharTypeAttr {
					case _ec.ST_FldCharTypeBegin:
						_edba = _dadg
					case _ec.ST_FldCharTypeSeparate:
						_gcdc = _dadg
					case _ec.ST_FldCharTypeEnd:
						_beca = _dadg
						if _ecbc._faac != "" {
							_ecbc._fagc = _fbeg
							_ecbc._edbc = _edba
							_ecbc._bbbg = _beca
							_ecbc._bgcf = _gcdc
							_dgcc = append(_dgcc, _ecbc)
						}
						_edba = -1
						_gcdc = -1
						_beca = -1
						_ecbc = mergeFieldInfo{}
					}
				} else if _cgge.InstrText != nil && _g.Contains(_cgge.InstrText.Content, "\u004d\u0045\u0052\u0047\u0045\u0046\u0049\u0045\u004c\u0044") {
					if _edba != -1 && _beca == -1 {
						_ecbc = _cfffe(_cgge.InstrText.Content)
					}
				}
			}
		}
	}
	return _dgcc
}

// RemoveFootnote removes a footnote from both the paragraph and the document
// the requested footnote must be anchored on the paragraph being referenced.
func (_cedbb Paragraph) RemoveFootnote(id int64) {
	_fef := _cedbb._baf._dea
	var _eafe int
	for _dgfg, _eedb := range _fef.CT_Footnotes.Footnote {
		if _eedb.IdAttr == id {
			_eafe = _dgfg
		}
	}
	_eafe = 0
	_fef.CT_Footnotes.Footnote[_eafe] = nil
	_fef.CT_Footnotes.Footnote[_eafe] = _fef.CT_Footnotes.Footnote[len(_fef.CT_Footnotes.Footnote)-1]
	_fef.CT_Footnotes.Footnote = _fef.CT_Footnotes.Footnote[:len(_fef.CT_Footnotes.Footnote)-1]
	var _dfeg Run
	for _, _agcee := range _cedbb.Runs() {
		if _afee, _dcgd := _agcee.IsFootnote(); _afee {
			if _dcgd == id {
				_dfeg = _agcee
			}
		}
	}
	_cedbb.RemoveRun(_dfeg)
}

// X returns the inner wrapped XML type.
func (_faedf Endnote) X() *_ec.CT_FtnEdn { return _faedf._acca }

// SetVerticalAlignment sets the vertical alignment of content within a table cell.
func (_ace CellProperties) SetVerticalAlignment(align _ec.ST_VerticalJc) {
	if align == _ec.ST_VerticalJcUnset {
		_ace._adfg.VAlign = nil
	} else {
		_ace._adfg.VAlign = _ec.NewCT_VerticalJc()
		_ace._adfg.VAlign.ValAttr = align
	}
}

// AddLevel adds a new numbering level to a NumberingDefinition.
func (_ffae NumberingDefinition) AddLevel() NumberingLevel {
	_egd := _ec.NewCT_Lvl()
	_egd.Start = &_ec.CT_DecimalNumber{ValAttr: 1}
	_egd.IlvlAttr = int64(len(_ffae._gafdd.Lvl))
	_ffae._gafdd.Lvl = append(_ffae._gafdd.Lvl, _egd)
	return NumberingLevel{_egd}
}

func (_gbaf FormFieldType) String() string {
	if _gbaf >= FormFieldType(len(_agda)-1) {
		return _cfc.Sprintf("\u0046\u006f\u0072\u006d\u0046\u0069\u0065\u006c\u0064\u0054\u0079\u0070e\u0028\u0025\u0064\u0029", _gbaf)
	}
	return _eece[_agda[_gbaf]:_agda[_gbaf+1]]
}

// SetKerning sets the run's font kerning.
func (_cfdb RunProperties) SetKerning(size _fg.Distance) {
	_cfdb._eeab.Kern = _ec.NewCT_HpsMeasure()
	_cfdb._eeab.Kern.ValAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(size / _fg.HalfPoint))
}

// SetFontFamily sets the Ascii & HAnsi fonly family for a run.
func (_bbaf RunProperties) SetFontFamily(family string) {
	if _bbaf._eeab.RFonts == nil {
		_bbaf._eeab.RFonts = _ec.NewCT_Fonts()
	}
	_bbaf._eeab.RFonts.AsciiAttr = _e.String(family)
	_bbaf._eeab.RFonts.HAnsiAttr = _e.String(family)
	_bbaf._eeab.RFonts.EastAsiaAttr = _e.String(family)
}

// TableBorders allows manipulation of borders on a table.
type TableBorders struct{ _bcd *_ec.CT_TblBorders }

// SetDoubleStrikeThrough sets the run to double strike-through.
func (_abda RunProperties) SetDoubleStrikeThrough(b bool) {
	if !b {
		_abda._eeab.Dstrike = nil
	} else {
		_abda._eeab.Dstrike = _ec.NewCT_OnOff()
	}
}

// Read reads a document from an io.Reader.
func Read(r _f.ReaderAt, size int64) (*Document, error) {
	_bgdb := New()
	_bgdb.Numbering._ebge = nil
	_fce, _gdbc := _ba.TempDir("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0064\u006f\u0063\u0078")
	if _gdbc != nil {
		return nil, _gdbc
	}
	_bgdb.TmpPath = _fce
	_egbc, _gdbc := _cd.NewReader(r, size)
	if _gdbc != nil {
		return nil, _cfc.Errorf("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073", _gdbc)
	}
	_eccg := []*_cd.File{}
	_eccg = append(_eccg, _egbc.File...)
	_eead := false
	for _, _gebg := range _eccg {
		if _gebg.FileHeader.Name == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
			_eead = true
			break
		}
	}
	if _eead {
		_bgdb.createCustomProperties()
	}
	_bbce := _bgdb._bbef.ConformanceAttr
	_fgda := _gf.DecodeMap{}
	_fgda.SetOnNewRelationshipFunc(_bgdb.onNewRelationship)
	_fgda.AddTarget(_e.ContentTypesFilename, _bgdb.ContentTypes.X(), "", 0)
	_fgda.AddTarget(_e.BaseRelsFilename, _bgdb.Rels.X(), "", 0)
	if _acce := _fgda.Decode(_eccg); _acce != nil {
		return nil, _acce
	}
	_bgdb._bbef.ConformanceAttr = _bbce
	for _, _cgb := range _eccg {
		if _cgb == nil {
			continue
		}
		if _eeb := _bgdb.AddExtraFileFromZip(_cgb); _eeb != nil {
			return nil, _eeb
		}
	}
	if _eead {
		_eeca := false
		for _, _gggb := range _bgdb.Rels.X().Relationship {
			if _gggb.TargetAttr == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
				_eeca = true
				break
			}
		}
		if !_eeca {
			_bgdb.addCustomRelationships()
		}
	}
	return _bgdb, nil
}

// Strike returns true if paragraph is striked.
func (_bdgg ParagraphProperties) Strike() bool { return _gebc(_bdgg._aeda.RPr.Strike) }

// X returns the inner wrapped XML type.
func (_gebf Footnote) X() *_ec.CT_FtnEdn { return _gebf._dded }

// SetItalic sets the run to italic.
func (_egac RunProperties) SetItalic(b bool) {
	if !b {
		_egac._eeab.I = nil
		_egac._eeab.ICs = nil
	} else {
		_egac._eeab.I = _ec.NewCT_OnOff()
		_egac._eeab.ICs = _ec.NewCT_OnOff()
	}
}

// SetLastColumn controls the conditional formatting for the last column in a table.
func (_ggcd TableLook) SetLastColumn(on bool) {
	if !on {
		_ggcd._bafa.LastColumnAttr = &_bc.ST_OnOff{}
		_ggcd._bafa.LastColumnAttr.ST_OnOff1 = _bc.ST_OnOff1Off
	} else {
		_ggcd._bafa.LastColumnAttr = &_bc.ST_OnOff{}
		_ggcd._bafa.LastColumnAttr.ST_OnOff1 = _bc.ST_OnOff1On
	}
}

// Paragraph is a paragraph within a document.
type Paragraph struct {
	_baf  *Document
	_bbee *_ec.CT_P
}

// X returns the inner wrapped XML type.
func (_febd TableStyleProperties) X() *_ec.CT_TblPrBase { return _febd._addg }

// InsertParagraphAfter adds a new empty paragraph after the relativeTo
// paragraph.
func (_agdf *Document) InsertParagraphAfter(relativeTo Paragraph) Paragraph {
	return _agdf.insertParagraph(relativeTo, false)
}

// SetPageBreakBefore controls if there is a page break before this paragraph.
func (_bcefe ParagraphProperties) SetPageBreakBefore(b bool) {
	if !b {
		_bcefe._aeda.PageBreakBefore = nil
	} else {
		_bcefe._aeda.PageBreakBefore = _ec.NewCT_OnOff()
	}
}

// Save writes the document to an io.Writer in the Zip package format.
func (_bgcd *Document) Save(w _f.Writer) error {
	//if _gce := _bgcd._bbef.Validate(); _gce != nil {
	//	_e.Log("\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0065\u0072\u0072\u006fr\u0020i\u006e\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u003a\u0020\u0025\u0073", _gce)
	//}
	_eee := _e.DocTypeDocument
	//if !_ed.GetLicenseKey().IsLicensed() && !_fbd {
	//	_cfc.Println("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065")
	//	_cfc.Println("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
	//	return _bf.New("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064")
	//}
	_dad := _cd.NewWriter(w)
	defer _dad.Close()
	if _bge := _gf.MarshalXML(_dad, _e.BaseRelsFilename, _bgcd.Rels.X()); _bge != nil {
		return _bge
	}
	if _gaf := _gf.MarshalXMLByType(_dad, _eee, _e.ExtendedPropertiesType, _bgcd.AppProperties.X()); _gaf != nil {
		return _gaf
	}
	if _bfa := _gf.MarshalXMLByType(_dad, _eee, _e.CorePropertiesType, _bgcd.CoreProperties.X()); _bfa != nil {
		return _bfa
	}
	if _bgcd.CustomProperties.X() != nil {
		if _bggd := _gf.MarshalXMLByType(_dad, _eee, _e.CustomPropertiesType, _bgcd.CustomProperties.X()); _bggd != nil {
			return _bggd
		}
	}
	if _bgcd.Thumbnail != nil {
		_ffb, _ccd := _dad.Create("\u0064\u006f\u0063Pr\u006f\u0070\u0073\u002f\u0074\u0068\u0075\u006d\u0062\u006e\u0061\u0069\u006c\u002e\u006a\u0070\u0065\u0067")
		if _ccd != nil {
			return _ccd
		}
		if _cbe := _d.Encode(_ffb, _bgcd.Thumbnail, nil); _cbe != nil {
			return _cbe
		}
	}
	if _efbf := _gf.MarshalXMLByType(_dad, _eee, _e.SettingsType, _bgcd.Settings.X()); _efbf != nil {
		return _efbf
	}
	_ca := _e.AbsoluteFilename(_eee, _e.OfficeDocumentType, 0)
	if _afc := _gf.MarshalXML(_dad, _ca, _bgcd._bbef); _afc != nil {
		return _afc
	}
	if _ceag := _gf.MarshalXML(_dad, _gf.RelationsPathFor(_ca), _bgcd._cgg.X()); _ceag != nil {
		return _ceag
	}
	if _bgcd.Numbering.X() != nil {
		if _afd := _gf.MarshalXMLByType(_dad, _eee, _e.NumberingType, _bgcd.Numbering.X()); _afd != nil {
			return _afd
		}
	}
	if _bbf := _gf.MarshalXMLByType(_dad, _eee, _e.StylesType, _bgcd.Styles.X()); _bbf != nil {
		return _bbf
	}
	if _bgcd._baeb != nil {
		if _gb := _gf.MarshalXMLByType(_dad, _eee, _e.WebSettingsType, _bgcd._baeb); _gb != nil {
			return _gb
		}
	}
	if _bgcd._fac != nil {
		if _aced := _gf.MarshalXMLByType(_dad, _eee, _e.FontTableType, _bgcd._fac); _aced != nil {
			return _aced
		}
	}
	if _bgcd._fgg != nil {
		if _aaff := _gf.MarshalXMLByType(_dad, _eee, _e.EndNotesType, _bgcd._fgg); _aaff != nil {
			return _aaff
		}
	}
	if _bgcd._dea != nil {
		if _ded := _gf.MarshalXMLByType(_dad, _eee, _e.FootNotesType, _bgcd._dea); _ded != nil {
			return _ded
		}
	}
	for _fdf, _cdbd := range _bgcd._cbag {
		if _cbc := _gf.MarshalXMLByTypeIndex(_dad, _eee, _e.ThemeType, _fdf+1, _cdbd); _cbc != nil {
			return _cbc
		}
	}
	for _gad, _gde := range _bgcd._dfe {
		_eba := _e.AbsoluteFilename(_eee, _e.HeaderType, _gad+1)
		if _fdg := _gf.MarshalXML(_dad, _eba, _gde); _fdg != nil {
			return _fdg
		}
		if !_bgcd._de[_gad].IsEmpty() {
			_gf.MarshalXML(_dad, _gf.RelationsPathFor(_eba), _bgcd._de[_gad].X())
		}
	}
	for _acg, _dfb := range _bgcd._ead {
		_gbe := _e.AbsoluteFilename(_eee, _e.FooterType, _acg+1)
		if _eeg := _gf.MarshalXMLByTypeIndex(_dad, _eee, _e.FooterType, _acg+1, _dfb); _eeg != nil {
			return _eeg
		}
		if !_bgcd._ecc[_acg].IsEmpty() {
			_gf.MarshalXML(_dad, _gf.RelationsPathFor(_gbe), _bgcd._ecc[_acg].X())
		}
	}
	for _gba, _bea := range _bgcd.Images {
		if _bbg := _gc.AddImageToZip(_dad, _bea, _gba+1, _e.DocTypeDocument); _bbg != nil {
			return _bbg
		}
	}
	if _ffe := _gf.MarshalXML(_dad, _e.ContentTypesFilename, _bgcd.ContentTypes.X()); _ffe != nil {
		return _ffe
	}
	if _eda := _bgcd.WriteExtraFiles(_dad); _eda != nil {
		return _eda
	}
	return _dad.Close()
}

// Properties returns the row properties.
func (_bcge Row) Properties() RowProperties {
	if _bcge._eedff.TrPr == nil {
		_bcge._eedff.TrPr = _ec.NewCT_TrPr()
	}
	return RowProperties{_bcge._eedff.TrPr}
}

// SetTargetBookmark sets the bookmark target of the hyperlink.
func (_bcgb HyperLink) SetTargetBookmark(bm Bookmark) {
	_bcgb._eabea.AnchorAttr = _e.String(bm.Name())
	_bcgb._eabea.IdAttr = nil
}

func (_cdgba Paragraph) addBeginFldChar(_fdgca string) *_ec.CT_FFData {
	_bddeb := _cdgba.addFldChar()
	_bddeb.FldCharTypeAttr = _ec.ST_FldCharTypeBegin
	_bddeb.FfData = _ec.NewCT_FFData()
	_fegd := _ec.NewCT_FFName()
	_fegd.ValAttr = &_fdgca
	_bddeb.FfData.Name = []*_ec.CT_FFName{_fegd}
	return _bddeb.FfData
}

// SetRowBandSize sets the number of Rows in the row band
func (_fecf TableStyleProperties) SetRowBandSize(rows int64) {
	_fecf._addg.TblStyleRowBandSize = _ec.NewCT_DecimalNumber()
	_fecf._addg.TblStyleRowBandSize.ValAttr = rows
}

// Borders allows controlling individual cell borders.
func (_fec CellProperties) Borders() CellBorders {
	if _fec._adfg.TcBorders == nil {
		_fec._adfg.TcBorders = _ec.NewCT_TcBorders()
	}
	return CellBorders{_fec._adfg.TcBorders}
}

// X returns the inner wrapped XML type.
func (_agce NumberingDefinition) X() *_ec.CT_AbstractNum { return _agce._gafdd }

// Styles returns all styles.
func (_fdgcb Styles) Styles() []Style {
	_cafab := []Style{}
	for _, _fbedg := range _fdgcb._gccd.Style {
		_cafab = append(_cafab, Style{_fbedg})
	}
	return _cafab
}

// Italic returns true if run font is italic.
func (_fbed RunProperties) Italic() bool {
	_aacf := _fbed._eeab
	return _gebc(_aacf.I) || _gebc(_aacf.ICs)
}

// SetUpdateFieldsOnOpen controls if fields are recalculated upon opening the
// document. This is useful for things like a table of contents as the library
// only adds the field code and relies on Word/LibreOffice to actually compute
// the content.
func (_dddd Settings) SetUpdateFieldsOnOpen(b bool) {
	if !b {
		_dddd._ebfg.UpdateFields = nil
	} else {
		_dddd._ebfg.UpdateFields = _ec.NewCT_OnOff()
	}
}

// CharacterSpacingMeasure returns paragraph characters spacing with its measure which can be mm, cm, in, pt, pc or pi.
func (_afca ParagraphProperties) CharacterSpacingMeasure() string {
	if _eede := _afca._aeda.RPr.Spacing; _eede != nil {
		_agfbe := _eede.ValAttr
		if _agfbe.ST_UniversalMeasure != nil {
			return *_agfbe.ST_UniversalMeasure
		}
	}
	return ""
}

// AddCheckBox adds checkbox form field to the paragraph and returns it.
func (_dgef Paragraph) AddCheckBox(name string) FormField {
	_ceg := _dgef.addFldCharsForField(name, "\u0046\u004f\u0052M\u0043\u0048\u0045\u0043\u004b\u0042\u004f\u0058")
	_ceg._bef.CheckBox = _ec.NewCT_FFCheckBox()
	return _ceg
}

// Endnotes returns the endnotes defined in the document.
func (_fge *Document) Endnotes() []Endnote {
	_fbge := []Endnote{}
	for _, _bbc := range _fge._fgg.CT_Endnotes.Endnote {
		_fbge = append(_fbge, Endnote{_fge, _bbc})
	}
	return _fbge
}

// SetThemeColor sets the color from the theme.
func (_acf Color) SetThemeColor(t _ec.ST_ThemeColor) { _acf._bca.ThemeColorAttr = t }

// AddImage adds an image to the document package, returning a reference that
// can be used to add the image to a run and place it in the document contents.
func (_ccf Header) AddImage(i _gc.Image) (_gc.ImageRef, error) {
	var _bggf _gc.Relationships
	for _bggda, _dgf := range _ccf._fceb._dfe {
		if _dgf == _ccf._gca {
			_bggf = _ccf._fceb._de[_bggda]
		}
	}
	_aba := _gc.MakeImageRef(i, &_ccf._fceb.DocBase, _bggf)
	if i.Data == nil && i.Path == "" {
		return _aba, _bf.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _aba, _bf.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _aba, _bf.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	_ccf._fceb.Images = append(_ccf._fceb.Images, _aba)
	_gbd := _cfc.Sprintf("\u006d\u0065d\u0069\u0061\u002fi\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", len(_ccf._fceb.Images), i.Format)
	_gfbb := _bggf.AddRelationship(_gbd, _e.ImageType)
	_aba.SetRelID(_gfbb.X().IdAttr)
	return _aba, nil
}

// SizeValue returns the value of run font size in points.
func (_bggb RunProperties) SizeValue() float64 {
	if _ebfc := _bggb._eeab.Sz; _ebfc != nil {
		_gcec := _ebfc.ValAttr
		if _gcec.ST_UnsignedDecimalNumber != nil {
			return float64(*_gcec.ST_UnsignedDecimalNumber) / 2
		}
	}
	return 0.0
}

// SetStyle sets the style of a paragraph and is identical to setting it on the
// paragraph's Properties()
func (_bdbb Paragraph) SetStyle(s string) {
	_bdbb.ensurePPr()
	if s == "" {
		_bdbb._bbee.PPr.PStyle = nil
	} else {
		_bdbb._bbee.PPr.PStyle = _ec.NewCT_String()
		_bdbb._bbee.PPr.PStyle.ValAttr = s
	}
}

// SetToolTip sets the tooltip text for a hyperlink.
func (_efdc HyperLink) SetToolTip(text string) {
	if text == "" {
		_efdc._eabea.TooltipAttr = nil
	} else {
		_efdc._eabea.TooltipAttr = _e.String(text)
	}
}

// AddDrawingInline adds an inline drawing from an ImageRef.
func (_fdfg Run) AddDrawingInline(img _gc.ImageRef) (InlineDrawing, error) {
	_ceeg := _fdfg.newIC()
	_ceeg.Drawing = _ec.NewCT_Drawing()
	_eacd := _ec.NewWdInline()
	_gaagg := InlineDrawing{_fdfg._afea, _eacd}
	_eacd.CNvGraphicFramePr = _eff.NewCT_NonVisualGraphicFrameProperties()
	_ceeg.Drawing.Inline = append(_ceeg.Drawing.Inline, _eacd)
	_eacd.Graphic = _eff.NewGraphic()
	_eacd.Graphic.GraphicData = _eff.NewCT_GraphicalObjectData()
	_eacd.Graphic.GraphicData.UriAttr = "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006frg\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006d\u006c\u002f\u0032\u0030\u0030\u0036\u002f\u0070\u0069\u0063\u0074\u0075\u0072\u0065"
	_eacd.DistTAttr = _e.Uint32(0)
	_eacd.DistLAttr = _e.Uint32(0)
	_eacd.DistBAttr = _e.Uint32(0)
	_eacd.DistRAttr = _e.Uint32(0)
	_eacd.Extent.CxAttr = int64(float64(img.Size().X*_fg.Pixel72) / _fg.EMU)
	_eacd.Extent.CyAttr = int64(float64(img.Size().Y*_fg.Pixel72) / _fg.EMU)
	_agacc := 0x7FFFFFFF & _cb.Uint32()
	_eacd.DocPr.IdAttr = _agacc
	_fgbe := _ad.NewPic()
	_fgbe.NvPicPr.CNvPr.IdAttr = _agacc
	_ffceb := img.RelID()
	if _ffceb == "" {
		return _gaagg, _bf.New("\u0063\u006f\u0075\u006c\u0064\u006e\u0027\u0074\u0020\u0066\u0069\u006e\u0064\u0020\u0072\u0065\u0066\u0065\u0072\u0065n\u0063\u0065\u0020\u0074\u006f\u0020\u0069\u006d\u0061g\u0065\u0020\u0077\u0069\u0074\u0068\u0069\u006e\u0020\u0064\u006f\u0063\u0075m\u0065\u006e\u0074\u0020\u0072\u0065l\u0061\u0074\u0069o\u006e\u0073")
	}
	_eacd.Graphic.GraphicData.Any = append(_eacd.Graphic.GraphicData.Any, _fgbe)
	_fgbe.BlipFill = _eff.NewCT_BlipFillProperties()
	_fgbe.BlipFill.Blip = _eff.NewCT_Blip()
	_fgbe.BlipFill.Blip.EmbedAttr = &_ffceb
	_fgbe.BlipFill.Stretch = _eff.NewCT_StretchInfoProperties()
	_fgbe.BlipFill.Stretch.FillRect = _eff.NewCT_RelativeRect()
	_fgbe.SpPr = _eff.NewCT_ShapeProperties()
	_fgbe.SpPr.Xfrm = _eff.NewCT_Transform2D()
	_fgbe.SpPr.Xfrm.Off = _eff.NewCT_Point2D()
	_fgbe.SpPr.Xfrm.Off.XAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_fgbe.SpPr.Xfrm.Off.YAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_fgbe.SpPr.Xfrm.Ext = _eff.NewCT_PositiveSize2D()
	_fgbe.SpPr.Xfrm.Ext.CxAttr = int64(img.Size().X * _fg.Point)
	_fgbe.SpPr.Xfrm.Ext.CyAttr = int64(img.Size().Y * _fg.Point)
	_fgbe.SpPr.PrstGeom = _eff.NewCT_PresetGeometry2D()
	_fgbe.SpPr.PrstGeom.PrstAttr = _eff.ST_ShapeTypeRect
	return _gaagg, nil
}

// SetAlignment sets the paragraph alignment
func (_gbfc NumberingLevel) SetAlignment(j _ec.ST_Jc) {
	if j == _ec.ST_JcUnset {
		_gbfc._dccb.LvlJc = nil
	} else {
		_gbfc._dccb.LvlJc = _ec.NewCT_Jc()
		_gbfc._dccb.LvlJc.ValAttr = j
	}
}

// SetChecked marks a FormFieldTypeCheckBox as checked or unchecked.
func (_dddc FormField) SetChecked(b bool) {
	if _dddc._bef.CheckBox == nil {
		return
	}
	if !b {
		_dddc._bef.CheckBox.Checked = nil
	} else {
		_dddc._bef.CheckBox.Checked = _ec.NewCT_OnOff()
	}
}

// ComplexSizeMeasure returns font with its measure which can be mm, cm, in, pt, pc or pi.
func (_abde RunProperties) ComplexSizeMeasure() string {
	if _aded := _abde._eeab.SzCs; _aded != nil {
		_fcgc := _aded.ValAttr
		if _fcgc.ST_PositiveUniversalMeasure != nil {
			return *_fcgc.ST_PositiveUniversalMeasure
		}
	}
	return ""
}

// TableLook is the conditional formatting associated with a table style that
// has been assigned to a table.
type TableLook struct{ _bafa *_ec.CT_TblLook }

// SetLineSpacing sets the spacing between lines in a paragraph.
func (_fedga ParagraphSpacing) SetLineSpacing(d _fg.Distance, rule _ec.ST_LineSpacingRule) {
	if rule == _ec.ST_LineSpacingRuleUnset {
		_fedga._agffc.LineRuleAttr = _ec.ST_LineSpacingRuleUnset
		_fedga._agffc.LineAttr = nil
	} else {
		_fedga._agffc.LineRuleAttr = rule
		_fedga._agffc.LineAttr = &_ec.ST_SignedTwipsMeasure{}
		_fedga._agffc.LineAttr.Int64 = _e.Int64(int64(d / _fg.Twips))
	}
}

// Properties returns the cell properties.
func (_agd Cell) Properties() CellProperties {
	if _agd._dae.TcPr == nil {
		_agd._dae.TcPr = _ec.NewCT_TcPr()
	}
	return CellProperties{_agd._dae.TcPr}
}

// SetSize sets the size of the displayed image on the page.
func (_eabc InlineDrawing) SetSize(w, h _fg.Distance) {
	_eabc._aebg.Extent.CxAttr = int64(float64(w*_fg.Pixel72) / _fg.EMU)
	_eabc._aebg.Extent.CyAttr = int64(float64(h*_fg.Pixel72) / _fg.EMU)
}

func (_dce *Document) insertParagraph(_fdfb Paragraph, _cga bool) Paragraph {
	if _dce._bbef.Body == nil {
		return _dce.AddParagraph()
	}
	_bff := _fdfb.X()
	for _, _cagd := range _dce._bbef.Body.EG_BlockLevelElts {
		for _, _ffc := range _cagd.EG_ContentBlockContent {
			for _aeec, _edag := range _ffc.P {
				if _edag == _bff {
					_dead := _ec.NewCT_P()
					_ffc.P = append(_ffc.P, nil)
					if _cga {
						copy(_ffc.P[_aeec+1:], _ffc.P[_aeec:])
						_ffc.P[_aeec] = _dead
					} else {
						copy(_ffc.P[_aeec+2:], _ffc.P[_aeec+1:])
						_ffc.P[_aeec+1] = _dead
					}
					return Paragraph{_dce, _dead}
				}
			}
			for _, _bdab := range _ffc.Tbl {
				for _, _ece := range _bdab.EG_ContentRowContent {
					for _, _gfcc := range _ece.Tr {
						for _, _bbbf := range _gfcc.EG_ContentCellContent {
							for _, _edf := range _bbbf.Tc {
								for _, _ebd := range _edf.EG_BlockLevelElts {
									for _, _gcbb := range _ebd.EG_ContentBlockContent {
										for _age, _dcae := range _gcbb.P {
											if _dcae == _bff {
												_fggb := _ec.NewCT_P()
												_gcbb.P = append(_gcbb.P, nil)
												if _cga {
													copy(_gcbb.P[_age+1:], _gcbb.P[_age:])
													_gcbb.P[_age] = _fggb
												} else {
													copy(_gcbb.P[_age+2:], _gcbb.P[_age+1:])
													_gcbb.P[_age+1] = _fggb
												}
												return Paragraph{_dce, _fggb}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if _ffc.Sdt != nil && _ffc.Sdt.SdtContent != nil && _ffc.Sdt.SdtContent.P != nil {
				for _eedf, _dee := range _ffc.Sdt.SdtContent.P {
					if _dee == _bff {
						_cgbe := _ec.NewCT_P()
						_ffc.Sdt.SdtContent.P = append(_ffc.Sdt.SdtContent.P, nil)
						if _cga {
							copy(_ffc.Sdt.SdtContent.P[_eedf+1:], _ffc.Sdt.SdtContent.P[_eedf:])
							_ffc.Sdt.SdtContent.P[_eedf] = _cgbe
						} else {
							copy(_ffc.Sdt.SdtContent.P[_eedf+2:], _ffc.Sdt.SdtContent.P[_eedf+1:])
							_ffc.Sdt.SdtContent.P[_eedf+1] = _cgbe
						}
						return Paragraph{_dce, _cgbe}
					}
				}
			}
		}
	}
	return _dce.AddParagraph()
}

// IsEndnote returns a bool based on whether the run has a
// footnote or not. Returns both a bool as to whether it has
// a footnote as well as the ID of the footnote.
func (_cfag Run) IsEndnote() (bool, int64) {
	if _cfag._cbaga.EG_RunInnerContent != nil {
		if _cfag._cbaga.EG_RunInnerContent[0].EndnoteReference != nil {
			return true, _cfag._cbaga.EG_RunInnerContent[0].EndnoteReference.IdAttr
		}
	}
	return false, 0
}

// New constructs an empty document that content can be added to.
func New() *Document {
	_ddca := &Document{_bbef: _ec.NewDocument()}
	_ddca.ContentTypes = _gc.NewContentTypes()
	_ddca._bbef.Body = _ec.NewCT_Body()
	_ddca._bbef.ConformanceAttr = _bc.ST_ConformanceClassTransitional
	_ddca._cgg = _gc.NewRelationships()
	_ddca.AppProperties = _gc.NewAppProperties()
	_ddca.CoreProperties = _gc.NewCoreProperties()
	_ddca.ContentTypes.AddOverride("\u002fw\u006fr\u0064\u002f\u0064\u006f\u0063u\u006d\u0065n\u0074\u002e\u0078\u006d\u006c", "\u0061p\u0070\u006c\u0069c\u0061\u0074\u0069o\u006e/v\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072dp\u0072o\u0063\u0065\u0073\u0073\u0069\u006eg\u006d\u006c\u002e\u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u002e\u006d\u0061\u0069\u006e\u002bx\u006d\u006c")
	_ddca.Settings = NewSettings()
	_ddca._cgg.AddRelationship("\u0073\u0065\u0074t\u0069\u006e\u0067\u0073\u002e\u0078\u006d\u006c", _e.SettingsType)
	_ddca.ContentTypes.AddOverride("\u002fw\u006fr\u0064\u002f\u0073\u0065\u0074t\u0069\u006eg\u0073\u002e\u0078\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0074\u0069o\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006e\u0078\u006dl\u0066\u006f\u0072\u006da\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c.\u0073\u0065\u0074\u0074\u0069\u006e\u0067\u0073\u002b\u0078\u006d\u006c")
	_ddca.Rels = _gc.NewRelationships()
	_ddca.Rels.AddRelationship(_e.RelativeFilename(_e.DocTypeDocument, "", _e.CorePropertiesType, 0), _e.CorePropertiesType)
	_ddca.Rels.AddRelationship("\u0064\u006fc\u0050\u0072\u006fp\u0073\u002f\u0061\u0070\u0070\u002e\u0078\u006d\u006c", _e.ExtendedPropertiesType)
	_ddca.Rels.AddRelationship("\u0077\u006f\u0072\u0064\u002f\u0064\u006f\u0063\u0075\u006d\u0065\u006et\u002e\u0078\u006d\u006c", _e.OfficeDocumentType)
	_ddca.Numbering = NewNumbering()
	_ddca.Numbering.InitializeDefault()
	_ddca.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072d/\u006e\u0075\u006d\u0062\u0065\u0072\u0069\u006e\u0067\u002e\u0078\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002f\u0076n\u0064\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063e\u0073\u0073\u0069\u006e\u0067\u006d\u006c\u002e\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067\u002b\u0078m\u006c")
	_ddca._cgg.AddRelationship("\u006e\u0075\u006d\u0062\u0065\u0072\u0069\u006e\u0067\u002e\u0078\u006d\u006c", _e.NumberingType)
	_ddca.Styles = NewStyles()
	_ddca.Styles.InitializeDefault()
	_ddca.ContentTypes.AddOverride("\u002f\u0077o\u0072\u0064\u002fs\u0074\u0079\u006c\u0065\u0073\u002e\u0078\u006d\u006c", "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0076\u006e\u0064.\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c\u002e\u0073\u0074\u0079\u006ce\u0073\u002b\u0078\u006d\u006c")
	_ddca._cgg.AddRelationship("\u0073\u0074\u0079\u006c\u0065\u0073\u002e\u0078\u006d\u006c", _e.StylesType)
	_ddca._bbef.Body = _ec.NewCT_Body()
	return _ddca
}

// AddHyperLink adds a new hyperlink to a parapgraph.
func (_gafdf Paragraph) AddHyperLink() HyperLink {
	_gdag := _ec.NewEG_PContent()
	_gafdf._bbee.EG_PContent = append(_gafdf._bbee.EG_PContent, _gdag)
	_gdag.Hyperlink = _ec.NewCT_Hyperlink()
	return HyperLink{_gafdf._baf, _gdag.Hyperlink}
}

// AddDrawingAnchored adds an anchored (floating) drawing from an ImageRef.
func (_feed Run) AddDrawingAnchored(img _gc.ImageRef) (AnchoredDrawing, error) {
	_ffdef := _feed.newIC()
	_ffdef.Drawing = _ec.NewCT_Drawing()
	_fgbdg := _ec.NewWdAnchor()
	_ccfc := AnchoredDrawing{_feed._afea, _fgbdg}
	_fgbdg.SimplePosAttr = _e.Bool(false)
	_fgbdg.AllowOverlapAttr = true
	_fgbdg.CNvGraphicFramePr = _eff.NewCT_NonVisualGraphicFrameProperties()
	_ffdef.Drawing.Anchor = append(_ffdef.Drawing.Anchor, _fgbdg)
	_fgbdg.Graphic = _eff.NewGraphic()
	_fgbdg.Graphic.GraphicData = _eff.NewCT_GraphicalObjectData()
	_fgbdg.Graphic.GraphicData.UriAttr = "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006frg\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006d\u006c\u002f\u0032\u0030\u0030\u0036\u002f\u0070\u0069\u0063\u0074\u0075\u0072\u0065"
	_fgbdg.SimplePos.XAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_fgbdg.SimplePos.YAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_fgbdg.PositionH.RelativeFromAttr = _ec.WdST_RelFromHPage
	_fgbdg.PositionH.Choice = &_ec.WdCT_PosHChoice{}
	_fgbdg.PositionH.Choice.PosOffset = _e.Int32(0)
	_fgbdg.PositionV.RelativeFromAttr = _ec.WdST_RelFromVPage
	_fgbdg.PositionV.Choice = &_ec.WdCT_PosVChoice{}
	_fgbdg.PositionV.Choice.PosOffset = _e.Int32(0)
	_fgbdg.Extent.CxAttr = int64(float64(img.Size().X*_fg.Pixel72) / _fg.EMU)
	_fgbdg.Extent.CyAttr = int64(float64(img.Size().Y*_fg.Pixel72) / _fg.EMU)
	_fgbdg.Choice = &_ec.WdEG_WrapTypeChoice{}
	_fgbdg.Choice.WrapSquare = _ec.NewWdCT_WrapSquare()
	_fgbdg.Choice.WrapSquare.WrapTextAttr = _ec.WdST_WrapTextBothSides
	_cfac := 0x7FFFFFFF & _cb.Uint32()
	_fgbdg.DocPr.IdAttr = _cfac
	_aegb := _ad.NewPic()
	_aegb.NvPicPr.CNvPr.IdAttr = _cfac
	_aea := img.RelID()
	if _aea == "" {
		return _ccfc, _bf.New("\u0063\u006f\u0075\u006c\u0064\u006e\u0027\u0074\u0020\u0066\u0069\u006e\u0064\u0020\u0072\u0065\u0066\u0065\u0072\u0065n\u0063\u0065\u0020\u0074\u006f\u0020\u0069\u006d\u0061g\u0065\u0020\u0077\u0069\u0074\u0068\u0069\u006e\u0020\u0064\u006f\u0063\u0075m\u0065\u006e\u0074\u0020\u0072\u0065l\u0061\u0074\u0069o\u006e\u0073")
	}
	_fgbdg.Graphic.GraphicData.Any = append(_fgbdg.Graphic.GraphicData.Any, _aegb)
	_aegb.BlipFill = _eff.NewCT_BlipFillProperties()
	_aegb.BlipFill.Blip = _eff.NewCT_Blip()
	_aegb.BlipFill.Blip.EmbedAttr = &_aea
	_aegb.BlipFill.Stretch = _eff.NewCT_StretchInfoProperties()
	_aegb.BlipFill.Stretch.FillRect = _eff.NewCT_RelativeRect()
	_aegb.SpPr = _eff.NewCT_ShapeProperties()
	_aegb.SpPr.Xfrm = _eff.NewCT_Transform2D()
	_aegb.SpPr.Xfrm.Off = _eff.NewCT_Point2D()
	_aegb.SpPr.Xfrm.Off.XAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_aegb.SpPr.Xfrm.Off.YAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_aegb.SpPr.Xfrm.Ext = _eff.NewCT_PositiveSize2D()
	_aegb.SpPr.Xfrm.Ext.CxAttr = int64(img.Size().X * _fg.Point)
	_aegb.SpPr.Xfrm.Ext.CyAttr = int64(img.Size().Y * _fg.Point)
	_aegb.SpPr.PrstGeom = _eff.NewCT_PresetGeometry2D()
	_aegb.SpPr.PrstGeom.PrstAttr = _eff.ST_ShapeTypeRect
	return _ccfc, nil
}

// Outline returns true if paragraph outline is on.
func (_bcbc ParagraphProperties) Outline() bool { return _gebc(_bcbc._aeda.RPr.Outline) }

// StructuredDocumentTags returns the structured document tags in the document
// which are commonly used in document templates.
func (_bcbe *Document) StructuredDocumentTags() []StructuredDocumentTag {
	_fdc := []StructuredDocumentTag{}
	for _, _fbc := range _bcbe._bbef.Body.EG_BlockLevelElts {
		for _, _eadf := range _fbc.EG_ContentBlockContent {
			if _eadf.Sdt != nil {
				_fdc = append(_fdc, StructuredDocumentTag{_bcbe, _eadf.Sdt})
			}
		}
	}
	return _fdc
}

// SetStyle sets the style of a paragraph.
func (_bfab ParagraphProperties) SetStyle(s string) {
	if s == "" {
		_bfab._aeda.PStyle = nil
	} else {
		_bfab._aeda.PStyle = _ec.NewCT_String()
		_bfab._aeda.PStyle.ValAttr = s
	}
}

// SetAll sets all of the borders to a given value.
func (_aab CellBorders) SetAll(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_aab.SetBottom(t, c, thickness)
	_aab.SetLeft(t, c, thickness)
	_aab.SetRight(t, c, thickness)
	_aab.SetTop(t, c, thickness)
	_aab.SetInsideHorizontal(t, c, thickness)
	_aab.SetInsideVertical(t, c, thickness)
}

// SetBottom sets the bottom border to a specified type, color and thickness.
func (_cgef TableBorders) SetBottom(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_cgef._bcd.Bottom = _ec.NewCT_Border()
	_edfca(_cgef._bcd.Bottom, t, c, thickness)
}

// Value returns the tring value of a FormFieldTypeText or FormFieldTypeDropDown.
func (_gabd FormField) Value() string {
	if _gabd._bef.TextInput != nil && _gabd._adbc.T != nil {
		return _gabd._adbc.T.Content
	} else if _gabd._bef.DdList != nil && _gabd._bef.DdList.Result != nil {
		_beae := _gabd.PossibleValues()
		_feac := int(_gabd._bef.DdList.Result.ValAttr)
		if _feac < len(_beae) {
			return _beae[_feac]
		}
	} else if _gabd._bef.CheckBox != nil {
		if _gabd.IsChecked() {
			return "\u0074\u0072\u0075\u0065"
		}
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}

// Type returns the type of the style.
func (_dbde Style) Type() _ec.ST_StyleType { return _dbde._dacg.TypeAttr }

// AddHeader creates a header associated with the document, but doesn't add it
// to the document for display.
func (_bcbb *Document) AddHeader() Header {
	_gfb := _ec.NewHdr()
	_bcbb._dfe = append(_bcbb._dfe, _gfb)
	_bba := _cfc.Sprintf("\u0068\u0065\u0061d\u0065\u0072\u0025\u0064\u002e\u0078\u006d\u006c", len(_bcbb._dfe))
	_bcbb._cgg.AddRelationship(_bba, _e.HeaderType)
	_bcbb.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072\u0064\u002f"+_bba, "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0076\u006e\u0064.\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c\u002e\u0068\u0065\u0061\u0064e\u0072\u002b\u0078\u006d\u006c")
	_bcbb._de = append(_bcbb._de, _gc.NewRelationships())
	return Header{_bcbb, _gfb}
}

// ComplexSizeMeasure returns font with its measure which can be mm, cm, in, pt, pc or pi.
func (_gaged ParagraphProperties) ComplexSizeMeasure() string {
	if _cfga := _gaged._aeda.RPr.SzCs; _cfga != nil {
		_egca := _cfga.ValAttr
		if _egca.ST_PositiveUniversalMeasure != nil {
			return *_egca.ST_PositiveUniversalMeasure
		}
	}
	return ""
}

// SetSize sets the size of the displayed image on the page.
func (_ge AnchoredDrawing) SetSize(w, h _fg.Distance) {
	_ge._fc.Extent.CxAttr = int64(float64(w*_fg.Pixel72) / _fg.EMU)
	_ge._fc.Extent.CyAttr = int64(float64(h*_fg.Pixel72) / _fg.EMU)
}

// Footnote returns the footnote based on the ID; this can be used nicely with
// the run.IsFootnote() functionality.
func (_eabe *Document) Footnote(id int64) Footnote {
	for _, _bgd := range _eabe.Footnotes() {
		if _bgd.id() == id {
			return _bgd
		}
	}
	return Footnote{}
}

// Tables returns the tables defined in the footer.
func (_ggeb Footer) Tables() []Table {
	_dbbf := []Table{}
	if _ggeb._abd == nil {
		return nil
	}
	for _, _ccb := range _ggeb._abd.EG_ContentBlockContent {
		for _, _fdbb := range _ggeb._bcf.tables(_ccb) {
			_dbbf = append(_dbbf, _fdbb)
		}
	}
	return _dbbf
}

// SetStart sets the cell start margin
func (_aaf CellMargins) SetStart(d _fg.Distance) {
	_aaf._cba.Start = _ec.NewCT_TblWidth()
	_fcf(_aaf._cba.Start, d)
}

// ComplexSizeValue returns the value of paragraph font size for complex fonts in points.
func (_fdab ParagraphProperties) ComplexSizeValue() float64 {
	if _gefe := _fdab._aeda.RPr.SzCs; _gefe != nil {
		_ceaeg := _gefe.ValAttr
		if _ceaeg.ST_UnsignedDecimalNumber != nil {
			return float64(*_ceaeg.ST_UnsignedDecimalNumber) / 2
		}
	}
	return 0.0
}

// SetCellSpacingPercent sets the cell spacing within a table to a percent width.
func (_fabe TableStyleProperties) SetCellSpacingPercent(pct float64) {
	_fabe._addg.TblCellSpacing = _ec.NewCT_TblWidth()
	_fabe._addg.TblCellSpacing.TypeAttr = _ec.ST_TblWidthPct
	_fabe._addg.TblCellSpacing.WAttr = &_ec.ST_MeasurementOrPercent{}
	_fabe._addg.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_fabe._addg.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(pct * 50))
}

// X returns the inner wrapped XML type.
func (_ddbf HyperLink) X() *_ec.CT_Hyperlink { return _ddbf._eabea }

func (_eag Footnote) id() int64 { return _eag._dded.IdAttr }

// OnOffValue represents an on/off value that can also be unset
type OnOffValue byte

// Section is the beginning of a new section.
type Section struct {
	_debfg *Document
	_efad  *_ec.CT_SectPr
}

// RunProperties returns the RunProperties controlling numbering level font, etc.
func (_cfgf NumberingLevel) RunProperties() RunProperties {
	if _cfgf._dccb.RPr == nil {
		_cfgf._dccb.RPr = _ec.NewCT_RPr()
	}
	return RunProperties{_cfgf._dccb.RPr}
}

// SetBeforeAuto controls if spacing before a paragraph is automatically determined.
func (_gbff ParagraphSpacing) SetBeforeAuto(b bool) {
	if b {
		_gbff._agffc.BeforeAutospacingAttr = &_bc.ST_OnOff{}
		_gbff._agffc.BeforeAutospacingAttr.Bool = _e.Bool(true)
	} else {
		_gbff._agffc.BeforeAutospacingAttr = nil
	}
}

// Tables returns the tables defined in the header.
func (_eddg Header) Tables() []Table {
	_fcgf := []Table{}
	if _eddg._gca == nil {
		return nil
	}
	for _, _bag := range _eddg._gca.EG_ContentBlockContent {
		for _, _eceb := range _eddg._fceb.tables(_bag) {
			_fcgf = append(_fcgf, _eceb)
		}
	}
	return _fcgf
}

// Footnotes returns the footnotes defined in the document.
func (_agde *Document) Footnotes() []Footnote {
	_acda := []Footnote{}
	for _, _bgec := range _agde._dea.CT_Footnotes.Footnote {
		_acda = append(_acda, Footnote{_agde, _bgec})
	}
	return _acda
}

// Fonts allows manipulating a style or run's fonts.
type Fonts struct{ _dcade *_ec.CT_Fonts }

// Numbering is the document wide numbering styles contained in numbering.xml.
type Numbering struct{ _ebge *_ec.Numbering }

// SetConformance sets conformance attribute of the document
// as one of these values from github.com/unidoc/unioffice/schema/soo/ofc/sharedTypes:
// ST_ConformanceClassUnset, ST_ConformanceClassStrict or ST_ConformanceClassTransitional.
func (_bddc Document) SetConformance(conformanceAttr _bc.ST_ConformanceClass) {
	_bddc._bbef.ConformanceAttr = conformanceAttr
}

// X returns the inner wrapped XML type.
func (_def Style) X() *_ec.CT_Style { return _def._dacg }

// SetSize sets the font size for a run.
func (_fgbgg RunProperties) SetSize(size _fg.Distance) {
	_fgbgg._eeab.Sz = _ec.NewCT_HpsMeasure()
	_fgbgg._eeab.Sz.ValAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(size / _fg.HalfPoint))
	_fgbgg._eeab.SzCs = _ec.NewCT_HpsMeasure()
	_fgbgg._eeab.SzCs.ValAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(size / _fg.HalfPoint))
}

func _eef(_bdeg *_ec.CT_TblWidth, _fgb float64) {
	_bdeg.TypeAttr = _ec.ST_TblWidthPct
	_bdeg.WAttr = &_ec.ST_MeasurementOrPercent{}
	_bdeg.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_bdeg.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(_fgb * 50))
}

// SetEnabled marks a FormField as enabled or disabled.
func (_bdbe FormField) SetEnabled(enabled bool) {
	_efbg := _ec.NewCT_OnOff()
	_efbg.ValAttr = &_bc.ST_OnOff{Bool: &enabled}
	_bdbe._bef.Enabled = []*_ec.CT_OnOff{_efbg}
}

// SetLineSpacing sets the spacing between lines in a paragraph.
func (_afbef Paragraph) SetLineSpacing(d _fg.Distance, rule _ec.ST_LineSpacingRule) {
	_afbef.ensurePPr()
	if _afbef._bbee.PPr.Spacing == nil {
		_afbef._bbee.PPr.Spacing = _ec.NewCT_Spacing()
	}
	_gcag := _afbef._bbee.PPr.Spacing
	if rule == _ec.ST_LineSpacingRuleUnset {
		_gcag.LineRuleAttr = _ec.ST_LineSpacingRuleUnset
		_gcag.LineAttr = nil
	} else {
		_gcag.LineRuleAttr = rule
		_gcag.LineAttr = &_ec.ST_SignedTwipsMeasure{}
		_gcag.LineAttr.Int64 = _e.Int64(int64(d / _fg.Twips))
	}
}

// SetHeader sets a section header.
func (_bddef Section) SetHeader(h Header, t _ec.ST_HdrFtr) {
	_fdfga := _ec.NewEG_HdrFtrReferences()
	_bddef._efad.EG_HdrFtrReferences = append(_bddef._efad.EG_HdrFtrReferences, _fdfga)
	_fdfga.HeaderReference = _ec.NewCT_HdrFtrRef()
	_fdfga.HeaderReference.TypeAttr = t
	_efaa := _bddef._debfg._cgg.FindRIDForN(h.Index(), _e.HeaderType)
	if _efaa == "" {
		_c.Print("\u0075\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0072\u006d\u0069\u006e\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0049\u0044")
	}
	_fdfga.HeaderReference.IdAttr = _efaa
}

// Index returns the index of the header within the document.  This is used to
// form its zip packaged filename as well as to match it with its relationship
// ID.
func (_aafg Header) Index() int {
	for _decd, _gfgge := range _aafg._fceb._dfe {
		if _gfgge == _aafg._gca {
			return _decd
		}
	}
	return -1
}

// SetEmboss sets the run to embossed text.
func (_cbdf RunProperties) SetEmboss(b bool) {
	if !b {
		_cbdf._eeab.Emboss = nil
	} else {
		_cbdf._eeab.Emboss = _ec.NewCT_OnOff()
	}
}

// SetNumberingDefinition sets the numbering definition ID via a NumberingDefinition
// defined in numbering.xml
func (_caea Paragraph) SetNumberingDefinition(nd NumberingDefinition) {
	_caea.ensurePPr()
	if _caea._bbee.PPr.NumPr == nil {
		_caea._bbee.PPr.NumPr = _ec.NewCT_NumPr()
	}
	_abcc := _ec.NewCT_DecimalNumber()
	_gcff := int64(-1)
	for _, _cggb := range _caea._baf.Numbering._ebge.Num {
		if _cggb.AbstractNumId != nil && _cggb.AbstractNumId.ValAttr == nd.AbstractNumberID() {
			_gcff = _cggb.NumIdAttr
		}
	}
	if _gcff == -1 {
		_agfbf := _ec.NewCT_Num()
		_caea._baf.Numbering._ebge.Num = append(_caea._baf.Numbering._ebge.Num, _agfbf)
		_agfbf.NumIdAttr = int64(len(_caea._baf.Numbering._ebge.Num))
		_agfbf.AbstractNumId = _ec.NewCT_DecimalNumber()
		_agfbf.AbstractNumId.ValAttr = nd.AbstractNumberID()
	}
	_abcc.ValAttr = _gcff
	_caea._bbee.PPr.NumPr.NumId = _abcc
}

// SetAllCaps sets the run to all caps.
func (_dggbf RunProperties) SetAllCaps(b bool) {
	if !b {
		_dggbf._eeab.Caps = nil
	} else {
		_dggbf._eeab.Caps = _ec.NewCT_OnOff()
	}
}

// GetImageByRelID returns an ImageRef with the associated relation ID in the
// document.
func (_bdbf *Document) GetImageByRelID(relID string) (_gc.ImageRef, bool) {
	for _, _cedb := range _bdbf.Images {
		if _cedb.RelID() == relID {
			return _cedb, true
		}
	}
	return _gc.ImageRef{}, false
}

// SetRightPct sets the cell right margin
func (_cea CellMargins) SetRightPct(pct float64) {
	_cea._cba.Right = _ec.NewCT_TblWidth()
	_eef(_cea._cba.Right, pct)
}

// Cells returns the cells defined in the table.
func (_eagb Row) Cells() []Cell {
	_gbfee := []Cell{}
	for _, _ddcg := range _eagb._eedff.EG_ContentCellContent {
		for _, _edbf := range _ddcg.Tc {
			_gbfee = append(_gbfee, Cell{_eagb._gedad, _edbf})
		}
		if _ddcg.Sdt != nil && _ddcg.Sdt.SdtContent != nil {
			for _, _gffa := range _ddcg.Sdt.SdtContent.Tc {
				_gbfee = append(_gbfee, Cell{_eagb._gedad, _gffa})
			}
		}
	}
	return _gbfee
}

// SetFirstColumn controls the conditional formatting for the first column in a table.
func (_fbgce TableLook) SetFirstColumn(on bool) {
	if !on {
		_fbgce._bafa.FirstColumnAttr = &_bc.ST_OnOff{}
		_fbgce._bafa.FirstColumnAttr.ST_OnOff1 = _bc.ST_OnOff1Off
	} else {
		_fbgce._bafa.FirstColumnAttr = &_bc.ST_OnOff{}
		_fbgce._bafa.FirstColumnAttr.ST_OnOff1 = _bc.ST_OnOff1On
	}
}

// Style returns the style for a paragraph, or an empty string if it is unset.
func (_agfg ParagraphProperties) Style() string {
	if _agfg._aeda.PStyle != nil {
		return _agfg._aeda.PStyle.ValAttr
	}
	return ""
}

// SetYOffset sets the Y offset for an image relative to the origin.
func (_bgc AnchoredDrawing) SetYOffset(y _fg.Distance) {
	_bgc._fc.PositionV.Choice = &_ec.WdCT_PosVChoice{}
	_bgc._fc.PositionV.Choice.PosOffset = _e.Int32(int32(y / _fg.EMU))
}

// Clear clears all content within a footer
func (_ccgd Footer) Clear() { _ccgd._abd.EG_ContentBlockContent = nil }

func (_eb *Document) addCustomRelationships() {
	_eb.ContentTypes.AddOverride("/\u0064o\u0063\u0050\u0072\u006f\u0070\u0073\u002f\u0063u\u0073\u0074\u006f\u006d.x\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069\u0063a\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065n\u0078\u006d\u006c\u0066\u006fr\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0063\u0075\u0073\u0074\u006f\u006d\u002d\u0070r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073+\u0078\u006d\u006c")
	_eb.Rels.AddRelationship("\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c", _e.CustomPropertiesType)
}

// AddCell adds a cell to a row and returns it
func (_acedb Row) AddCell() Cell {
	_gfff := _ec.NewEG_ContentCellContent()
	_acedb._eedff.EG_ContentCellContent = append(_acedb._eedff.EG_ContentCellContent, _gfff)
	_efe := _ec.NewCT_Tc()
	_gfff.Tc = append(_gfff.Tc, _efe)
	return Cell{_acedb._gedad, _efe}
}

// Font returns the name of paragraph font family.
func (_dag ParagraphProperties) Font() string {
	if _eeebd := _dag._aeda.RPr.RFonts; _eeebd != nil {
		if _eeebd.AsciiAttr != nil {
			return *_eeebd.AsciiAttr
		} else if _eeebd.HAnsiAttr != nil {
			return *_eeebd.HAnsiAttr
		} else if _eeebd.CsAttr != nil {
			return *_eeebd.CsAttr
		}
	}
	return ""
}

// DoubleStrike returns true if run is double striked.
func (_egea RunProperties) DoubleStrike() bool { return _gebc(_egea._eeab.Dstrike) }

// Properties returns the paragraph properties.
func (_ceae Paragraph) Properties() ParagraphProperties {
	_ceae.ensurePPr()
	return ParagraphProperties{_ceae._baf, _ceae._bbee.PPr}
}

// SetInsideVertical sets the interior vertical borders to a specified type, color and thickness.
func (_efd CellBorders) SetInsideVertical(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_efd._dcb.InsideV = _ec.NewCT_Border()
	_edfca(_efd._dcb.InsideV, t, c, thickness)
}

// Style is a style within the styles.xml file.
type Style struct{ _dacg *_ec.CT_Style }

// Underline returns the type of run underline.
func (_ecbd RunProperties) Underline() _ec.ST_Underline {
	if _bggbf := _ecbd._eeab.U; _bggbf != nil {
		return _bggbf.ValAttr
	}
	return 0
}

// ItalicValue returns the precise nature of the italic setting (unset, off or on).
func (_gbea RunProperties) ItalicValue() OnOffValue { return _gdbf(_gbea._eeab.I) }

// SetAlignment controls the paragraph alignment
func (_eeba ParagraphProperties) SetAlignment(align _ec.ST_Jc) {
	if align == _ec.ST_JcUnset {
		_eeba._aeda.Jc = nil
	} else {
		_eeba._aeda.Jc = _ec.NewCT_Jc()
		_eeba._aeda.Jc.ValAttr = align
	}
}

// EastAsiaFont returns the name of paragraph font family for East Asia.
func (_gcgeg ParagraphProperties) EastAsiaFont() string {
	if _bfg := _gcgeg._aeda.RPr.RFonts; _bfg != nil {
		if _bfg.EastAsiaAttr != nil {
			return *_bfg.EastAsiaAttr
		}
	}
	return ""
}

func _fcf(_adb *_ec.CT_TblWidth, _adf _fg.Distance) {
	_adb.TypeAttr = _ec.ST_TblWidthDxa
	_adb.WAttr = &_ec.ST_MeasurementOrPercent{}
	_adb.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_adb.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(_adf / _fg.Dxa))
}

// SetWidth sets the cell width to a specified width.
func (_gfa CellProperties) SetWidth(d _fg.Distance) {
	_gfa._adfg.TcW = _ec.NewCT_TblWidth()
	_gfa._adfg.TcW.TypeAttr = _ec.ST_TblWidthDxa
	_gfa._adfg.TcW.WAttr = &_ec.ST_MeasurementOrPercent{}
	_gfa._adfg.TcW.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_gfa._adfg.TcW.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(d / _fg.Twips))
}

// Footer is a footer for a document section.
type Footer struct {
	_bcf *Document
	_abd *_ec.Ftr
}

// Paragraphs returns the paragraphs defined in a footnote.
func (_cgcdf Footnote) Paragraphs() []Paragraph {
	_cggd := []Paragraph{}
	for _, _cggf := range _cgcdf.content() {
		for _, _aag := range _cggf.P {
			_cggd = append(_cggd, Paragraph{_cgcdf._cecb, _aag})
		}
	}
	return _cggd
}

// SetKeepWithNext controls if this paragraph should be kept with the next.
func (_aeg ParagraphProperties) SetKeepWithNext(b bool) {
	if !b {
		_aeg._aeda.KeepNext = nil
	} else {
		_aeg._aeda.KeepNext = _ec.NewCT_OnOff()
	}
}

// RemoveParagraph removes a paragraph from a footer.
func (_dgdg Header) RemoveParagraph(p Paragraph) {
	for _, _gbf := range _dgdg._gca.EG_ContentBlockContent {
		for _fbde, _deec := range _gbf.P {
			if _deec == p._bbee {
				copy(_gbf.P[_fbde:], _gbf.P[_fbde+1:])
				_gbf.P = _gbf.P[0 : len(_gbf.P)-1]
				return
			}
		}
	}
}

// ParagraphStyles returns only the paragraph styles.
func (_egdb Styles) ParagraphStyles() []Style {
	_cfgd := []Style{}
	for _, _gfccc := range _egdb._gccd.Style {
		if _gfccc.TypeAttr != _ec.ST_StyleTypeParagraph {
			continue
		}
		_cfgd = append(_cfgd, Style{_gfccc})
	}
	return _cfgd
}

// NewTableWidth returns a newly intialized TableWidth
func NewTableWidth() TableWidth { return TableWidth{_ec.NewCT_TblWidth()} }

// AddTextInput adds text input form field to the paragraph and returns it.
func (_bcff Paragraph) AddTextInput(name string) FormField {
	_cdcdc := _bcff.addFldCharsForField(name, "\u0046\u004f\u0052\u004d\u0054\u0045\u0058\u0054")
	_cdcdc._bef.TextInput = _ec.NewCT_FFTextInput()
	return _cdcdc
}

// Clear removes all of the content from within a run.
func (_ebbf Run) Clear() { _ebbf._cbaga.EG_RunInnerContent = nil }

// X returns the inner wrapped XML type.
func (_fdbe Numbering) X() *_ec.Numbering { return _fdbe._ebge }

// SetAlignment sets the alignment of a table within the page.
func (_edbfg TableProperties) SetAlignment(align _ec.ST_JcTable) {
	if align == _ec.ST_JcTableUnset {
		_edbfg._ddac.Jc = nil
	} else {
		_edbfg._ddac.Jc = _ec.NewCT_JcTable()
		_edbfg._ddac.Jc.ValAttr = align
	}
}

// AddTab adds tab to a run and can be used with the the Paragraph's tab stops.
func (_fegg Run) AddTab() { _cggc := _fegg.newIC(); _cggc.Tab = _ec.NewCT_Empty() }

// InsertParagraphBefore adds a new empty paragraph before the relativeTo
// paragraph.
func (_cecab *Document) InsertParagraphBefore(relativeTo Paragraph) Paragraph {
	return _cecab.insertParagraph(relativeTo, true)
}

// SetAlignment positions an anchored image via alignment.  Offset is
// incompatible with SetOffset, whichever is called last is applied.
func (_da AnchoredDrawing) SetAlignment(h _ec.WdST_AlignH, v _ec.WdST_AlignV) {
	_da.SetHAlignment(h)
	_da.SetVAlignment(v)
}

func (_gcgb Paragraph) addEndFldChar() *_ec.CT_FldChar {
	_fcgfe := _gcgb.addFldChar()
	_fcgfe.FldCharTypeAttr = _ec.ST_FldCharTypeEnd
	return _fcgfe
}

// SetWidthPercent sets the cell to a width percentage.
func (_gdb CellProperties) SetWidthPercent(pct float64) {
	_gdb._adfg.TcW = _ec.NewCT_TblWidth()
	_gdb._adfg.TcW.TypeAttr = _ec.ST_TblWidthPct
	_gdb._adfg.TcW.WAttr = &_ec.ST_MeasurementOrPercent{}
	_gdb._adfg.TcW.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_gdb._adfg.TcW.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(pct * 50))
}

// SetName sets the name of the bookmark. This is the name that is used to
// reference the bookmark from hyperlinks.
func (_bga Bookmark) SetName(name string) { _bga._bde.NameAttr = name }

func (_gddaf Paragraph) addFldCharsForField(_facee, _cbcf string) FormField {
	_abcd := _gddaf.addBeginFldChar(_facee)
	_ddeg := FormField{_bef: _abcd}
	_ceef := _gddaf._baf.Bookmarks()
	_bcef := int64(len(_ceef))
	if _facee != "" {
		_gddaf.addStartBookmark(_bcef, _facee)
	}
	_gddaf.addInstrText(_cbcf)
	_gddaf.addSeparateFldChar()
	if _cbcf == "\u0046\u004f\u0052\u004d\u0054\u0045\u0058\u0054" {
		_cgae := _gddaf.AddRun()
		_eddf := _ec.NewEG_RunInnerContent()
		_cgae._cbaga.EG_RunInnerContent = []*_ec.EG_RunInnerContent{_eddf}
		_ddeg._adbc = _eddf
	}
	_gddaf.addEndFldChar()
	if _facee != "" {
		_gddaf.addEndBookmark(_bcef)
	}
	return _ddeg
}

// X returns the inner wrapped XML type.
func (_cdg *Document) X() *_ec.Document { return _cdg._bbef }

// Borders allows manipulation of the table borders.
func (_fdgf TableStyleProperties) Borders() TableBorders {
	if _fdgf._addg.TblBorders == nil {
		_fdgf._addg.TblBorders = _ec.NewCT_TblBorders()
	}
	return TableBorders{_fdgf._addg.TblBorders}
}

// Caps returns true if run font is capitalized.
func (_fcad RunProperties) Caps() bool { return _gebc(_fcad._eeab.Caps) }

// Shadow returns true if paragraph shadow is on.
func (_gacg ParagraphProperties) Shadow() bool { return _gebc(_gacg._aeda.RPr.Shadow) }

// EastAsiaFont returns the name of run font family for East Asia.
func (_cbec RunProperties) EastAsiaFont() string {
	if _fgce := _cbec._eeab.RFonts; _fgce != nil {
		if _fgce.EastAsiaAttr != nil {
			return *_fgce.EastAsiaAttr
		}
	}
	return ""
}

func (_gdaa Endnote) id() int64 { return _gdaa._acca.IdAttr }

// SetHighlight highlights text in a specified color.
func (_aacge RunProperties) SetHighlight(c _ec.ST_HighlightColor) {
	_aacge._eeab.Highlight = _ec.NewCT_Highlight()
	_aacge._eeab.Highlight.ValAttr = c
}

// SetHeadingLevel sets a heading level and style based on the level to a
// paragraph.  The default styles for a new unioffice document support headings
// from level 1 to 8.
func (_gebb ParagraphProperties) SetHeadingLevel(idx int) {
	_gebb.SetStyle(_cfc.Sprintf("\u0048e\u0061\u0064\u0069\u006e\u0067\u0025d", idx))
	if _gebb._aeda.NumPr == nil {
		_gebb._aeda.NumPr = _ec.NewCT_NumPr()
	}
	_gebb._aeda.NumPr.Ilvl = _ec.NewCT_DecimalNumber()
	_gebb._aeda.NumPr.Ilvl.ValAttr = int64(idx)
}

// SetUnhideWhenUsed controls if a semi hidden style becomes visible when used.
func (_eeaf Style) SetUnhideWhenUsed(b bool) {
	if b {
		_eeaf._dacg.UnhideWhenUsed = _ec.NewCT_OnOff()
	} else {
		_eeaf._dacg.UnhideWhenUsed = nil
	}
}

func (_cac *Document) insertTable(_bab Paragraph, _dcgb bool) Table {
	_cfd := _cac._bbef.Body
	if _cfd == nil {
		return _cac.AddTable()
	}
	_gfd := _bab.X()
	for _edd, _dcc := range _cfd.EG_BlockLevelElts {
		for _, _gaa := range _dcc.EG_ContentBlockContent {
			for _bda, _dca := range _gaa.P {
				if _dca == _gfd {
					_bec := _ec.NewCT_Tbl()
					_efbc := _ec.NewEG_BlockLevelElts()
					_dgad := _ec.NewEG_ContentBlockContent()
					_efbc.EG_ContentBlockContent = append(_efbc.EG_ContentBlockContent, _dgad)
					_dgad.Tbl = append(_dgad.Tbl, _bec)
					_cfd.EG_BlockLevelElts = append(_cfd.EG_BlockLevelElts, nil)
					if _dcgb {
						copy(_cfd.EG_BlockLevelElts[_edd+1:], _cfd.EG_BlockLevelElts[_edd:])
						_cfd.EG_BlockLevelElts[_edd] = _efbc
						if _bda != 0 {
							_ggf := _ec.NewEG_BlockLevelElts()
							_gadf := _ec.NewEG_ContentBlockContent()
							_ggf.EG_ContentBlockContent = append(_ggf.EG_ContentBlockContent, _gadf)
							_gadf.P = _gaa.P[:_bda]
							_cfd.EG_BlockLevelElts = append(_cfd.EG_BlockLevelElts, nil)
							copy(_cfd.EG_BlockLevelElts[_edd+1:], _cfd.EG_BlockLevelElts[_edd:])
							_cfd.EG_BlockLevelElts[_edd] = _ggf
						}
						_gaa.P = _gaa.P[_bda:]
					} else {
						copy(_cfd.EG_BlockLevelElts[_edd+2:], _cfd.EG_BlockLevelElts[_edd+1:])
						_cfd.EG_BlockLevelElts[_edd+1] = _efbc
						if _bda != len(_gaa.P)-1 {
							_gda := _ec.NewEG_BlockLevelElts()
							_edg := _ec.NewEG_ContentBlockContent()
							_gda.EG_ContentBlockContent = append(_gda.EG_ContentBlockContent, _edg)
							_edg.P = _gaa.P[_bda+1:]
							_cfd.EG_BlockLevelElts = append(_cfd.EG_BlockLevelElts, nil)
							copy(_cfd.EG_BlockLevelElts[_edd+3:], _cfd.EG_BlockLevelElts[_edd+2:])
							_cfd.EG_BlockLevelElts[_edd+2] = _gda
						}
						_gaa.P = _gaa.P[:_bda+1]
					}
					return Table{_cac, _bec}
				}
			}
			for _, _aga := range _gaa.Tbl {
				_cgcd := _eccd(_aga, _gfd, _dcgb)
				if _cgcd != nil {
					return Table{_cac, _cgcd}
				}
			}
		}
	}
	return _cac.AddTable()
}

// RemoveEndnote removes a endnote from both the paragraph and the document
// the requested endnote must be anchored on the paragraph being referenced.
func (_dcgg Paragraph) RemoveEndnote(id int64) {
	_bbbd := _dcgg._baf._fgg
	var _debg int
	for _aceg, _daf := range _bbbd.CT_Endnotes.Endnote {
		if _daf.IdAttr == id {
			_debg = _aceg
		}
	}
	_debg = 0
	_bbbd.CT_Endnotes.Endnote[_debg] = nil
	_bbbd.CT_Endnotes.Endnote[_debg] = _bbbd.CT_Endnotes.Endnote[len(_bbbd.CT_Endnotes.Endnote)-1]
	_bbbd.CT_Endnotes.Endnote = _bbbd.CT_Endnotes.Endnote[:len(_bbbd.CT_Endnotes.Endnote)-1]
	var _fee Run
	for _, _febbf := range _dcgg.Runs() {
		if _adab, _efddg := _febbf.IsEndnote(); _adab {
			if _efddg == id {
				_fee = _febbf
			}
		}
	}
	_dcgg.RemoveRun(_fee)
}

// SizeValue returns the value of paragraph font size in points.
func (_bdbba ParagraphProperties) SizeValue() float64 {
	if _gdce := _bdbba._aeda.RPr.Sz; _gdce != nil {
		_acfg := _gdce.ValAttr
		if _acfg.ST_UnsignedDecimalNumber != nil {
			return float64(*_acfg.ST_UnsignedDecimalNumber) / 2
		}
	}
	return 0.0
}

// X returns the inner wrapped XML type.
func (_fbcg Paragraph) X() *_ec.CT_P { return _fbcg._bbee }

func (_dab *Document) InsertTableAfter(relativeTo Paragraph) Table {
	return _dab.insertTable(relativeTo, false)
}

// Caps returns true if paragraph font is capitalized.
func (_baegc ParagraphProperties) Caps() bool { return _gebc(_baegc._aeda.RPr.Caps) }

// SetXOffset sets the X offset for an image relative to the origin.
func (_bcb AnchoredDrawing) SetXOffset(x _fg.Distance) {
	_bcb._fc.PositionH.Choice = &_ec.WdCT_PosHChoice{}
	_bcb._fc.PositionH.Choice.PosOffset = _e.Int32(int32(x / _fg.EMU))
}

// Row is a row within a table within a document.
type Row struct {
	_gedad *Document
	_eedff *_ec.CT_Row
}

// BodySection returns the default body section used for all preceding
// paragraphs until the previous Section. If there is no previous sections, the
// body section applies to the entire document.
func (_bgb *Document) BodySection() Section {
	if _bgb._bbef.Body.SectPr == nil {
		_bgb._bbef.Body.SectPr = _ec.NewCT_SectPr()
	}
	return Section{_bgb, _bgb._bbef.Body.SectPr}
}

func (_fafab Styles) initializeDocDefaults() {
	_fafab._gccd.DocDefaults = _ec.NewCT_DocDefaults()
	_fafab._gccd.DocDefaults.RPrDefault = _ec.NewCT_RPrDefault()
	_fafab._gccd.DocDefaults.RPrDefault.RPr = _ec.NewCT_RPr()
	_cbafb := RunProperties{_fafab._gccd.DocDefaults.RPrDefault.RPr}
	_cbafb.SetSize(12 * _fg.Point)
	_cbafb.Fonts().SetASCIITheme(_ec.ST_ThemeMajorAscii)
	_cbafb.Fonts().SetEastAsiaTheme(_ec.ST_ThemeMajorEastAsia)
	_cbafb.Fonts().SetHANSITheme(_ec.ST_ThemeMajorHAnsi)
	_cbafb.Fonts().SetCSTheme(_ec.ST_ThemeMajorBidi)
	_cbafb.X().Lang = _ec.NewCT_Language()
	_cbafb.X().Lang.ValAttr = _e.String("\u0065\u006e\u002dU\u0053")
	_cbafb.X().Lang.EastAsiaAttr = _e.String("\u0065\u006e\u002dU\u0053")
	_cbafb.X().Lang.BidiAttr = _e.String("\u0061\u0072\u002dS\u0041")
	_fafab._gccd.DocDefaults.PPrDefault = _ec.NewCT_PPrDefault()
}

// SetFirstRow controls the conditional formatting for the first row in a table.
func (_fafd TableLook) SetFirstRow(on bool) {
	if !on {
		_fafd._bafa.FirstRowAttr = &_bc.ST_OnOff{}
		_fafd._bafa.FirstRowAttr.ST_OnOff1 = _bc.ST_OnOff1Off
	} else {
		_fafd._bafa.FirstRowAttr = &_bc.ST_OnOff{}
		_fafd._bafa.FirstRowAttr.ST_OnOff1 = _bc.ST_OnOff1On
	}
}

// Paragraphs returns all of the paragraphs in the document body including tables.
func (_ffa *Document) Paragraphs() []Paragraph {
	_efbb := []Paragraph{}
	if _ffa._bbef.Body == nil {
		return nil
	}
	for _, _eabb := range _ffa._bbef.Body.EG_BlockLevelElts {
		for _, _ffed := range _eabb.EG_ContentBlockContent {
			for _, _dcbc := range _ffed.P {
				_efbb = append(_efbb, Paragraph{_ffa, _dcbc})
			}
		}
	}
	for _, _ade := range _ffa.Tables() {
		for _, _cdbe := range _ade.Rows() {
			for _, _gffg := range _cdbe.Cells() {
				_efbb = append(_efbb, _gffg.Paragraphs()...)
			}
		}
	}
	return _efbb
}

// Table is a table within a document.
type Table struct {
	_ffdb *Document
	_adgg *_ec.CT_Tbl
}

// SetDefaultValue sets the default value of a FormFieldTypeDropDown. For
// FormFieldTypeDropDown, the value must be one of the fields possible values.
func (_ecec FormField) SetDefaultValue(v string) {
	if _ecec._bef.DdList != nil {
		for _eccgc, _bdde := range _ecec.PossibleValues() {
			if _bdde == v {
				_ecec._bef.DdList.Default = _ec.NewCT_DecimalNumber()
				_ecec._bef.DdList.Default.ValAttr = int64(_eccgc)
				break
			}
		}
	}
}

// SetBottom sets the cell bottom margin
func (_df CellMargins) SetBottom(d _fg.Distance) {
	_df._cba.Bottom = _ec.NewCT_TblWidth()
	_fcf(_df._cba.Bottom, d)
}

// AddEndnote will create a new endnote and attach it to the Paragraph in the
// location at the end of the previous run (endnotes create their own run within
// the paragraph. The text given to the function is simply a convenience helper,
// paragraphs and runs can always be added to the text of the endnote later.
func (_dfde Paragraph) AddEndnote(text string) Endnote {
	var _eccb int64
	if _dfde._baf.HasEndnotes() {
		for _, _dccf := range _dfde._baf.Endnotes() {
			if _dccf.id() > _eccb {
				_eccb = _dccf.id()
			}
		}
		_eccb++
	} else {
		_eccb = 0
		_dfde._baf._fgg = &_ec.Endnotes{}
	}
	_cdcd := _ec.NewCT_FtnEdn()
	_cdgdg := _ec.NewCT_FtnEdnRef()
	_cdgdg.IdAttr = _eccb
	_dfde._baf._fgg.CT_Endnotes.Endnote = append(_dfde._baf._fgg.CT_Endnotes.Endnote, _cdcd)
	_baeaa := _dfde.AddRun()
	_aeeb := _baeaa.Properties()
	_aeeb.SetStyle("\u0045\u006e\u0064\u006e\u006f\u0074\u0065\u0041\u006e\u0063\u0068\u006f\u0072")
	_baeaa._cbaga.EG_RunInnerContent = []*_ec.EG_RunInnerContent{_ec.NewEG_RunInnerContent()}
	_baeaa._cbaga.EG_RunInnerContent[0].EndnoteReference = _cdgdg
	_ddcca := Endnote{_dfde._baf, _cdcd}
	_ddcca._acca.IdAttr = _eccb
	_ddcca._acca.EG_BlockLevelElts = []*_ec.EG_BlockLevelElts{_ec.NewEG_BlockLevelElts()}
	_eggf := _ddcca.AddParagraph()
	_eggf.Properties().SetStyle("\u0045n\u0064\u006e\u006f\u0074\u0065")
	_eggf._bbee.PPr.RPr = _ec.NewCT_ParaRPr()
	_gfga := _eggf.AddRun()
	_gfga.AddTab()
	_gfga.AddText(text)
	return _ddcca
}

// SetStartPct sets the cell start margin
func (_bgg CellMargins) SetStartPct(pct float64) {
	_bgg._cba.Start = _ec.NewCT_TblWidth()
	_eef(_bgg._cba.Start, pct)
}

// AddDefinition adds a new numbering definition.
func (_egaa Numbering) AddDefinition() NumberingDefinition {
	_eecg := _ec.NewCT_Num()
	_gegf := int64(1)
	for _, _ggdd := range _egaa.Definitions() {
		if _ggdd.AbstractNumberID() >= _gegf {
			_gegf = _ggdd.AbstractNumberID() + 1
		}
	}
	_abdc := int64(1)
	for _, _dbg := range _egaa.X().Num {
		if _dbg.NumIdAttr >= _abdc {
			_abdc = _dbg.NumIdAttr + 1
		}
	}
	_eecg.NumIdAttr = _abdc
	_eecg.AbstractNumId = _ec.NewCT_DecimalNumber()
	_eecg.AbstractNumId.ValAttr = _gegf
	_gagbd := _ec.NewCT_AbstractNum()
	_gagbd.AbstractNumIdAttr = _gegf
	_egaa._ebge.AbstractNum = append(_egaa._ebge.AbstractNum, _gagbd)
	_egaa._ebge.Num = append(_egaa._ebge.Num, _eecg)
	return NumberingDefinition{_gagbd}
}

// Endnote is an individual endnote reference within the document.
type Endnote struct {
	_gafe *Document
	_acca *_ec.CT_FtnEdn
}

// X returns the inner wrapped XML type.
func (_afe CellProperties) X() *_ec.CT_TcPr { return _afe._adfg }

// TableConditionalFormatting controls the conditional formatting within a table
// style.
type TableConditionalFormatting struct{ _cbdbe *_ec.CT_TblStylePr }

// IsChecked returns true if a FormFieldTypeCheckBox is checked.
func (_ega FormField) IsChecked() bool {
	if _ega._bef.CheckBox == nil {
		return false
	}
	if _ega._bef.CheckBox.Checked != nil {
		return true
	}
	return false
}

// Emboss returns true if run emboss is on.
func (_fcfdc RunProperties) Emboss() bool { return _gebc(_fcfdc._eeab.Emboss) }

// AddParagraph adds a paragraph to the endnote.
func (_dgd Endnote) AddParagraph() Paragraph {
	_eaeee := _ec.NewEG_ContentBlockContent()
	_dcad := len(_dgd._acca.EG_BlockLevelElts[0].EG_ContentBlockContent)
	_dgd._acca.EG_BlockLevelElts[0].EG_ContentBlockContent = append(_dgd._acca.EG_BlockLevelElts[0].EG_ContentBlockContent, _eaeee)
	_gfca := _ec.NewCT_P()
	var _dge *_ec.CT_String
	if _dcad != 0 {
		_gfgg := len(_dgd._acca.EG_BlockLevelElts[0].EG_ContentBlockContent[_dcad-1].P)
		_dge = _dgd._acca.EG_BlockLevelElts[0].EG_ContentBlockContent[_dcad-1].P[_gfgg-1].PPr.PStyle
	} else {
		_dge = _ec.NewCT_String()
		_dge.ValAttr = "\u0045n\u0064\u006e\u006f\u0074\u0065"
	}
	_eaeee.P = append(_eaeee.P, _gfca)
	_gefg := Paragraph{_dgd._gafe, _gfca}
	_gefg._bbee.PPr = _ec.NewCT_PPr()
	_gefg._bbee.PPr.PStyle = _dge
	_gefg._bbee.PPr.RPr = _ec.NewCT_ParaRPr()
	return _gefg
}

// SetImprint sets the run to imprinted text.
func (_eaefg RunProperties) SetImprint(b bool) {
	if !b {
		_eaefg._eeab.Imprint = nil
	} else {
		_eaefg._eeab.Imprint = _ec.NewCT_OnOff()
	}
}

func (_agac Footnote) content() []*_ec.EG_ContentBlockContent {
	var _acec []*_ec.EG_ContentBlockContent
	for _, _ccaf := range _agac._dded.EG_BlockLevelElts {
		_acec = append(_acec, _ccaf.EG_ContentBlockContent...)
	}
	return _acec
}

// FormField is a form within a document. It references the document, so changes
// to the form field wil be reflected in the document if it is saved.
type FormField struct {
	_bef  *_ec.CT_FFData
	_adbc *_ec.EG_RunInnerContent
}

// X returns the inner wrapped XML type.
func (_cc Bookmark) X() *_ec.CT_Bookmark { return _cc._bde }

// AddRun adds a run to a paragraph.
func (_fead Paragraph) AddRun() Run {
	_edca := _ec.NewEG_PContent()
	_fead._bbee.EG_PContent = append(_fead._bbee.EG_PContent, _edca)
	_ebc := _ec.NewEG_ContentRunContent()
	_edca.EG_ContentRunContent = append(_edca.EG_ContentRunContent, _ebc)
	_facf := _ec.NewCT_R()
	_ebc.R = _facf
	return Run{_fead._baf, _facf}
}

func (_dgag Paragraph) ensurePPr() {
	if _dgag._bbee.PPr == nil {
		_dgag._bbee.PPr = _ec.NewCT_PPr()
	}
}

// Bold returns true if run font is bold.
func (_gdfd RunProperties) Bold() bool {
	_cafg := _gdfd._eeab
	return _gebc(_cafg.B) || _gebc(_cafg.BCs)
}

// SetUISortOrder controls the order the style is displayed in the UI.
func (_dggg Style) SetUISortOrder(order int) {
	_dggg._dacg.UiPriority = _ec.NewCT_DecimalNumber()
	_dggg._dacg.UiPriority.ValAttr = int64(order)
}

// SetCharacterSpacing sets the run's Character Spacing Adjustment.
func (_dgce RunProperties) SetCharacterSpacing(size _fg.Distance) {
	_dgce._eeab.Spacing = _ec.NewCT_SignedTwipsMeasure()
	_dgce._eeab.Spacing.ValAttr.Int64 = _e.Int64(int64(size / _fg.Twips))
}

// SetWidthAuto sets the the table width to automatic.
func (_fece TableProperties) SetWidthAuto() {
	_fece._ddac.TblW = _ec.NewCT_TblWidth()
	_fece._ddac.TblW.TypeAttr = _ec.ST_TblWidthAuto
}

// AddTabStop adds a tab stop to the paragraph.
func (_daba ParagraphStyleProperties) AddTabStop(position _fg.Distance, justificaton _ec.ST_TabJc, leader _ec.ST_TabTlc) {
	if _daba._abef.Tabs == nil {
		_daba._abef.Tabs = _ec.NewCT_Tabs()
	}
	_ggfeg := _ec.NewCT_TabStop()
	_ggfeg.LeaderAttr = leader
	_ggfeg.ValAttr = justificaton
	_ggfeg.PosAttr.Int64 = _e.Int64(int64(position / _fg.Twips))
	_daba._abef.Tabs.Tab = append(_daba._abef.Tabs.Tab, _ggfeg)
}

// AddTable adds a table to the table cell.
func (_fb Cell) AddTable() Table {
	_add := _ec.NewEG_BlockLevelElts()
	_fb._dae.EG_BlockLevelElts = append(_fb._dae.EG_BlockLevelElts, _add)
	_egb := _ec.NewEG_ContentBlockContent()
	_add.EG_ContentBlockContent = append(_add.EG_ContentBlockContent, _egb)
	_dc := _ec.NewCT_Tbl()
	_egb.Tbl = append(_egb.Tbl, _dc)
	return Table{_fb._ged, _dc}
}

// NumberingDefinition defines a numbering definition for a list of pragraphs.
type NumberingDefinition struct{ _gafdd *_ec.CT_AbstractNum }

// NumberingLevel is the definition for numbering for a particular level within
// a NumberingDefinition.
type NumberingLevel struct{ _dccb *_ec.CT_Lvl }

// SetVerticalBanding controls the conditional formatting for vertical banding.
func (_adgc TableLook) SetVerticalBanding(on bool) {
	if !on {
		_adgc._bafa.NoVBandAttr = &_bc.ST_OnOff{}
		_adgc._bafa.NoVBandAttr.ST_OnOff1 = _bc.ST_OnOff1On
	} else {
		_adgc._bafa.NoVBandAttr = &_bc.ST_OnOff{}
		_adgc._bafa.NoVBandAttr.ST_OnOff1 = _bc.ST_OnOff1Off
	}
}

// SetEndIndent controls the end indentation.
func (_ceed ParagraphProperties) SetEndIndent(m _fg.Distance) {
	if _ceed._aeda.Ind == nil {
		_ceed._aeda.Ind = _ec.NewCT_Ind()
	}
	if m == _fg.Zero {
		_ceed._aeda.Ind.EndAttr = nil
	} else {
		_ceed._aeda.Ind.EndAttr = &_ec.ST_SignedTwipsMeasure{}
		_ceed._aeda.Ind.EndAttr.Int64 = _e.Int64(int64(m / _fg.Twips))
	}
}

// SetTextWrapSquare sets the text wrap to square with a given wrap type.
func (_eg AnchoredDrawing) SetTextWrapSquare(t _ec.WdST_WrapText) {
	_eg._fc.Choice = &_ec.WdEG_WrapTypeChoice{}
	_eg._fc.Choice.WrapSquare = _ec.NewWdCT_WrapSquare()
	_eg._fc.Choice.WrapSquare.WrapTextAttr = t
}

// Levels returns all of the numbering levels defined in the definition.
func (_ddfg NumberingDefinition) Levels() []NumberingLevel {
	_efc := []NumberingLevel{}
	for _, _eebb := range _ddfg._gafdd.Lvl {
		_efc = append(_efc, NumberingLevel{_eebb})
	}
	return _efc
}

// Borders allows manipulation of the table borders.
func (_feggd TableProperties) Borders() TableBorders {
	if _feggd._ddac.TblBorders == nil {
		_feggd._ddac.TblBorders = _ec.NewCT_TblBorders()
	}
	return TableBorders{_feggd._ddac.TblBorders}
}

// SetUnderline controls underline for a run style.
func (_cdba RunProperties) SetUnderline(style _ec.ST_Underline, c _ga.Color) {
	if style == _ec.ST_UnderlineUnset {
		_cdba._eeab.U = nil
	} else {
		_cdba._eeab.U = _ec.NewCT_Underline()
		_cdba._eeab.U.ColorAttr = &_ec.ST_HexColor{}
		_cdba._eeab.U.ColorAttr.ST_HexColorRGB = c.AsRGBString()
		_cdba._eeab.U.ValAttr = style
	}
}

// SetOutlineLevel sets the outline level of this style.
func (_ddfb ParagraphStyleProperties) SetOutlineLevel(lvl int) {
	_ddfb._abef.OutlineLvl = _ec.NewCT_DecimalNumber()
	_ddfb._abef.OutlineLvl.ValAttr = int64(lvl)
}

// SetCellSpacingAuto sets the cell spacing within a table to automatic.
func (_bfgg TableStyleProperties) SetCellSpacingAuto() {
	_bfgg._addg.TblCellSpacing = _ec.NewCT_TblWidth()
	_bfgg._addg.TblCellSpacing.TypeAttr = _ec.ST_TblWidthAuto
}

// SetPageMargins sets the page margins for a section
func (_eefag Section) SetPageMargins(top, right, bottom, left, header, footer, gutter _fg.Distance) {
	_bfgd := _ec.NewCT_PageMar()
	_bfgd.TopAttr.Int64 = _e.Int64(int64(top / _fg.Twips))
	_bfgd.BottomAttr.Int64 = _e.Int64(int64(bottom / _fg.Twips))
	_bfgd.RightAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(right / _fg.Twips))
	_bfgd.LeftAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(left / _fg.Twips))
	_bfgd.HeaderAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(header / _fg.Twips))
	_bfgd.FooterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(footer / _fg.Twips))
	_bfgd.GutterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(gutter / _fg.Twips))
	_eefag._efad.PgMar = _bfgd
}

func (_gcef Paragraph) addStartBookmark(_aae int64, _geae string) *_ec.CT_Bookmark {
	_bbefb := _ec.NewEG_PContent()
	_gcef._bbee.EG_PContent = append(_gcef._bbee.EG_PContent, _bbefb)
	_ddce := _ec.NewEG_ContentRunContent()
	_gegge := _ec.NewEG_RunLevelElts()
	_fgbb := _ec.NewEG_RangeMarkupElements()
	_aaee := _ec.NewCT_Bookmark()
	_aaee.NameAttr = _geae
	_aaee.IdAttr = _aae
	_fgbb.BookmarkStart = _aaee
	_bbefb.EG_ContentRunContent = append(_bbefb.EG_ContentRunContent, _ddce)
	_ddce.EG_RunLevelElts = append(_ddce.EG_RunLevelElts, _gegge)
	_gegge.EG_RangeMarkupElements = append(_gegge.EG_RangeMarkupElements, _fgbb)
	return _aaee
}

func (_bbb *Document) validateBookmarks() error {
	_gdc := make(map[string]struct{})
	for _, _gae := range _bbb.Bookmarks() {
		if _, _cdgg := _gdc[_gae.Name()]; _cdgg {
			return _cfc.Errorf("d\u0075\u0070\u006c\u0069\u0063\u0061t\u0065\u0020\u0062\u006f\u006f\u006b\u006d\u0061\u0072k\u0020\u0025\u0073 \u0066o\u0075\u006e\u0064", _gae.Name())
		}
		_gdc[_gae.Name()] = struct{}{}
	}
	return nil
}

// InitializeDefault constructs a default numbering.
func (_edce Numbering) InitializeDefault() {
	_cdc := _ec.NewCT_AbstractNum()
	_cdc.MultiLevelType = _ec.NewCT_MultiLevelType()
	_cdc.MultiLevelType.ValAttr = _ec.ST_MultiLevelTypeHybridMultilevel
	_edce._ebge.AbstractNum = append(_edce._ebge.AbstractNum, _cdc)
	_cdc.AbstractNumIdAttr = 1
	const _bdfa = 720
	const _cafa = 720
	const _fcb = 360
	for _eabgc := 0; _eabgc < 9; _eabgc++ {
		_caefd := _ec.NewCT_Lvl()
		_caefd.IlvlAttr = int64(_eabgc)
		_caefd.Start = _ec.NewCT_DecimalNumber()
		_caefd.Start.ValAttr = 1
		_caefd.NumFmt = _ec.NewCT_NumFmt()
		_caefd.NumFmt.ValAttr = _ec.ST_NumberFormatBullet
		_caefd.Suff = _ec.NewCT_LevelSuffix()
		_caefd.Suff.ValAttr = _ec.ST_LevelSuffixNothing
		_caefd.LvlText = _ec.NewCT_LevelText()
		_caefd.LvlText.ValAttr = _e.String("\uf0b7")
		_caefd.LvlJc = _ec.NewCT_Jc()
		_caefd.LvlJc.ValAttr = _ec.ST_JcLeft
		_caefd.RPr = _ec.NewCT_RPr()
		_caefd.RPr.RFonts = _ec.NewCT_Fonts()
		_caefd.RPr.RFonts.AsciiAttr = _e.String("\u0053\u0079\u006d\u0062\u006f\u006c")
		_caefd.RPr.RFonts.HAnsiAttr = _e.String("\u0053\u0079\u006d\u0062\u006f\u006c")
		_caefd.RPr.RFonts.HintAttr = _ec.ST_HintDefault
		_caefd.PPr = _ec.NewCT_PPrGeneral()
		_feaa := int64(_eabgc*_cafa + _bdfa)
		_caefd.PPr.Ind = _ec.NewCT_Ind()
		_caefd.PPr.Ind.LeftAttr = &_ec.ST_SignedTwipsMeasure{}
		_caefd.PPr.Ind.LeftAttr.Int64 = _e.Int64(_feaa)
		_caefd.PPr.Ind.HangingAttr = &_bc.ST_TwipsMeasure{}
		_caefd.PPr.Ind.HangingAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(_fcb))
		_cdc.Lvl = append(_cdc.Lvl, _caefd)
	}
	_dedc := _ec.NewCT_Num()
	_dedc.NumIdAttr = 1
	_dedc.AbstractNumId = _ec.NewCT_DecimalNumber()
	_dedc.AbstractNumId.ValAttr = 1
	_edce._ebge.Num = append(_edce._ebge.Num, _dedc)
}

// SetNumberingLevel sets the numbering level of a paragraph.  If used, then the
// NumberingDefinition must also be set via SetNumberingDefinition or
// SetNumberingDefinitionByID.
func (_ebcd Paragraph) SetNumberingLevel(listLevel int) {
	_ebcd.ensurePPr()
	if _ebcd._bbee.PPr.NumPr == nil {
		_ebcd._bbee.PPr.NumPr = _ec.NewCT_NumPr()
	}
	_faaef := _ec.NewCT_DecimalNumber()
	_faaef.ValAttr = int64(listLevel)
	_ebcd._bbee.PPr.NumPr.Ilvl = _faaef
}

// SetSpacing sets the spacing that comes before and after the paragraph.
// Deprecated: See Spacing() instead which allows finer control.
func (_dcdf ParagraphProperties) SetSpacing(before, after _fg.Distance) {
	if _dcdf._aeda.Spacing == nil {
		_dcdf._aeda.Spacing = _ec.NewCT_Spacing()
	}
	_dcdf._aeda.Spacing.BeforeAttr = &_bc.ST_TwipsMeasure{}
	_dcdf._aeda.Spacing.BeforeAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(before / _fg.Twips))
	_dcdf._aeda.Spacing.AfterAttr = &_bc.ST_TwipsMeasure{}
	_dcdf._aeda.Spacing.AfterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(after / _fg.Twips))
}

// SetTarget sets the URL target of the hyperlink.
func (_aafc HyperLink) SetTarget(url string) {
	_ffde := _aafc._dgdb.AddHyperlink(url)
	_aafc._eabea.IdAttr = _e.String(_gc.Relationship(_ffde).ID())
	_aafc._eabea.AnchorAttr = nil
}

// SetName sets the name of the image, visible in the properties of the image
// within Word.
func (_gac AnchoredDrawing) SetName(name string) {
	_gac._fc.DocPr.NameAttr = name
	for _, _ecg := range _gac._fc.Graphic.GraphicData.Any {
		if _gcg, _agf := _ecg.(*_ad.Pic); _agf {
			_gcg.NvPicPr.CNvPr.DescrAttr = _e.String(name)
		}
	}
}

// Paragraphs returns the paragraphs defined in an endnote.
func (_eabg Endnote) Paragraphs() []Paragraph {
	_fggfd := []Paragraph{}
	for _, _ffce := range _eabg.content() {
		for _, _cgeb := range _ffce.P {
			_fggfd = append(_fggfd, Paragraph{_eabg._gafe, _cgeb})
		}
	}
	return _fggfd
}

// X returns the inner wrapped XML type.
func (_dcge Color) X() *_ec.CT_Color { return _dcge._bca }

// InsertRunAfter inserts a run in the paragraph after the relative run.
func (_cfbd Paragraph) InsertRunAfter(relativeTo Run) Run {
	return _cfbd.insertRun(relativeTo, false)
}

// CharacterSpacingValue returns the value of characters spacing in twips (1/20 of point).
func (_abeb ParagraphProperties) CharacterSpacingValue() int64 {
	if _edaea := _abeb._aeda.RPr.Spacing; _edaea != nil {
		_bdgc := _edaea.ValAttr
		if _bdgc.Int64 != nil {
			return *_bdgc.Int64
		}
	}
	return int64(0)
}

func (_dga *Document) InsertTableBefore(relativeTo Paragraph) Table {
	return _dga.insertTable(relativeTo, true)
}

// HyperLink is a link within a document.
type HyperLink struct {
	_dgdb  *Document
	_eabea *_ec.CT_Hyperlink
}

// Properties returns the table properties.
func (_gbegc Table) Properties() TableProperties {
	if _gbegc._adgg.TblPr == nil {
		_gbegc._adgg.TblPr = _ec.NewCT_TblPr()
	}
	return TableProperties{_gbegc._adgg.TblPr}
}

func (_gcf *Document) createCustomProperties() {
	_gcf.CustomProperties = _gc.NewCustomProperties()
	_gcf.addCustomRelationships()
}

// Paragraphs returns the paragraphs defined in a footer.
func (_cecaf Footer) Paragraphs() []Paragraph {
	_feae := []Paragraph{}
	for _, _bdag := range _cecaf._abd.EG_ContentBlockContent {
		for _, _bebd := range _bdag.P {
			_feae = append(_feae, Paragraph{_cecaf._bcf, _bebd})
		}
	}
	for _, _bfcc := range _cecaf.Tables() {
		for _, _edbg := range _bfcc.Rows() {
			for _, _dfdf := range _edbg.Cells() {
				_feae = append(_feae, _dfdf.Paragraphs()...)
			}
		}
	}
	return _feae
}

// GetImage returns the ImageRef associated with an InlineDrawing.
func (_ddcb InlineDrawing) GetImage() (_gc.ImageRef, bool) {
	_fdde := _ddcb._aebg.Graphic.GraphicData.Any
	if len(_fdde) > 0 {
		_faf, _adee := _fdde[0].(*_ad.Pic)
		if _adee {
			if _faf.BlipFill != nil && _faf.BlipFill.Blip != nil && _faf.BlipFill.Blip.EmbedAttr != nil {
				return _ddcb._bgga.GetImageByRelID(*_faf.BlipFill.Blip.EmbedAttr)
			}
		}
	}
	return _gc.ImageRef{}, false
}

// SaveToFile writes the document out to a file.
func (_fgbf *Document) SaveToFile(path string) error {
	_fgeb, _dbaa := _ag.Create(path)
	if _dbaa != nil {
		return _dbaa
	}
	defer _fgeb.Close()
	return _fgbf.Save(_fgeb)
}

// Open opens and reads a document from a file (.docx).
func Open(filename string) (*Document, error) {
	_cbd, _ced := _ag.Open(filename)
	if _ced != nil {
		return nil, _cfc.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _ced)
	}
	defer _cbd.Close()
	_fffc, _ced := _ag.Stat(filename)
	if _ced != nil {
		return nil, _cfc.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _ced)
	}
	_ = _fffc
	return Read(_cbd, _fffc.Size())
}

func _cfb(_ddb *_ec.EG_ContentBlockContent) []Bookmark {
	_bded := []Bookmark{}
	for _, _gaab := range _ddb.P {
		for _, _dacc := range _gaab.EG_PContent {
			for _, _eebf := range _dacc.EG_ContentRunContent {
				for _, _cdfb := range _eebf.EG_RunLevelElts {
					for _, _afb := range _cdfb.EG_RangeMarkupElements {
						if _afb.BookmarkStart != nil {
							_bded = append(_bded, Bookmark{_afb.BookmarkStart})
						}
					}
				}
			}
		}
	}
	for _, _edb := range _ddb.EG_RunLevelElts {
		for _, _effg := range _edb.EG_RangeMarkupElements {
			if _effg.BookmarkStart != nil {
				_bded = append(_bded, Bookmark{_effg.BookmarkStart})
			}
		}
	}
	for _, _agdfg := range _ddb.Tbl {
		for _, _cgbb := range _agdfg.EG_ContentRowContent {
			for _, _caef := range _cgbb.Tr {
				for _, _gaad := range _caef.EG_ContentCellContent {
					for _, _dfcc := range _gaad.Tc {
						for _, _agg := range _dfcc.EG_BlockLevelElts {
							for _, _ggdc := range _agg.EG_ContentBlockContent {
								for _, _ecfe := range _cfb(_ggdc) {
									_bded = append(_bded, _ecfe)
								}
							}
						}
					}
				}
			}
		}
	}
	return _bded
}

// SetInsideHorizontal sets the interior horizontal borders to a specified type, color and thickness.
func (_gfcfe TableBorders) SetInsideHorizontal(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_gfcfe._bcd.InsideH = _ec.NewCT_Border()
	_edfca(_gfcfe._bcd.InsideH, t, c, thickness)
}

// SetTop sets the top border to a specified type, color and thickness.
func (_ce CellBorders) SetTop(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_ce._dcb.Top = _ec.NewCT_Border()
	_edfca(_ce._dcb.Top, t, c, thickness)
}

type mergeFieldInfo struct {
	_faac               string
	_gdga               string
	_gdda               string
	_dcca               bool
	_fedg               bool
	_bgcaa              bool
	_fcfef              bool
	_fagc               Paragraph
	_edbc, _bgcf, _bbbg int
	_edbgb              *_ec.EG_PContent
	_cdbee              bool
}

const (
	FormFieldTypeUnknown FormFieldType = iota
	FormFieldTypeText
	FormFieldTypeCheckBox
	FormFieldTypeDropDown
)

// SetStyle sets the font size.
func (_deeb RunProperties) SetStyle(style string) {
	if style == "" {
		_deeb._eeab.RStyle = nil
	} else {
		_deeb._eeab.RStyle = _ec.NewCT_String()
		_deeb._eeab.RStyle.ValAttr = style
	}
}

// SetBottom sets the bottom border to a specified type, color and thickness.
func (_ab CellBorders) SetBottom(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_ab._dcb.Bottom = _ec.NewCT_Border()
	_edfca(_ab._dcb.Bottom, t, c, thickness)
}

// Endnote returns the endnote based on the ID; this can be used nicely with
// the run.IsEndnote() functionality.
func (_geg *Document) Endnote(id int64) Endnote {
	for _, _feg := range _geg.Endnotes() {
		if _feg.id() == id {
			return _feg
		}
	}
	return Endnote{}
}

// AddRow adds a row to a table.
func (_ggcg Table) AddRow() Row {
	_adbf := _ec.NewEG_ContentRowContent()
	_ggcg._adgg.EG_ContentRowContent = append(_ggcg._adgg.EG_ContentRowContent, _adbf)
	_caefg := _ec.NewCT_Row()
	_adbf.Tr = append(_adbf.Tr, _caefg)
	return Row{_ggcg._ffdb, _caefg}
}

// Outline returns true if run outline is on.
func (_abce RunProperties) Outline() bool { return _gebc(_abce._eeab.Outline) }

// SetLeft sets the left border to a specified type, color and thickness.
func (_aceda TableBorders) SetLeft(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_aceda._bcd.Left = _ec.NewCT_Border()
	_edfca(_aceda._bcd.Left, t, c, thickness)
}

// AnchoredDrawing is an absolutely positioned image within a document page.
type AnchoredDrawing struct {
	_gd *Document
	_fc *_ec.WdAnchor
}

// Font returns the name of run font family.
func (_ecece RunProperties) Font() string {
	if _dcabg := _ecece._eeab.RFonts; _dcabg != nil {
		if _dcabg.AsciiAttr != nil {
			return *_dcabg.AsciiAttr
		} else if _dcabg.HAnsiAttr != nil {
			return *_dcabg.HAnsiAttr
		} else if _dcabg.CsAttr != nil {
			return *_dcabg.CsAttr
		}
	}
	return ""
}

// Paragraphs returns the paragraphs defined in the cell.
func (_cfe Cell) Paragraphs() []Paragraph {
	_dgg := []Paragraph{}
	for _, _bdb := range _cfe._dae.EG_BlockLevelElts {
		for _, _ddc := range _bdb.EG_ContentBlockContent {
			for _, _bbe := range _ddc.P {
				_dgg = append(_dgg, Paragraph{_cfe._ged, _bbe})
			}
		}
	}
	return _dgg
}

// Margins allows controlling individual cell margins.
func (_be CellProperties) Margins() CellMargins {
	if _be._adfg.TcMar == nil {
		_be._adfg.TcMar = _ec.NewCT_TcMar()
	}
	return CellMargins{_be._adfg.TcMar}
}

// X returns the inner wrapped XML type.
func (_dd AnchoredDrawing) X() *_ec.WdAnchor { return _dd._fc }

// SetVerticalMerge controls the vertical merging of cells.
func (_adbg CellProperties) SetVerticalMerge(mergeVal _ec.ST_Merge) {
	if mergeVal == _ec.ST_MergeUnset {
		_adbg._adfg.VMerge = nil
	} else {
		_adbg._adfg.VMerge = _ec.NewCT_VMerge()
		_adbg._adfg.VMerge.ValAttr = mergeVal
	}
}

// SetAfter sets the spacing that comes after the paragraph.
func (_cbda ParagraphSpacing) SetAfter(after _fg.Distance) {
	_cbda._agffc.AfterAttr = &_bc.ST_TwipsMeasure{}
	_cbda._agffc.AfterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(after / _fg.Twips))
}

// Italic returns true if paragraph font is italic.
func (_bed ParagraphProperties) Italic() bool {
	_dbda := _bed._aeda.RPr
	return _gebc(_dbda.I) || _gebc(_dbda.ICs)
}

// SetLastRow controls the conditional formatting for the last row in a table.
// This is called the 'Total' row within Word.
func (_agea TableLook) SetLastRow(on bool) {
	if !on {
		_agea._bafa.LastRowAttr = &_bc.ST_OnOff{}
		_agea._bafa.LastRowAttr.ST_OnOff1 = _bc.ST_OnOff1Off
	} else {
		_agea._bafa.LastRowAttr = &_bc.ST_OnOff{}
		_agea._bafa.LastRowAttr.ST_OnOff1 = _bc.ST_OnOff1On
	}
}

// SetColumnSpan sets the number of Grid Columns Spanned by the Cell.  This is used
// to give the appearance of merged cells.
func (_gg CellProperties) SetColumnSpan(cols int) {
	if cols == 0 {
		_gg._adfg.GridSpan = nil
	} else {
		_gg._adfg.GridSpan = _ec.NewCT_DecimalNumber()
		_gg._adfg.GridSpan.ValAttr = int64(cols)
	}
}

// TableProperties returns the table style properties.
func (_deccg Style) TableProperties() TableStyleProperties {
	if _deccg._dacg.TblPr == nil {
		_deccg._dacg.TblPr = _ec.NewCT_TblPrBase()
	}
	return TableStyleProperties{_deccg._dacg.TblPr}
}

func (_fffca Endnote) content() []*_ec.EG_ContentBlockContent {
	var _caefc []*_ec.EG_ContentBlockContent
	for _, _cgga := range _fffca._acca.EG_BlockLevelElts {
		_caefc = append(_caefc, _cgga.EG_ContentBlockContent...)
	}
	return _caefc
}

// RightToLeft returns true if run text goes from right to left.
func (_cgcda RunProperties) RightToLeft() bool { return _gebc(_cgcda._eeab.Rtl) }

// AddImage adds an image to the document package, returning a reference that
// can be used to add the image to a run and place it in the document contents.
func (_cfg *Document) AddImage(i _gc.Image) (_gc.ImageRef, error) {
	_gedg := _gc.MakeImageRef(i, &_cfg.DocBase, _cfg._cgg)
	if i.Data == nil && i.Path == "" {
		return _gedg, _bf.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _gedg, _bf.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _gedg, _bf.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	if i.Path != "" {
		_cfa := _ba.Add(i.Path)
		if _cfa != nil {
			return _gedg, _cfa
		}
	}
	_cfg.Images = append(_cfg.Images, _gedg)
	_gag := _cfc.Sprintf("\u006d\u0065d\u0069\u0061\u002fi\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", len(_cfg.Images), i.Format)
	_baea := _cfg._cgg.AddRelationship(_gag, _e.ImageType)
	_cfg.ContentTypes.EnsureDefault("\u0070\u006e\u0067", "\u0069m\u0061\u0067\u0065\u002f\u0070\u006eg")
	_cfg.ContentTypes.EnsureDefault("\u006a\u0070\u0065\u0067", "\u0069\u006d\u0061\u0067\u0065\u002f\u006a\u0070\u0065\u0067")
	_cfg.ContentTypes.EnsureDefault("\u006a\u0070\u0067", "\u0069\u006d\u0061\u0067\u0065\u002f\u006a\u0070\u0065\u0067")
	_cfg.ContentTypes.EnsureDefault("\u0077\u006d\u0066", "i\u006d\u0061\u0067\u0065\u002f\u0078\u002d\u0077\u006d\u0066")
	_cfg.ContentTypes.EnsureDefault(i.Format, "\u0069\u006d\u0061\u0067\u0065\u002f"+i.Format)
	_gedg.SetRelID(_baea.X().IdAttr)
	return _gedg, nil
}

// Document is a text document that can be written out in the OOXML .docx
// format. It can be opened from a file on disk and modified, or created from
// scratch.
type Document struct {
	_gc.DocBase
	_bbef     *_ec.Document
	Settings  Settings
	Numbering Numbering
	Styles    Styles
	_dfe      []*_ec.Hdr
	_de       []_gc.Relationships
	_ead      []*_ec.Ftr
	_ecc      []_gc.Relationships
	_cgg      _gc.Relationships
	_cbag     []*_eff.Theme
	_baeb     *_ec.WebSettings
	_fac      *_ec.Fonts
	_fgg      *_ec.Endnotes
	_dea      *_ec.Footnotes
}

// ParagraphStyleProperties is the styling information for a paragraph.
type ParagraphStyleProperties struct{ _abef *_ec.CT_PPrGeneral }

// Validate validates the structure and in cases where it't possible, the ranges
// of elements within a document. A validation error dones't mean that the
// document won't work in MS Word or LibreOffice, but it's worth checking into.
func (_cbg *Document) Validate() error {
	if _cbg == nil || _cbg._bbef == nil {
		return _bf.New("\u0064o\u0063\u0075m\u0065\u006e\u0074\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065")
	}
	for _, _cda := range []func() error{_cbg.validateTableCells, _cbg.validateBookmarks} {
		if _ebgf := _cda(); _ebgf != nil {
			return _ebgf
		}
	}
	if _gge := _cbg._bbef.Validate(); _gge != nil {
		return _gge
	}
	return nil
}

// Bookmarks returns all of the bookmarks defined in the document.
func (_fedc Document) Bookmarks() []Bookmark {
	if _fedc._bbef.Body == nil {
		return nil
	}
	_eedg := []Bookmark{}
	for _, _dgc := range _fedc._bbef.Body.EG_BlockLevelElts {
		for _, _fea := range _dgc.EG_ContentBlockContent {
			for _, _dec := range _cfb(_fea) {
				_eedg = append(_eedg, _dec)
			}
		}
	}
	return _eedg
}

// SetTopPct sets the cell top margin
func (_gcb CellMargins) SetTopPct(pct float64) {
	_gcb._cba.Top = _ec.NewCT_TblWidth()
	_eef(_gcb._cba.Top, pct)
}

// TableStyleProperties are table properties as defined in a style.
type TableStyleProperties struct{ _addg *_ec.CT_TblPrBase }

// TableLook returns the table look, or conditional formatting applied to a table style.
func (_agceeb TableProperties) TableLook() TableLook {
	if _agceeb._ddac.TblLook == nil {
		_agceeb._ddac.TblLook = _ec.NewCT_TblLook()
	}
	return TableLook{_agceeb._ddac.TblLook}
}

// SetFirstLineIndent controls the indentation of the first line in a paragraph.
func (_efbfa ParagraphProperties) SetFirstLineIndent(m _fg.Distance) {
	if _efbfa._aeda.Ind == nil {
		_efbfa._aeda.Ind = _ec.NewCT_Ind()
	}
	if m == _fg.Zero {
		_efbfa._aeda.Ind.FirstLineAttr = nil
	} else {
		_efbfa._aeda.Ind.FirstLineAttr = &_bc.ST_TwipsMeasure{}
		_efbfa._aeda.Ind.FirstLineAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _fg.Twips))
	}
}

// DrawingAnchored returns a slice of AnchoredDrawings.
func (_gdbfd Run) DrawingAnchored() []AnchoredDrawing {
	_bfga := []AnchoredDrawing{}
	for _, _fecd := range _gdbfd._cbaga.EG_RunInnerContent {
		if _fecd.Drawing == nil {
			continue
		}
		for _, _cgbbb := range _fecd.Drawing.Anchor {
			_bfga = append(_bfga, AnchoredDrawing{_gdbfd._afea, _cgbbb})
		}
	}
	return _bfga
}

// TableConditionalFormatting returns a conditional formatting object of a given
// type.  Calling this method repeatedly will return the same object.
func (_ccgdc Style) TableConditionalFormatting(typ _ec.ST_TblStyleOverrideType) TableConditionalFormatting {
	for _, _dgac := range _ccgdc._dacg.TblStylePr {
		if _dgac.TypeAttr == typ {
			return TableConditionalFormatting{_dgac}
		}
	}
	_gdeec := _ec.NewCT_TblStylePr()
	_gdeec.TypeAttr = typ
	_ccgdc._dacg.TblStylePr = append(_ccgdc._dacg.TblStylePr, _gdeec)
	return TableConditionalFormatting{_gdeec}
}

// SetAlignment controls the paragraph alignment
func (_eabbb ParagraphStyleProperties) SetAlignment(align _ec.ST_Jc) {
	if align == _ec.ST_JcUnset {
		_eabbb._abef.Jc = nil
	} else {
		_eabbb._abef.Jc = _ec.NewCT_Jc()
		_eabbb._abef.Jc.ValAttr = align
	}
}

// SetTop sets the cell top margin
func (_gdf CellMargins) SetTop(d _fg.Distance) {
	_gdf._cba.Top = _ec.NewCT_TblWidth()
	_fcf(_gdf._cba.Top, d)
}

// RightToLeft returns true if paragraph text goes from right to left.
func (_egag ParagraphProperties) RightToLeft() bool { return _gebc(_egag._aeda.RPr.Rtl) }

// ClearContent clears any content in the run (text, tabs, breaks, etc.)
func (_fcgfef Run) ClearContent() { _fcgfef._cbaga.EG_RunInnerContent = nil }

// SetOrigin sets the origin of the image.  It defaults to ST_RelFromHPage and
// ST_RelFromVPage
func (_fe AnchoredDrawing) SetOrigin(h _ec.WdST_RelFromH, v _ec.WdST_RelFromV) {
	_fe._fc.PositionH.RelativeFromAttr = h
	_fe._fc.PositionV.RelativeFromAttr = v
}

// Underline returns the type of paragraph underline.
func (_edad ParagraphProperties) Underline() _ec.ST_Underline {
	if _gaadc := _edad._aeda.RPr.U; _gaadc != nil {
		return _gaadc.ValAttr
	}
	return 0
}

// GetImage returns the ImageRef associated with an AnchoredDrawing.
func (_ea AnchoredDrawing) GetImage() (_gc.ImageRef, bool) {
	_db := _ea._fc.Graphic.GraphicData.Any
	if len(_db) > 0 {
		_ada, _bfb := _db[0].(*_ad.Pic)
		if _bfb {
			if _ada.BlipFill != nil && _ada.BlipFill.Blip != nil && _ada.BlipFill.Blip.EmbedAttr != nil {
				return _ea._gd.GetImageByRelID(*_ada.BlipFill.Blip.EmbedAttr)
			}
		}
	}
	return _gc.ImageRef{}, false
}

// SizeMeasure returns font with its measure which can be mm, cm, in, pt, pc or pi.
func (_aacfb RunProperties) SizeMeasure() string {
	if _cbcgc := _aacfb._eeab.Sz; _cbcgc != nil {
		_cffa := _cbcgc.ValAttr
		if _cffa.ST_PositiveUniversalMeasure != nil {
			return *_cffa.ST_PositiveUniversalMeasure
		}
	}
	return ""
}

// Rows returns the rows defined in the table.
func (_cdgf Table) Rows() []Row {
	_dbfa := []Row{}
	for _, _acba := range _cdgf._adgg.EG_ContentRowContent {
		for _, _bgfga := range _acba.Tr {
			_dbfa = append(_dbfa, Row{_cdgf._ffdb, _bgfga})
		}
		if _acba.Sdt != nil && _acba.Sdt.SdtContent != nil {
			for _, _ccdb := range _acba.Sdt.SdtContent.Tr {
				_dbfa = append(_dbfa, Row{_cdgf._ffdb, _ccdb})
			}
		}
	}
	return _dbfa
}

// RunProperties returns the run properties controlling text formatting within the table.
func (_deeca TableConditionalFormatting) RunProperties() RunProperties {
	if _deeca._cbdbe.RPr == nil {
		_deeca._cbdbe.RPr = _ec.NewCT_RPr()
	}
	return RunProperties{_deeca._cbdbe.RPr}
}

// SetSmallCaps sets the run to small caps.
func (_aeed RunProperties) SetSmallCaps(b bool) {
	if !b {
		_aeed._eeab.SmallCaps = nil
	} else {
		_aeed._eeab.SmallCaps = _ec.NewCT_OnOff()
	}
}

// AddBreak adds a line break to a run.
func (_fggc Run) AddBreak() { _efdf := _fggc.newIC(); _efdf.Br = _ec.NewCT_Br() }

// AddSection adds a new document section with an optional section break.  If t
// is ST_SectionMarkUnset, then no break will be inserted.
func (_abg ParagraphProperties) AddSection(t _ec.ST_SectionMark) Section {
	_abg._aeda.SectPr = _ec.NewCT_SectPr()
	if t != _ec.ST_SectionMarkUnset {
		_abg._aeda.SectPr.Type = _ec.NewCT_SectType()
		_abg._aeda.SectPr.Type.ValAttr = t
	}
	return Section{_abg._fgbg, _abg._aeda.SectPr}
}

// AddHyperlink adds a hyperlink to a document. Adding the hyperlink to a document
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_aaca Document) AddHyperlink(url string) _gc.Hyperlink {
	return _aaca._cgg.AddHyperlink(url)
}

// RemoveParagraph removes a paragraph from a document.
func (_eed *Document) RemoveParagraph(p Paragraph) {
	if _eed._bbef.Body == nil {
		return
	}
	for _, _fca := range _eed._bbef.Body.EG_BlockLevelElts {
		for _, _afg := range _fca.EG_ContentBlockContent {
			for _eaa, _fdb := range _afg.P {
				if _fdb == p._bbee {
					copy(_afg.P[_eaa:], _afg.P[_eaa+1:])
					_afg.P = _afg.P[0 : len(_afg.P)-1]
					return
				}
			}
			if _afg.Sdt != nil && _afg.Sdt.SdtContent != nil && _afg.Sdt.SdtContent.P != nil {
				for _fdgcc, _ebf := range _afg.Sdt.SdtContent.P {
					if _ebf == p._bbee {
						copy(_afg.P[_fdgcc:], _afg.P[_fdgcc+1:])
						_afg.P = _afg.P[0 : len(_afg.P)-1]
						return
					}
				}
			}
		}
	}
}

// RStyle returns the name of character style.
// It is defined here http://officeopenxml.com/WPstyleCharStyles.php
func (_cdda RunProperties) RStyle() string {
	if _cdda._eeab.RStyle != nil {
		return _cdda._eeab.RStyle.ValAttr
	}
	return ""
}

// SetASCIITheme sets the font ASCII Theme.
func (_cecg Fonts) SetASCIITheme(t _ec.ST_Theme) { _cecg._dcade.AsciiThemeAttr = t }

// AddDropdownList adds dropdown list form field to the paragraph and returns it.
func (_edec Paragraph) AddDropdownList(name string) FormField {
	_deef := _edec.addFldCharsForField(name, "\u0046\u004f\u0052M\u0044\u0052\u004f\u0050\u0044\u004f\u0057\u004e")
	_deef._bef.DdList = _ec.NewCT_FFDDList()
	return _deef
}

// Paragraphs returns the paragraphs defined in a header.
func (_bagd Header) Paragraphs() []Paragraph {
	_cfcc := []Paragraph{}
	for _, _cbb := range _bagd._gca.EG_ContentBlockContent {
		for _, _begc := range _cbb.P {
			_cfcc = append(_cfcc, Paragraph{_bagd._fceb, _begc})
		}
	}
	for _, _cce := range _bagd.Tables() {
		for _, _gacf := range _cce.Rows() {
			for _, _ffec := range _gacf.Cells() {
				_cfcc = append(_cfcc, _ffec.Paragraphs()...)
			}
		}
	}
	return _cfcc
}

// Run is a run of text within a paragraph that shares the same formatting.
type Run struct {
	_afea  *Document
	_cbaga *_ec.CT_R
}

// SetColor sets a specific color or auto.
func (_efdg Color) SetColor(v _ga.Color) {
	if v.IsAuto() {
		_efdg._bca.ValAttr.ST_HexColorAuto = _ec.ST_HexColorAutoAuto
		_efdg._bca.ValAttr.ST_HexColorRGB = nil
	} else {
		_efdg._bca.ValAttr.ST_HexColorAuto = _ec.ST_HexColorAutoUnset
		_efdg._bca.ValAttr.ST_HexColorRGB = v.AsRGBString()
	}
}

// SetText sets the text to be used in bullet mode.
func (_fgcb NumberingLevel) SetText(t string) {
	if t == "" {
		_fgcb._dccb.LvlText = nil
	} else {
		_fgcb._dccb.LvlText = _ec.NewCT_LevelText()
		_fgcb._dccb.LvlText.ValAttr = _e.String(t)
	}
}

// Definitions returns the defined numbering definitions.
func (_gfcca Numbering) Definitions() []NumberingDefinition {
	_dece := []NumberingDefinition{}
	for _, _dcdc := range _gfcca._ebge.AbstractNum {
		_dece = append(_dece, NumberingDefinition{_dcdc})
	}
	return _dece
}

// SetLeftIndent controls the left indent of the paragraph.
func (_fbcd ParagraphStyleProperties) SetLeftIndent(m _fg.Distance) {
	if _fbcd._abef.Ind == nil {
		_fbcd._abef.Ind = _ec.NewCT_Ind()
	}
	if m == _fg.Zero {
		_fbcd._abef.Ind.LeftAttr = nil
	} else {
		_fbcd._abef.Ind.LeftAttr = &_ec.ST_SignedTwipsMeasure{}
		_fbcd._abef.Ind.LeftAttr.Int64 = _e.Int64(int64(m / _fg.Twips))
	}
}

// Headers returns the headers defined in the document.
func (_ege *Document) Headers() []Header {
	_dba := []Header{}
	for _, _eae := range _ege._dfe {
		_dba = append(_dba, Header{_ege, _eae})
	}
	return _dba
}

// SetBold sets the run to bold.
func (_edgf RunProperties) SetBold(b bool) {
	if !b {
		_edgf._eeab.B = nil
		_edgf._eeab.BCs = nil
	} else {
		_edgf._eeab.B = _ec.NewCT_OnOff()
		_edgf._eeab.BCs = _ec.NewCT_OnOff()
	}
}

// NewStyles constructs a new empty Styles
func NewStyles() Styles { return Styles{_ec.NewStyles()} }

// X returns the inner wrapped XML type.
func (_gbag NumberingLevel) X() *_ec.CT_Lvl { return _gbag._dccb }

// GetColor returns the color.Color object representing the run color.
func (_daee ParagraphProperties) GetColor() _ga.Color {
	if _dbc := _daee._aeda.RPr.Color; _dbc != nil {
		_edccg := _dbc.ValAttr
		if _edccg.ST_HexColorRGB != nil {
			return _ga.FromHex(*_edccg.ST_HexColorRGB)
		}
	}
	return _ga.Color{}
}

// RemoveParagraph removes a paragraph from the footnote.
func (_bbbe Footnote) RemoveParagraph(p Paragraph) {
	for _, _cbge := range _bbbe.content() {
		for _ccdg, _aggf := range _cbge.P {
			if _aggf == p._bbee {
				copy(_cbge.P[_ccdg:], _cbge.P[_ccdg+1:])
				_cbge.P = _cbge.P[0 : len(_cbge.P)-1]
				return
			}
		}
	}
}

// MailMerge finds mail merge fields and replaces them with the text provided.  It also removes
// the mail merge source info from the document settings.
func (_agdc *Document) MailMerge(mergeContent map[string]string) {
	_bgfb := _agdc.mergeFields()
	_ffdea := map[Paragraph][]Run{}
	for _, _feb := range _bgfb {
		_bdgf, _eefa := mergeContent[_feb._faac]
		if _eefa {
			if _feb._dcca {
				_bdgf = _g.ToUpper(_bdgf)
			} else if _feb._fedg {
				_bdgf = _g.ToLower(_bdgf)
			} else if _feb._fcfef {
				_bdgf = _g.Title(_bdgf)
			} else if _feb._bgcaa {
				_gdcd := _cf.Buffer{}
				for _dfcf, _caac := range _bdgf {
					if _dfcf == 0 {
						_gdcd.WriteRune(_a.ToUpper(_caac))
					} else {
						_gdcd.WriteRune(_caac)
					}
				}
				_bdgf = _gdcd.String()
			}
			if _bdgf != "" && _feb._gdda != "" {
				_bdgf = _feb._gdda + _bdgf
			}
			if _bdgf != "" && _feb._gdga != "" {
				_bdgf = _bdgf + _feb._gdga
			}
		}
		if _feb._cdbee {
			if len(_feb._edbgb.FldSimple) == 1 && len(_feb._edbgb.FldSimple[0].EG_PContent) == 1 && len(_feb._edbgb.FldSimple[0].EG_PContent[0].EG_ContentRunContent) == 1 {
				_fceba := &_ec.EG_ContentRunContent{}
				_fceba.R = _feb._edbgb.FldSimple[0].EG_PContent[0].EG_ContentRunContent[0].R
				_feb._edbgb.FldSimple = nil
				_cabf := Run{_agdc, _fceba.R}
				_cabf.ClearContent()
				_cabf.AddText(_bdgf)
				_feb._edbgb.EG_ContentRunContent = append(_feb._edbgb.EG_ContentRunContent, _fceba)
			}
		} else {
			_dabbf := _feb._fagc.Runs()
			for _afcg := _feb._edbc; _afcg <= _feb._bbbg; _afcg++ {
				if _afcg == _feb._bgcf+1 {
					_dabbf[_afcg].ClearContent()
					_dabbf[_afcg].AddText(_bdgf)
				} else {
					_ffdea[_feb._fagc] = append(_ffdea[_feb._fagc], _dabbf[_afcg])
				}
			}
		}
	}
	for _fgf, _gfab := range _ffdea {
		for _, _cgce := range _gfab {
			_fgf.RemoveRun(_cgce)
		}
	}
	_agdc.Settings.RemoveMailMerge()
}

// SetHangingIndent controls the indentation of the non-first lines in a paragraph.
func (_edfd ParagraphProperties) SetHangingIndent(m _fg.Distance) {
	if _edfd._aeda.Ind == nil {
		_edfd._aeda.Ind = _ec.NewCT_Ind()
	}
	if m == _fg.Zero {
		_edfd._aeda.Ind.HangingAttr = nil
	} else {
		_edfd._aeda.Ind.HangingAttr = &_bc.ST_TwipsMeasure{}
		_edfd._aeda.Ind.HangingAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _fg.Twips))
	}
}

// SetTextWrapNone unsets text wrapping so the image can float on top of the
// text. When used in conjunction with X/Y Offset relative to the page it can be
// used to place a logo at the top of a page at an absolute position that
// doesn't interfere with text.
func (_dg AnchoredDrawing) SetTextWrapNone() {
	_dg._fc.Choice = &_ec.WdEG_WrapTypeChoice{}
	_dg._fc.Choice.WrapNone = _ec.NewWdCT_WrapNone()
}

// AddFootnote will create a new footnote and attach it to the Paragraph in the
// location at the end of the previous run (footnotes create their own run within
// the paragraph). The text given to the function is simply a convenience helper,
// paragraphs and runs can always be added to the text of the footnote later.
func (_gage Paragraph) AddFootnote(text string) Footnote {
	var _abbf int64
	if _gage._baf.HasFootnotes() {
		for _, _ffbe := range _gage._baf.Footnotes() {
			if _ffbe.id() > _abbf {
				_abbf = _ffbe.id()
			}
		}
		_abbf++
	} else {
		_abbf = 0
		_gage._baf._dea = &_ec.Footnotes{}
		_gage._baf._dea.CT_Footnotes = _ec.CT_Footnotes{}
		_gage._baf._dea.Footnote = make([]*_ec.CT_FtnEdn, 0)
	}
	_fbgc := _ec.NewCT_FtnEdn()
	_dfae := _ec.NewCT_FtnEdnRef()
	_dfae.IdAttr = _abbf
	_gage._baf._dea.CT_Footnotes.Footnote = append(_gage._baf._dea.CT_Footnotes.Footnote, _fbgc)
	_ffge := _gage.AddRun()
	_bdac := _ffge.Properties()
	_bdac.SetStyle("\u0046\u006f\u006f\u0074\u006e\u006f\u0074\u0065\u0041n\u0063\u0068\u006f\u0072")
	_ffge._cbaga.EG_RunInnerContent = []*_ec.EG_RunInnerContent{_ec.NewEG_RunInnerContent()}
	_ffge._cbaga.EG_RunInnerContent[0].FootnoteReference = _dfae
	_ecce := Footnote{_gage._baf, _fbgc}
	_ecce._dded.IdAttr = _abbf
	_ecce._dded.EG_BlockLevelElts = []*_ec.EG_BlockLevelElts{_ec.NewEG_BlockLevelElts()}
	_ccde := _ecce.AddParagraph()
	_ccde.Properties().SetStyle("\u0046\u006f\u006f\u0074\u006e\u006f\u0074\u0065")
	_ccde._bbee.PPr.RPr = _ec.NewCT_ParaRPr()
	_fdbf := _ccde.AddRun()
	_fdbf.AddTab()
	_fdbf.AddText(text)
	return _ecce
}

// SetWindowControl controls if the first or last line of the paragraph is
// allowed to dispay on a separate page.
func (_dgdgc ParagraphProperties) SetWindowControl(b bool) {
	if !b {
		_dgdgc._aeda.WidowControl = nil
	} else {
		_dgdgc._aeda.WidowControl = _ec.NewCT_OnOff()
	}
}

// SetStrikeThrough sets the run to strike-through.
func (_gbafa RunProperties) SetStrikeThrough(b bool) {
	if !b {
		_gbafa._eeab.Strike = nil
	} else {
		_gbafa._eeab.Strike = _ec.NewCT_OnOff()
	}
}

// SetRight sets the right border to a specified type, color and thickness.
func (_bccf TableBorders) SetRight(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_bccf._bcd.Right = _ec.NewCT_Border()
	_edfca(_bccf._bcd.Right, t, c, thickness)
}

// SetStartIndent controls the start indent of the paragraph.
func (_fecag ParagraphStyleProperties) SetStartIndent(m _fg.Distance) {
	if _fecag._abef.Ind == nil {
		_fecag._abef.Ind = _ec.NewCT_Ind()
	}
	if m == _fg.Zero {
		_fecag._abef.Ind.StartAttr = nil
	} else {
		_fecag._abef.Ind.StartAttr = &_ec.ST_SignedTwipsMeasure{}
		_fecag._abef.Ind.StartAttr.Int64 = _e.Int64(int64(m / _fg.Twips))
	}
}

// Name returns the name of the style if set.
func (_gefeb Style) Name() string {
	if _gefeb._dacg.Name == nil {
		return ""
	}
	return _gefeb._dacg.Name.ValAttr
}

// SetCSTheme sets the font complex script theme.
func (_egef Fonts) SetCSTheme(t _ec.ST_Theme) { _egef._dcade.CsthemeAttr = t }

// RunProperties returns the run style properties.
func (_gbdab Style) RunProperties() RunProperties {
	if _gbdab._dacg.RPr == nil {
		_gbdab._dacg.RPr = _ec.NewCT_RPr()
	}
	return RunProperties{_gbdab._dacg.RPr}
}

// Fonts returns the style's Fonts.
func (_gaage RunProperties) Fonts() Fonts {
	if _gaage._eeab.RFonts == nil {
		_gaage._eeab.RFonts = _ec.NewCT_Fonts()
	}
	return Fonts{_gaage._eeab.RFonts}
}

// SetStrict is a shortcut for document.SetConformance,
// as one of these values from github.com/unidoc/unioffice/schema/soo/ofc/sharedTypes:
// ST_ConformanceClassUnset, ST_ConformanceClassStrict or ST_ConformanceClassTransitional.
func (_edae Document) SetStrict(strict bool) {
	if strict {
		_edae._bbef.ConformanceAttr = _bc.ST_ConformanceClassStrict
	} else {
		_edae._bbef.ConformanceAttr = _bc.ST_ConformanceClassTransitional
	}
}

// Properties returns the numbering level paragraph properties.
func (_gbfe NumberingLevel) Properties() ParagraphStyleProperties {
	if _gbfe._dccb.PPr == nil {
		_gbfe._dccb.PPr = _ec.NewCT_PPrGeneral()
	}
	return ParagraphStyleProperties{_gbfe._dccb.PPr}
}

// SetAfterAuto controls if spacing after a paragraph is automatically determined.
func (_gga ParagraphSpacing) SetAfterAuto(b bool) {
	if b {
		_gga._agffc.AfterAutospacingAttr = &_bc.ST_OnOff{}
		_gga._agffc.AfterAutospacingAttr.Bool = _e.Bool(true)
	} else {
		_gga._agffc.AfterAutospacingAttr = nil
	}
}

// IsItalic returns true if the run has been set to italics.
func (_fbab RunProperties) IsItalic() bool { return _fbab.ItalicValue() == OnOffValueOn }

// X returns the inner wrapped XML type.
func (_ggfa Row) X() *_ec.CT_Row { return _ggfa._eedff }

// ParagraphProperties returns the paragraph properties controlling text formatting within the table.
func (_bddeg TableConditionalFormatting) ParagraphProperties() ParagraphStyleProperties {
	if _bddeg._cbdbe.PPr == nil {
		_bddeg._cbdbe.PPr = _ec.NewCT_PPrGeneral()
	}
	return ParagraphStyleProperties{_bddeg._cbdbe.PPr}
}

// SetName marks sets a name attribute for a FormField.
func (_eaeff FormField) SetName(name string) {
	_bgff := _ec.NewCT_FFName()
	_bgff.ValAttr = &name
	_eaeff._bef.Name = []*_ec.CT_FFName{_bgff}
}

// AddRun adds a run of text to a hyperlink. This is the text that will be linked.
func (_ecdd HyperLink) AddRun() Run {
	_bdgb := _ec.NewEG_ContentRunContent()
	_ecdd._eabea.EG_ContentRunContent = append(_ecdd._eabea.EG_ContentRunContent, _bdgb)
	_afgg := _ec.NewCT_R()
	_bdgb.R = _afgg
	return Run{_ecdd._dgdb, _afgg}
}

// AddText adds tet to a run.
func (_becd Run) AddText(s string) {
	_gacff := _ec.NewEG_RunInnerContent()
	_becd._cbaga.EG_RunInnerContent = append(_becd._cbaga.EG_RunInnerContent, _gacff)
	_gacff.T = _ec.NewCT_Text()
	if _e.NeedsSpacePreserve(s) {
		_gbdd := "\u0070\u0072\u0065\u0073\u0065\u0072\u0076\u0065"
		_gacff.T.SpaceAttr = &_gbdd
	}
	_gacff.T.Content = s
}

// SetInsideVertical sets the interior vertical borders to a specified type, color and thickness.
func (_bdff TableBorders) SetInsideVertical(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_bdff._bcd.InsideV = _ec.NewCT_Border()
	_edfca(_bdff._bcd.InsideV, t, c, thickness)
}

// X returns the inner wrapped type
func (_eec CellBorders) X() *_ec.CT_TcBorders { return _eec._dcb }

// Shadow returns true if run shadow is on.
func (_fgdd RunProperties) Shadow() bool { return _gebc(_fgdd._eeab.Shadow) }

// SetNextStyle sets the style that the next paragraph will use.
func (_geag Style) SetNextStyle(name string) {
	if name == "" {
		_geag._dacg.Next = nil
	} else {
		_geag._dacg.Next = _ec.NewCT_String()
		_geag._dacg.Next.ValAttr = name
	}
}

// InsertRowAfter inserts a row after another row
func (_egbd Table) InsertRowAfter(r Row) Row {
	for _fgbde, _fgfa := range _egbd._adgg.EG_ContentRowContent {
		if len(_fgfa.Tr) > 0 && r.X() == _fgfa.Tr[0] {
			_gcgegf := _ec.NewEG_ContentRowContent()
			if len(_egbd._adgg.EG_ContentRowContent) < _fgbde+2 {
				return _egbd.AddRow()
			}
			_egbd._adgg.EG_ContentRowContent = append(_egbd._adgg.EG_ContentRowContent, nil)
			copy(_egbd._adgg.EG_ContentRowContent[_fgbde+2:], _egbd._adgg.EG_ContentRowContent[_fgbde+1:])
			_egbd._adgg.EG_ContentRowContent[_fgbde+1] = _gcgegf
			_dbfg := _ec.NewCT_Row()
			_gcgegf.Tr = append(_gcgegf.Tr, _dbfg)
			return Row{_egbd._ffdb, _dbfg}
		}
	}
	return _egbd.AddRow()
}

func (_debgd Paragraph) addSeparateFldChar() *_ec.CT_FldChar {
	_acfa := _debgd.addFldChar()
	_acfa.FldCharTypeAttr = _ec.ST_FldCharTypeSeparate
	return _acfa
}

// TableWidth controls width values in table settings.
type TableWidth struct{ _ebef *_ec.CT_TblWidth }

// RemoveMailMerge removes any mail merge settings
func (_cded Settings) RemoveMailMerge() { _cded._ebfg.MailMerge = nil }

// ParagraphProperties returns the paragraph style properties.
func (_efgdf Style) ParagraphProperties() ParagraphStyleProperties {
	if _efgdf._dacg.PPr == nil {
		_efgdf._dacg.PPr = _ec.NewCT_PPrGeneral()
	}
	return ParagraphStyleProperties{_efgdf._dacg.PPr}
}

// SetAll sets all of the borders to a given value.
func (_faad TableBorders) SetAll(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_faad.SetBottom(t, c, thickness)
	_faad.SetLeft(t, c, thickness)
	_faad.SetRight(t, c, thickness)
	_faad.SetTop(t, c, thickness)
	_faad.SetInsideHorizontal(t, c, thickness)
	_faad.SetInsideVertical(t, c, thickness)
}

// SetNumberingDefinitionByID sets the numbering definition ID directly, which must
// match an ID defined in numbering.xml
func (_fafa Paragraph) SetNumberingDefinitionByID(abstractNumberID int64) {
	_fafa.ensurePPr()
	if _fafa._bbee.PPr.NumPr == nil {
		_fafa._bbee.PPr.NumPr = _ec.NewCT_NumPr()
	}
	_gbfg := _ec.NewCT_DecimalNumber()
	_gbfg.ValAttr = int64(abstractNumberID)
	_fafa._bbee.PPr.NumPr.NumId = _gbfg
}

// SetInsideHorizontal sets the interior horizontal borders to a specified type, color and thickness.
func (_ff CellBorders) SetInsideHorizontal(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_ff._dcb.InsideH = _ec.NewCT_Border()
	_edfca(_ff._dcb.InsideH, t, c, thickness)
}

// SetOutline sets the run to outlined text.
func (_degc RunProperties) SetOutline(b bool) {
	if !b {
		_degc._eeab.Outline = nil
	} else {
		_degc._eeab.Outline = _ec.NewCT_OnOff()
	}
}

// MultiLevelType returns the multilevel type, or ST_MultiLevelTypeUnset if not set.
func (_effb NumberingDefinition) MultiLevelType() _ec.ST_MultiLevelType {
	if _effb._gafdd.MultiLevelType != nil {
		return _effb._gafdd.MultiLevelType.ValAttr
	} else {
		return _ec.ST_MultiLevelTypeUnset
	}
}

// X returns the inner wrapped XML type.
func (_fa Cell) X() *_ec.CT_Tc { return _fa._dae }

// RunProperties controls run styling properties
type RunProperties struct{ _eeab *_ec.CT_RPr }

// X returns the inner wrapped XML type.
func (_fcaa TableLook) X() *_ec.CT_TblLook { return _fcaa._bafa }

// InitializeDefault constructs the default styles.
func (_fcc Styles) InitializeDefault() {
	_fcc.initializeDocDefaults()
	_fcc.initializeStyleDefaults()
}

// SetFooter sets a section footer.
func (_acfbb Section) SetFooter(f Footer, t _ec.ST_HdrFtr) {
	_dcdd := _ec.NewEG_HdrFtrReferences()
	_acfbb._efad.EG_HdrFtrReferences = append(_acfbb._efad.EG_HdrFtrReferences, _dcdd)
	_dcdd.FooterReference = _ec.NewCT_HdrFtrRef()
	_dcdd.FooterReference.TypeAttr = t
	_gagc := _acfbb._debfg._cgg.FindRIDForN(f.Index(), _e.FooterType)
	if _gagc == "" {
		_c.Print("\u0075\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0072\u006d\u0069\u006e\u0065\u0020\u0066\u006f\u006f\u0074\u0065r \u0049\u0044")
	}
	_dcdd.FooterReference.IdAttr = _gagc
}

// SetHorizontalBanding controls the conditional formatting for horizontal banding.
func (_cedc TableLook) SetHorizontalBanding(on bool) {
	if !on {
		_cedc._bafa.NoHBandAttr = &_bc.ST_OnOff{}
		_cedc._bafa.NoHBandAttr.ST_OnOff1 = _bc.ST_OnOff1On
	} else {
		_cedc._bafa.NoHBandAttr = &_bc.ST_OnOff{}
		_cedc._bafa.NoHBandAttr.ST_OnOff1 = _bc.ST_OnOff1Off
	}
}

func (_bdd *Document) onNewRelationship(_cebg *_gf.DecodeMap, _eeec, _bgabd string, _fda []*_cd.File, _ebb *_ef.Relationship, _agdd _gf.Target) error {
	_gdad := _e.DocTypeDocument
	switch _bgabd {
	case _e.OfficeDocumentType, _e.OfficeDocumentTypeStrict:
		_bdd._bbef = _ec.NewDocument()
		_cebg.AddTarget(_eeec, _bdd._bbef, _bgabd, 0)
		_cebg.AddTarget(_gf.RelationsPathFor(_eeec), _bdd._cgg.X(), _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.CorePropertiesType:
		_cebg.AddTarget(_eeec, _bdd.CoreProperties.X(), _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.CustomPropertiesType:
		_cebg.AddTarget(_eeec, _bdd.CustomProperties.X(), _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.ExtendedPropertiesType, _e.ExtendedPropertiesTypeStrict:
		_cebg.AddTarget(_eeec, _bdd.AppProperties.X(), _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.ThumbnailType, _e.ThumbnailTypeStrict:
		for _fad, _dfef := range _fda {
			if _dfef == nil {
				continue
			}
			if _dfef.Name == _eeec {
				_becb, _cff := _dfef.Open()
				if _cff != nil {
					return _cfc.Errorf("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073", _cff)
				}
				_bdd.Thumbnail, _, _cff = _bg.Decode(_becb)
				_becb.Close()
				if _cff != nil {
					return _cfc.Errorf("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073", _cff)
				}
				_fda[_fad] = nil
			}
		}
	case _e.SettingsType, _e.SettingsTypeStrict:
		_cebg.AddTarget(_eeec, _bdd.Settings.X(), _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.NumberingType, _e.NumberingTypeStrict:
		_bdd.Numbering = NewNumbering()
		_cebg.AddTarget(_eeec, _bdd.Numbering.X(), _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.StylesType, _e.StylesTypeStrict:
		_bdd.Styles.Clear()
		_cebg.AddTarget(_eeec, _bdd.Styles.X(), _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.HeaderType, _e.HeaderTypeStrict:
		_fae := _ec.NewHdr()
		_cebg.AddTarget(_eeec, _fae, _bgabd, uint32(len(_bdd._dfe)))
		_bdd._dfe = append(_bdd._dfe, _fae)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, len(_bdd._dfe))
		_gagf := _gc.NewRelationships()
		_cebg.AddTarget(_gf.RelationsPathFor(_eeec), _gagf.X(), _bgabd, 0)
		_bdd._de = append(_bdd._de, _gagf)
	case _e.FooterType, _e.FooterTypeStrict:
		_cdgb := _ec.NewFtr()
		_cebg.AddTarget(_eeec, _cdgb, _bgabd, uint32(len(_bdd._ead)))
		_bdd._ead = append(_bdd._ead, _cdgb)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, len(_bdd._ead))
		_gdac := _gc.NewRelationships()
		_cebg.AddTarget(_gf.RelationsPathFor(_eeec), _gdac.X(), _bgabd, 0)
		_bdd._ecc = append(_bdd._ecc, _gdac)
	case _e.ThemeType, _e.ThemeTypeStrict:
		_beg := _eff.NewTheme()
		_cebg.AddTarget(_eeec, _beg, _bgabd, uint32(len(_bdd._cbag)))
		_bdd._cbag = append(_bdd._cbag, _beg)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, len(_bdd._cbag))
	case _e.WebSettingsType, _e.WebSettingsTypeStrict:
		_bdd._baeb = _ec.NewWebSettings()
		_cebg.AddTarget(_eeec, _bdd._baeb, _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.FontTableType, _e.FontTableTypeStrict:
		_bdd._fac = _ec.NewFonts()
		_cebg.AddTarget(_eeec, _bdd._fac, _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.EndNotesType, _e.EndNotesTypeStrict:
		_bdd._fgg = _ec.NewEndnotes()
		_cebg.AddTarget(_eeec, _bdd._fgg, _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.FootNotesType, _e.FootNotesTypeStrict:
		_bdd._dea = _ec.NewFootnotes()
		_cebg.AddTarget(_eeec, _bdd._dea, _bgabd, 0)
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, 0)
	case _e.ImageType, _e.ImageTypeStrict:
		var _ggfe _gc.ImageRef
		for _ggee, _eaef := range _fda {
			if _eaef == nil {
				continue
			}
			if _eaef.Name == _eeec {
				_faed, _cdf := _gf.ExtractToDiskTmp(_eaef, _bdd.TmpPath)
				if _cdf != nil {
					return _cdf
				}
				_fagf, _cdf := _gc.ImageFromStorage(_faed)
				if _cdf != nil {
					return _cdf
				}
				_ggfe = _gc.MakeImageRef(_fagf, &_bdd.DocBase, _bdd._cgg)
				_bdd.Images = append(_bdd.Images, _ggfe)
				_fda[_ggee] = nil
			}
		}
		_aace := "\u002e" + _g.ToLower(_ggfe.Format())
		_ebb.TargetAttr = _e.RelativeFilename(_gdad, _agdd.Typ, _bgabd, len(_bdd.Images))
		if _ecae := _bd.Ext(_ebb.TargetAttr); _ecae != _aace {
			_ebb.TargetAttr = _ebb.TargetAttr[0:len(_ebb.TargetAttr)-len(_ecae)] + _aace
		}
	default:
		_e.Log("\u0075\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0065\u006c\u0061\u0074\u0069\u006fn\u0073\u0068\u0069\u0070\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u0074\u0067\u0074\u003a\u0020\u0025\u0073", _bgabd, _eeec)
	}
	return nil
}

// AddParagraph adds a paragraph to the footer.
func (_dfdd Footer) AddParagraph() Paragraph {
	_edfc := _ec.NewEG_ContentBlockContent()
	_dfdd._abd.EG_ContentBlockContent = append(_dfdd._abd.EG_ContentBlockContent, _edfc)
	_fab := _ec.NewCT_P()
	_edfc.P = append(_edfc.P, _fab)
	return Paragraph{_dfdd._bcf, _fab}
}

// SetFirstLineIndent controls the indentation of the first line in a paragraph.
func (_ccded Paragraph) SetFirstLineIndent(m _fg.Distance) {
	_ccded.ensurePPr()
	_baeg := _ccded._bbee.PPr
	if _baeg.Ind == nil {
		_baeg.Ind = _ec.NewCT_Ind()
	}
	if m == _fg.Zero {
		_baeg.Ind.FirstLineAttr = nil
	} else {
		_baeg.Ind.FirstLineAttr = &_bc.ST_TwipsMeasure{}
		_baeg.Ind.FirstLineAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _fg.Twips))
	}
}

// SetShadow sets the run to shadowed text.
func (_gbbfg RunProperties) SetShadow(b bool) {
	if !b {
		_gbbfg._eeab.Shadow = nil
	} else {
		_gbbfg._eeab.Shadow = _ec.NewCT_OnOff()
	}
}

// OpenTemplate opens a document, removing all content so it can be used as a
// template.  Since Word removes unused styles from a document upon save, to
// create a template in Word add a paragraph with every style of interest.  When
// opened with OpenTemplate the document's styles will be available but the
// content will be gone.
func OpenTemplate(filename string) (*Document, error) {
	_gaaa, _gfc := Open(filename)
	if _gfc != nil {
		return nil, _gfc
	}
	_gaaa._bbef.Body = _ec.NewCT_Body()
	return _gaaa, nil
}

// X returns the inner wrapped XML type.
func (_aeae Table) X() *_ec.CT_Tbl { return _aeae._adgg }

// AddField adds a field (automatically computed text) to the document.
func (_dfcd Run) AddField(code string) { _dfcd.AddFieldWithFormatting(code, "", true) }

// InsertRunBefore inserts a run in the paragraph before the relative run.
func (_ggddb Paragraph) InsertRunBefore(relativeTo Run) Run {
	return _ggddb.insertRun(relativeTo, true)
}

// X returns the inner wrapped XML type.
func (_bfe Settings) X() *_ec.Settings { return _bfe._ebfg }

// SetShading controls the cell shading.
func (_efdd CellProperties) SetShading(shd _ec.ST_Shd, foreground, fill _ga.Color) {
	if shd == _ec.ST_ShdUnset {
		_efdd._adfg.Shd = nil
	} else {
		_efdd._adfg.Shd = _ec.NewCT_Shd()
		_efdd._adfg.Shd.ValAttr = shd
		_efdd._adfg.Shd.ColorAttr = &_ec.ST_HexColor{}
		if foreground.IsAuto() {
			_efdd._adfg.Shd.ColorAttr.ST_HexColorAuto = _ec.ST_HexColorAutoAuto
		} else {
			_efdd._adfg.Shd.ColorAttr.ST_HexColorRGB = foreground.AsRGBString()
		}
		_efdd._adfg.Shd.FillAttr = &_ec.ST_HexColor{}
		if fill.IsAuto() {
			_efdd._adfg.Shd.FillAttr.ST_HexColorAuto = _ec.ST_HexColorAutoAuto
		} else {
			_efdd._adfg.Shd.FillAttr.ST_HexColorRGB = fill.AsRGBString()
		}
	}
}

// Emboss returns true if paragraph emboss is on.
func (_efbd ParagraphProperties) Emboss() bool { return _gebc(_efbd._aeda.RPr.Emboss) }

// SetWidthAuto sets the the cell width to automatic.
func (_fd CellProperties) SetWidthAuto() {
	_fd._adfg.TcW = _ec.NewCT_TblWidth()
	_fd._adfg.TcW.TypeAttr = _ec.ST_TblWidthAuto
}

// SetLeftPct sets the cell left margin
func (_bgcc CellMargins) SetLeftPct(pct float64) {
	_bgcc._cba.Left = _ec.NewCT_TblWidth()
	_eef(_bgcc._cba.Left, pct)
}

// SetLeft sets the left border to a specified type, color and thickness.
func (_cdb CellBorders) SetLeft(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_cdb._dcb.Left = _ec.NewCT_Border()
	_edfca(_cdb._dcb.Left, t, c, thickness)
}

// X returns the inner wrapped XML type.
func (_dccg Run) X() *_ec.CT_R { return _dccg._cbaga }

// SetCellSpacing sets the cell spacing within a table.
func (_fbbc TableProperties) SetCellSpacing(m _fg.Distance) {
	_fbbc._ddac.TblCellSpacing = _ec.NewCT_TblWidth()
	_fbbc._ddac.TblCellSpacing.TypeAttr = _ec.ST_TblWidthDxa
	_fbbc._ddac.TblCellSpacing.WAttr = &_ec.ST_MeasurementOrPercent{}
	_fbbc._ddac.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_fbbc._ddac.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(m / _fg.Dxa))
}

// SetRight sets the right border to a specified type, color and thickness.
func (_bae CellBorders) SetRight(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_bae._dcb.Right = _ec.NewCT_Border()
	_edfca(_bae._dcb.Right, t, c, thickness)
}

// Footnote is an individual footnote reference within the document.
type Footnote struct {
	_cecb *Document
	_dded *_ec.CT_FtnEdn
}

// Paragraphs returns the paragraphs within a structured document tag.
func (_eadc StructuredDocumentTag) Paragraphs() []Paragraph {
	if _eadc._cdef.SdtContent == nil {
		return nil
	}
	_ggc := []Paragraph{}
	for _, _cdcg := range _eadc._cdef.SdtContent.P {
		_ggc = append(_ggc, Paragraph{_eadc._bbcdg, _cdcg})
	}
	return _ggc
}

// CellMargins are the margins for an individual cell.
type CellMargins struct{ _cba *_ec.CT_TcMar }

// SetFormat sets the numbering format.
func (_bdaa NumberingLevel) SetFormat(f _ec.ST_NumberFormat) {
	if _bdaa._dccb.NumFmt == nil {
		_bdaa._dccb.NumFmt = _ec.NewCT_NumFmt()
	}
	_bdaa._dccb.NumFmt.ValAttr = f
}

var _fbd = false

// SetThemeShade sets the shade based off the theme color.
func (_gdfb Color) SetThemeShade(s uint8) {
	_efb := _cfc.Sprintf("\u0025\u0030\u0032\u0078", s)
	_gdfb._bca.ThemeShadeAttr = &_efb
}

// SetKeepNext controls if the paragraph is kept with the next paragraph.
func (_fde ParagraphStyleProperties) SetKeepNext(b bool) {
	if !b {
		_fde._abef.KeepNext = nil
	} else {
		_fde._abef.KeepNext = _ec.NewCT_OnOff()
	}
}

// UnderlineColor returns the hex color value of run underline.
func (_cdae RunProperties) UnderlineColor() string {
	if _gbda := _cdae._eeab.U; _gbda != nil {
		_efa := _gbda.ColorAttr
		if _efa != nil && _efa.ST_HexColorRGB != nil {
			return *_efa.ST_HexColorRGB
		}
	}
	return ""
}

// AddParagraph adds a paragraph to the header.
func (_cgbc Header) AddParagraph() Paragraph {
	_dddb := _ec.NewEG_ContentBlockContent()
	_cgbc._gca.EG_ContentBlockContent = append(_cgbc._gca.EG_ContentBlockContent, _dddb)
	_becba := _ec.NewCT_P()
	_dddb.P = append(_dddb.P, _becba)
	return Paragraph{_cgbc._fceb, _becba}
}

// PossibleValues returns the possible values for a FormFieldTypeDropDown.
func (_ddg FormField) PossibleValues() []string {
	if _ddg._bef.DdList == nil {
		return nil
	}
	_aeb := []string{}
	for _, _ffd := range _ddg._bef.DdList.ListEntry {
		if _ffd == nil {
			continue
		}
		_aeb = append(_aeb, _ffd.ValAttr)
	}
	return _aeb
}

// GetColor returns the color.Color object representing the run color.
func (_ggebb RunProperties) GetColor() _ga.Color {
	if _dccgg := _ggebb._eeab.Color; _dccgg != nil {
		_cggcc := _dccgg.ValAttr
		if _cggcc.ST_HexColorRGB != nil {
			return _ga.FromHex(*_cggcc.ST_HexColorRGB)
		}
	}
	return _ga.Color{}
}

// X returns the inner wml.CT_TblBorders
func (_eaab TableBorders) X() *_ec.CT_TblBorders { return _eaab._bcd }

// SetPrimaryStyle marks the style as a primary style.
func (_dbgc Style) SetPrimaryStyle(b bool) {
	if b {
		_dbgc._dacg.QFormat = _ec.NewCT_OnOff()
	} else {
		_dbgc._dacg.QFormat = nil
	}
}

// AddParagraph adds a paragraph to the table cell.
func (_cg Cell) AddParagraph() Paragraph {
	_ac := _ec.NewEG_BlockLevelElts()
	_cg._dae.EG_BlockLevelElts = append(_cg._dae.EG_BlockLevelElts, _ac)
	_acc := _ec.NewEG_ContentBlockContent()
	_ac.EG_ContentBlockContent = append(_ac.EG_ContentBlockContent, _acc)
	_edc := _ec.NewCT_P()
	_acc.P = append(_acc.P, _edc)
	return Paragraph{_cg._ged, _edc}
}

// Clear clears all content within a header
func (_aeeg Header) Clear() { _aeeg._gca.EG_ContentBlockContent = nil }

// BoldValue returns the precise nature of the bold setting (unset, off or on).
func (_ebab RunProperties) BoldValue() OnOffValue { return _gdbf(_ebab._eeab.B) }

var _agda = [...]uint8{0, 20, 37, 58, 79}

// SetMultiLevelType sets the multilevel type.
func (_ebe NumberingDefinition) SetMultiLevelType(t _ec.ST_MultiLevelType) {
	if t == _ec.ST_MultiLevelTypeUnset {
		_ebe._gafdd.MultiLevelType = nil
	} else {
		_ebe._gafdd.MultiLevelType = _ec.NewCT_MultiLevelType()
		_ebe._gafdd.MultiLevelType.ValAttr = t
	}
}

// X returns the inner wrapped XML type.
func (_ggda RunProperties) X() *_ec.CT_RPr { return _ggda._eeab }

// SetTableIndent sets the Table Indent from the Leading Margin
func (_edcd TableStyleProperties) SetTableIndent(ind _fg.Distance) {
	_edcd._addg.TblInd = _ec.NewCT_TblWidth()
	_edcd._addg.TblInd.TypeAttr = _ec.ST_TblWidthDxa
	_edcd._addg.TblInd.WAttr = &_ec.ST_MeasurementOrPercent{}
	_edcd._addg.TblInd.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_edcd._addg.TblInd.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(ind / _fg.Dxa))
}

// Bookmark is a bookmarked location within a document that can be referenced
// with a hyperlink.
type Bookmark struct{ _bde *_ec.CT_Bookmark }

// Style returns the style for a paragraph, or an empty string if it is unset.
func (_dadf Paragraph) Style() string {
	if _dadf._bbee.PPr != nil && _dadf._bbee.PPr.PStyle != nil {
		return _dadf._bbee.PPr.PStyle.ValAttr
	}
	return ""
}

// RStyle returns the name of character style.
// It is defined here http://officeopenxml.com/WPstyleCharStyles.php
func (_fgbd ParagraphProperties) RStyle() string {
	if _fgbd._aeda.RPr.RStyle != nil {
		return _fgbd._aeda.RPr.RStyle.ValAttr
	}
	return ""
}

// SetTargetByRef sets the URL target of the hyperlink and is more efficient if a link
// destination will be used many times.
func (_fdgd HyperLink) SetTargetByRef(link _gc.Hyperlink) {
	_fdgd._eabea.IdAttr = _e.String(_gc.Relationship(link).ID())
	_fdgd._eabea.AnchorAttr = nil
}

// X returns the inner wrapped XML type.
func (_fgcf Footer) X() *_ec.Ftr { return _fgcf._abd }

// SetLayout controls the table layout. wml.ST_TblLayoutTypeAutofit corresponds
// to "Automatically resize to fit contents" being checked, while
// wml.ST_TblLayoutTypeFixed corresponds to it being unchecked.
func (_gbfb TableProperties) SetLayout(l _ec.ST_TblLayoutType) {
	if l == _ec.ST_TblLayoutTypeUnset || l == _ec.ST_TblLayoutTypeAutofit {
		_gbfb._ddac.TblLayout = nil
	} else {
		_gbfb._ddac.TblLayout = _ec.NewCT_TblLayoutType()
		_gbfb._ddac.TblLayout.TypeAttr = l
	}
}

// SetCalcOnExit marks if a FormField should be CalcOnExit or not.
func (_ecfef FormField) SetCalcOnExit(calcOnExit bool) {
	_cbgec := _ec.NewCT_OnOff()
	_cbgec.ValAttr = &_bc.ST_OnOff{Bool: &calcOnExit}
	_ecfef._bef.CalcOnExit = []*_ec.CT_OnOff{_cbgec}
}

// AddParagraph adds a paragraph to the footnote.
func (_fcfee Footnote) AddParagraph() Paragraph {
	_cbf := _ec.NewEG_ContentBlockContent()
	_gfbc := len(_fcfee._dded.EG_BlockLevelElts[0].EG_ContentBlockContent)
	_fcfee._dded.EG_BlockLevelElts[0].EG_ContentBlockContent = append(_fcfee._dded.EG_BlockLevelElts[0].EG_ContentBlockContent, _cbf)
	_ggbc := _ec.NewCT_P()
	var _cad *_ec.CT_String
	if _gfbc != 0 {
		_bdef := len(_fcfee._dded.EG_BlockLevelElts[0].EG_ContentBlockContent[_gfbc-1].P)
		_cad = _fcfee._dded.EG_BlockLevelElts[0].EG_ContentBlockContent[_gfbc-1].P[_bdef-1].PPr.PStyle
	} else {
		_cad = _ec.NewCT_String()
		_cad.ValAttr = "\u0046\u006f\u006f\u0074\u006e\u006f\u0074\u0065"
	}
	_cbf.P = append(_cbf.P, _ggbc)
	_aed := Paragraph{_fcfee._cecb, _ggbc}
	_aed._bbee.PPr = _ec.NewCT_PPr()
	_aed._bbee.PPr.PStyle = _cad
	_aed._bbee.PPr.RPr = _ec.NewCT_ParaRPr()
	return _aed
}

// VerticalAlign returns the value of run vertical align.
func (_gdfdd RunProperties) VerticalAlignment() _bc.ST_VerticalAlignRun {
	if _gafg := _gdfdd._eeab.VertAlign; _gafg != nil {
		return _gafg.ValAttr
	}
	return 0
}

// CharacterSpacingValue returns the value of run's characters spacing in twips (1/20 of point).
func (_aafb RunProperties) CharacterSpacingValue() int64 {
	if _ccdec := _aafb._eeab.Spacing; _ccdec != nil {
		_ffdg := _ccdec.ValAttr
		if _ffdg.Int64 != nil {
			return *_ffdg.Int64
		}
	}
	return int64(0)
}

// InsertRowBefore inserts a row before another row
func (_ccccf Table) InsertRowBefore(r Row) Row {
	for _dcaa, _ceab := range _ccccf._adgg.EG_ContentRowContent {
		if len(_ceab.Tr) > 0 && r.X() == _ceab.Tr[0] {
			_bedg := _ec.NewEG_ContentRowContent()
			_ccccf._adgg.EG_ContentRowContent = append(_ccccf._adgg.EG_ContentRowContent, nil)
			copy(_ccccf._adgg.EG_ContentRowContent[_dcaa+1:], _ccccf._adgg.EG_ContentRowContent[_dcaa:])
			_ccccf._adgg.EG_ContentRowContent[_dcaa] = _bedg
			_deae := _ec.NewCT_Row()
			_bedg.Tr = append(_bedg.Tr, _deae)
			return Row{_ccccf._ffdb, _deae}
		}
	}
	return _ccccf.AddRow()
}

// SetBasedOn sets the style that this style is based on.
func (_eddd Style) SetBasedOn(name string) {
	if name == "" {
		_eddd._dacg.BasedOn = nil
	} else {
		_eddd._dacg.BasedOn = _ec.NewCT_String()
		_eddd._dacg.BasedOn.ValAttr = name
	}
}

// X returns the inner wrapped XML type.
func (_gegg InlineDrawing) X() *_ec.WdInline { return _gegg._aebg }

// Text returns the underlying tet in the run.
func (_gffc Run) Text() string {
	if len(_gffc._cbaga.EG_RunInnerContent) == 0 {
		return ""
	}
	_eaad := _cf.Buffer{}
	for _, _cbce := range _gffc._cbaga.EG_RunInnerContent {
		if _cbce.T != nil {
			_eaad.WriteString(_cbce.T.Content)
		}
		if _cbce.Tab != nil {
			_eaad.WriteByte('\t')
		}
	}
	return _eaad.String()
}

// UnderlineColor returns the hex color value of paragraph underline.
func (_bdfe ParagraphProperties) UnderlineColor() string {
	if _adg := _bdfe._aeda.RPr.U; _adg != nil {
		_ggfb := _adg.ColorAttr
		if _ggfb != nil && _ggfb.ST_HexColorRGB != nil {
			return *_ggfb.ST_HexColorRGB
		}
	}
	return ""
}

// Bold returns true if paragraph font is bold.
func (_dbgd ParagraphProperties) Bold() bool {
	_baa := _dbgd._aeda.RPr
	return _gebc(_baa.B) || _gebc(_baa.BCs)
}

// CellProperties returns the cell properties.
func (_fdgcg TableConditionalFormatting) CellProperties() CellProperties {
	if _fdgcg._cbdbe.TcPr == nil {
		_fdgcg._cbdbe.TcPr = _ec.NewCT_TcPr()
	}
	return CellProperties{_fdgcg._cbdbe.TcPr}
}

// Name returns the name of the bookmark whcih is the document unique ID that
// identifies the bookmark.
func (_ee Bookmark) Name() string { return _ee._bde.NameAttr }

// SetWidthPercent sets the table to a width percentage.
func (_gcdf TableProperties) SetWidthPercent(pct float64) {
	_gcdf._ddac.TblW = _ec.NewCT_TblWidth()
	_gcdf._ddac.TblW.TypeAttr = _ec.ST_TblWidthPct
	_gcdf._ddac.TblW.WAttr = &_ec.ST_MeasurementOrPercent{}
	_gcdf._ddac.TblW.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_gcdf._ddac.TblW.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(pct * 50))
}

// X returns the inner wrapped XML type.
func (_bdcfg TableWidth) X() *_ec.CT_TblWidth { return _bdcfg._ebef }

// Close closes the document, removing any temporary files that might have been
// created when opening a document.
func (_fgdb *Document) Close() error {
	if _fgdb.TmpPath != "" {
		return _ba.RemoveAll(_fgdb.TmpPath)
	}
	return nil
}

// ParagraphSpacing controls the spacing for a paragraph and its lines.
type ParagraphSpacing struct{ _agffc *_ec.CT_Spacing }

// ComplexSizeValue returns the value of run font size for complex fonts in points.
func (_fcga RunProperties) ComplexSizeValue() float64 {
	if _ddefd := _fcga._eeab.SzCs; _ddefd != nil {
		_debf := _ddefd.ValAttr
		if _debf.ST_UnsignedDecimalNumber != nil {
			return float64(*_debf.ST_UnsignedDecimalNumber) / 2
		}
	}
	return 0.0
}

const (
	FieldCurrentPage   = "\u0050\u0041\u0047\u0045"
	FieldNumberOfPages = "\u004e\u0055\u004d\u0050\u0041\u0047\u0045\u0053"
	FieldDate          = "\u0044\u0041\u0054\u0045"
	FieldCreateDate    = "\u0043\u0052\u0045\u0041\u0054\u0045\u0044\u0041\u0054\u0045"
	FieldEditTime      = "\u0045\u0044\u0049\u0054\u0054\u0049\u004d\u0045"
	FieldPrintDate     = "\u0050R\u0049\u004e\u0054\u0044\u0041\u0054E"
	FieldSaveDate      = "\u0053\u0041\u0056\u0045\u0044\u0041\u0054\u0045"
	FieldTIme          = "\u0054\u0049\u004d\u0045"
	FieldTOC           = "\u0054\u004f\u0043"
)

// SetSemiHidden controls if the style is hidden in the UI.
func (_dccge Style) SetSemiHidden(b bool) {
	if b {
		_dccge._dacg.SemiHidden = _ec.NewCT_OnOff()
	} else {
		_dccge._dacg.SemiHidden = nil
	}
}

// IsFootnote returns a bool based on whether the run has a
// footnote or not. Returns both a bool as to whether it has
// a footnote as well as the ID of the footnote.
func (_ddee Run) IsFootnote() (bool, int64) {
	if _ddee._cbaga.EG_RunInnerContent != nil {
		if _ddee._cbaga.EG_RunInnerContent[0].FootnoteReference != nil {
			return true, _ddee._cbaga.EG_RunInnerContent[0].FootnoteReference.IdAttr
		}
	}
	return false, 0
}

// TableProperties are the properties for a table within a document
type TableProperties struct{ _ddac *_ec.CT_TblPr }

// Color returns the style's Color.
func (_acbf RunProperties) Color() Color {
	if _acbf._eeab.Color == nil {
		_acbf._eeab.Color = _ec.NewCT_Color()
	}
	return Color{_acbf._eeab.Color}
}

// Spacing returns the paragraph spacing settings.
func (_eaga ParagraphProperties) Spacing() ParagraphSpacing {
	if _eaga._aeda.Spacing == nil {
		_eaga._aeda.Spacing = _ec.NewCT_Spacing()
	}
	return ParagraphSpacing{_eaga._aeda.Spacing}
}

const _eece = "\u0046\u006f\u0072\u006d\u0046\u0069\u0065l\u0064\u0054\u0079\u0070\u0065\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0046\u006fr\u006dF\u0069\u0065\u006c\u0064\u0054\u0079p\u0065\u0054\u0065\u0078\u0074\u0046\u006fr\u006d\u0046\u0069\u0065\u006c\u0064\u0054\u0079\u0070\u0065\u0043\u0068\u0065\u0063\u006b\u0042\u006f\u0078\u0046\u006f\u0072\u006d\u0046i\u0065\u006c\u0064\u0054\u0079\u0070\u0065\u0044\u0072\u006f\u0070\u0044\u006fw\u006e"

// RowProperties are the properties for a row within a table
type RowProperties struct{ _bdba *_ec.CT_TrPr }

// SetCellSpacingAuto sets the cell spacing within a table to automatic.
func (_dddcc TableProperties) SetCellSpacingAuto() {
	_dddcc._ddac.TblCellSpacing = _ec.NewCT_TblWidth()
	_dddcc._ddac.TblCellSpacing.TypeAttr = _ec.ST_TblWidthAuto
}

// SetStartIndent controls the start indentation.
func (_afab ParagraphProperties) SetStartIndent(m _fg.Distance) {
	if _afab._aeda.Ind == nil {
		_afab._aeda.Ind = _ec.NewCT_Ind()
	}
	if m == _fg.Zero {
		_afab._aeda.Ind.StartAttr = nil
	} else {
		_afab._aeda.Ind.StartAttr = &_ec.ST_SignedTwipsMeasure{}
		_afab._aeda.Ind.StartAttr.Int64 = _e.Int64(int64(m / _fg.Twips))
	}
}

// SetHAlignment sets the horizontal alignment for an anchored image.
func (_bb AnchoredDrawing) SetHAlignment(h _ec.WdST_AlignH) {
	_bb._fc.PositionH.Choice = &_ec.WdCT_PosHChoice{}
	_bb._fc.PositionH.Choice.Align = h
}

// ClearColor clears the text color.
func (_cgbfe RunProperties) ClearColor() { _cgbfe._eeab.Color = nil }

// X returns the inner wrapped XML type.
func (_adc Fonts) X() *_ec.CT_Fonts { return _adc._dcade }

// SetBottomPct sets the cell bottom margin
func (_bce CellMargins) SetBottomPct(pct float64) {
	_bce._cba.Bottom = _ec.NewCT_TblWidth()
	_eef(_bce._cba.Bottom, pct)
}

// SetCellSpacingPercent sets the cell spacing within a table to a percent width.
func (_bdbec TableProperties) SetCellSpacingPercent(pct float64) {
	_bdbec._ddac.TblCellSpacing = _ec.NewCT_TblWidth()
	_bdbec._ddac.TblCellSpacing.TypeAttr = _ec.ST_TblWidthPct
	_bdbec._ddac.TblCellSpacing.WAttr = &_ec.ST_MeasurementOrPercent{}
	_bdbec._ddac.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_bdbec._ddac.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(pct * 50))
}

// AddFooter creates a Footer associated with the document, but doesn't add it
// to the document for display.
func (_acdb *Document) AddFooter() Footer {
	_bdg := _ec.NewFtr()
	_acdb._ead = append(_acdb._ead, _bdg)
	_ccg := _cfc.Sprintf("\u0066\u006f\u006ft\u0065\u0072\u0025\u0064\u002e\u0078\u006d\u006c", len(_acdb._ead))
	_acdb._cgg.AddRelationship(_ccg, _e.FooterType)
	_acdb.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072\u0064\u002f"+_ccg, "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0076\u006e\u0064.\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c\u002e\u0066\u006f\u006f\u0074e\u0072\u002b\u0078\u006d\u006c")
	_acdb._ecc = append(_acdb._ecc, _gc.NewRelationships())
	return Footer{_acdb, _bdg}
}

// StyleID returns the style ID.
func (_cbgee Style) StyleID() string {
	if _cbgee._dacg.StyleIdAttr == nil {
		return ""
	}
	return *_cbgee._dacg.StyleIdAttr
}

// AddBookmark adds a bookmark to a document that can then be used from a hyperlink. Name is a document
// unique name that identifies the bookmark so it can be referenced from hyperlinks.
func (_cbad Paragraph) AddBookmark(name string) Bookmark {
	_cccc := _ec.NewEG_PContent()
	_dccac := _ec.NewEG_ContentRunContent()
	_cccc.EG_ContentRunContent = append(_cccc.EG_ContentRunContent, _dccac)
	_aacgd := _ec.NewEG_RunLevelElts()
	_dccac.EG_RunLevelElts = append(_dccac.EG_RunLevelElts, _aacgd)
	_gcac := _ec.NewEG_RangeMarkupElements()
	_cfce := _ec.NewCT_Bookmark()
	_gcac.BookmarkStart = _cfce
	_aacgd.EG_RangeMarkupElements = append(_aacgd.EG_RangeMarkupElements, _gcac)
	_gcac = _ec.NewEG_RangeMarkupElements()
	_gcac.BookmarkEnd = _ec.NewCT_MarkupRange()
	_aacgd.EG_RangeMarkupElements = append(_aacgd.EG_RangeMarkupElements, _gcac)
	_cbad._bbee.EG_PContent = append(_cbad._bbee.EG_PContent, _cccc)
	_cagc := Bookmark{_cfce}
	_cagc.SetName(name)
	return _cagc
}

func (_cbcg *Document) validateTableCells() error {
	for _, _beb := range _cbcg._bbef.Body.EG_BlockLevelElts {
		for _, _gadd := range _beb.EG_ContentBlockContent {
			for _, _fcfd := range _gadd.Tbl {
				for _, _ffeb := range _fcfd.EG_ContentRowContent {
					for _, _afeb := range _ffeb.Tr {
						_ccaa := false
						for _, _ggd := range _afeb.EG_ContentCellContent {
							_gab := false
							for _, _bgab := range _ggd.Tc {
								_ccaa = true
								for _, _bbd := range _bgab.EG_BlockLevelElts {
									for _, _dfge := range _bbd.EG_ContentBlockContent {
										if len(_dfge.P) > 0 {
											_gab = true
											break
										}
									}
								}
							}
							if !_gab {
								return _bf.New("t\u0061\u0062\u006c\u0065\u0020\u0063e\u006c\u006c\u0020\u006d\u0075\u0073t\u0020\u0063\u006f\u006e\u0074\u0061\u0069n\u0020\u0061\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061p\u0068")
							}
						}
						if !_ccaa {
							return _bf.New("\u0074\u0061b\u006c\u0065\u0020\u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0020ce\u006c\u006c")
						}
					}
				}
			}
		}
	}
	return nil
}

// StructuredDocumentTag are a tagged bit of content in a document.
type StructuredDocumentTag struct {
	_bbcdg *Document
	_cdef  *_ec.CT_SdtBlock
}

// Color controls the run or styles color.
type Color struct{ _bca *_ec.CT_Color }

// SetContextualSpacing controls whether to Ignore Spacing Above and Below When
// Using Identical Styles
func (_dgcce ParagraphStyleProperties) SetContextualSpacing(b bool) {
	if !b {
		_dgcce._abef.ContextualSpacing = nil
	} else {
		_dgcce._abef.ContextualSpacing = _ec.NewCT_OnOff()
	}
}

// CellProperties are a table cells properties within a document.
type CellProperties struct{ _adfg *_ec.CT_TcPr }

// Properties returns the run properties.
func (_ceec Run) Properties() RunProperties {
	if _ceec._cbaga.RPr == nil {
		_ceec._cbaga.RPr = _ec.NewCT_RPr()
	}
	return RunProperties{_ceec._cbaga.RPr}
}

// SetColumnBandSize sets the number of Columns in the column band
func (_aaedd TableStyleProperties) SetColumnBandSize(cols int64) {
	_aaedd._addg.TblStyleColBandSize = _ec.NewCT_DecimalNumber()
	_aaedd._addg.TblStyleColBandSize.ValAttr = cols
}

// RemoveParagraph removes a paragraph from a footer.
func (_eafb Footer) RemoveParagraph(p Paragraph) {
	for _, _daa := range _eafb._abd.EG_ContentBlockContent {
		for _bcaf, _dbfe := range _daa.P {
			if _dbfe == p._bbee {
				copy(_daa.P[_bcaf:], _daa.P[_bcaf+1:])
				_daa.P = _daa.P[0 : len(_daa.P)-1]
				return
			}
		}
	}
}

// AddStyle adds a new empty style.
func (_agcf Styles) AddStyle(styleID string, t _ec.ST_StyleType, isDefault bool) Style {
	_bdfd := _ec.NewCT_Style()
	_bdfd.TypeAttr = t
	if isDefault {
		_bdfd.DefaultAttr = &_bc.ST_OnOff{}
		_bdfd.DefaultAttr.Bool = _e.Bool(isDefault)
	}
	_bdfd.StyleIdAttr = _e.String(styleID)
	_agcf._gccd.Style = append(_agcf._gccd.Style, _bdfd)
	return Style{_bdfd}
}

// SetStyle sets the table style name.
func (_bafb TableProperties) SetStyle(name string) {
	if name == "" {
		_bafb._ddac.TblStyle = nil
	} else {
		_bafb._ddac.TblStyle = _ec.NewCT_String()
		_bafb._ddac.TblStyle.ValAttr = name
	}
}

func (_facb Paragraph) addInstrText(_aad string) *_ec.CT_Text {
	_dcee := _facb.AddRun()
	_afefe := _dcee.X()
	_fecg := _ec.NewEG_RunInnerContent()
	_dfgec := _ec.NewCT_Text()
	_agae := "\u0070\u0072\u0065\u0073\u0065\u0072\u0076\u0065"
	_dfgec.SpaceAttr = &_agae
	_dfgec.Content = "\u0020" + _aad + "\u0020"
	_fecg.InstrText = _dfgec
	_afefe.EG_RunInnerContent = append(_afefe.EG_RunInnerContent, _fecg)
	return _dfgec
}

func _cfffe(_accfa string) mergeFieldInfo {
	_abab := []string{}
	_fbef := _cf.Buffer{}
	_fdgg := -1
	for _bega, _bgcad := range _accfa {
		switch _bgcad {
		case ' ':
			if _fbef.Len() != 0 {
				_abab = append(_abab, _fbef.String())
			}
			_fbef.Reset()
		case '"':
			if _fdgg != -1 {
				_abab = append(_abab, _accfa[_fdgg+1:_bega])
				_fdgg = -1
			} else {
				_fdgg = _bega
			}
		default:
			_fbef.WriteRune(_bgcad)
		}
	}
	if _fbef.Len() != 0 {
		_abab = append(_abab, _fbef.String())
	}
	_dfdfa := mergeFieldInfo{}
	for _ecaed := 0; _ecaed < len(_abab)-1; _ecaed++ {
		_cbgd := _abab[_ecaed]
		switch _cbgd {
		case "\u004d\u0045\u0052\u0047\u0045\u0046\u0049\u0045\u004c\u0044":
			_dfdfa._faac = _abab[_ecaed+1]
			_ecaed++
		case "\u005c\u0066":
			_dfdfa._gdga = _abab[_ecaed+1]
			_ecaed++
		case "\u005c\u0062":
			_dfdfa._gdda = _abab[_ecaed+1]
			_ecaed++
		case "\u005c\u002a":
			switch _abab[_ecaed+1] {
			case "\u0055\u0070\u0070e\u0072":
				_dfdfa._dcca = true
			case "\u004c\u006f\u0077e\u0072":
				_dfdfa._fedg = true
			case "\u0043\u0061\u0070\u0073":
				_dfdfa._fcfef = true
			case "\u0046\u0069\u0072\u0073\u0074\u0043\u0061\u0070":
				_dfdfa._bgcaa = true
			}
			_ecaed++
		}
	}
	return _dfdfa
}

// Clear resets the numbering.
func (_bead Numbering) Clear() {
	_bead._ebge.AbstractNum = nil
	_bead._ebge.Num = nil
	_bead._ebge.NumIdMacAtCleanup = nil
	_bead._ebge.NumPicBullet = nil
}

// X returns the inner wrapped XML type.
func (_cbaf ParagraphStyleProperties) X() *_ec.CT_PPrGeneral { return _cbaf._abef }

// HasFootnotes returns a bool based on the presence or abscence of footnotes within
// the document.
func (_ceca *Document) HasFootnotes() bool { return _ceca._dea != nil }

// X returns the inner wrapped XML type.
func (_gdfg TableProperties) X() *_ec.CT_TblPr { return _gdfg._ddac }

// X returns the internally wrapped *wml.CT_SectPr.
func (_gbeg Section) X() *_ec.CT_SectPr { return _gbeg._efad }

// Index returns the index of the footer within the document.  This is used to
// form its zip packaged filename as well as to match it with its relationship
// ID.
func (_gbae Footer) Index() int {
	for _cfeb, _gdab := range _gbae._bcf._ead {
		if _gdab == _gbae._abd {
			return _cfeb
		}
	}
	return -1
}

// Name returns the name of the field.
func (_bgfe FormField) Name() string { return *_bgfe._bef.Name[0].ValAttr }

// Styles is the document wide styles contained in styles.xml.
type Styles struct{ _gccd *_ec.Styles }

// AddTable adds a new table to the document body.
func (_dde *Document) AddTable() Table {
	_cge := _ec.NewEG_BlockLevelElts()
	_dde._bbef.Body.EG_BlockLevelElts = append(_dde._bbef.Body.EG_BlockLevelElts, _cge)
	_faa := _ec.NewEG_ContentBlockContent()
	_cge.EG_ContentBlockContent = append(_cge.EG_ContentBlockContent, _faa)
	_bfd := _ec.NewCT_Tbl()
	_faa.Tbl = append(_faa.Tbl, _bfd)
	return Table{_dde, _bfd}
}

// X returns the inner wrapped XML type.
func (_gffgb Header) X() *_ec.Hdr { return _gffgb._gca }

// SetKeepOnOnePage controls if all lines in a paragraph are kept on the same
// page.
func (_fgac ParagraphProperties) SetKeepOnOnePage(b bool) {
	if !b {
		_fgac._aeda.KeepLines = nil
	} else {
		_fgac._aeda.KeepLines = _ec.NewCT_OnOff()
	}
}

// SetSize sets size attribute for a FormFieldTypeCheckBox in pt.
func (_cgbf FormField) SetSize(size uint64) {
	size *= 2
	if _cgbf._bef.CheckBox != nil {
		_cgbf._bef.CheckBox.Choice = _ec.NewCT_FFCheckBoxChoice()
		_cgbf._bef.CheckBox.Choice.Size = _ec.NewCT_HpsMeasure()
		_cgbf._bef.CheckBox.Choice.Size.ValAttr = _ec.ST_HpsMeasure{ST_UnsignedDecimalNumber: &size}
	}
}

// SetHeight allows controlling the height of a row within a table.
func (_aebe RowProperties) SetHeight(ht _fg.Distance, rule _ec.ST_HeightRule) {
	if rule == _ec.ST_HeightRuleUnset {
		_aebe._bdba.TrHeight = nil
	} else {
		_decb := _ec.NewCT_Height()
		_decb.HRuleAttr = rule
		_decb.ValAttr = &_bc.ST_TwipsMeasure{}
		_decb.ValAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(ht / _fg.Twips))
		_aebe._bdba.TrHeight = []*_ec.CT_Height{_decb}
	}
}

// SetBefore sets the spacing that comes before the paragraph.
func (_gdaf ParagraphSpacing) SetBefore(before _fg.Distance) {
	_gdaf._agffc.BeforeAttr = &_bc.ST_TwipsMeasure{}
	_gdaf._agffc.BeforeAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(before / _fg.Twips))
}

// SetPossibleValues sets possible values for a FormFieldTypeDropDown.
func (_adae FormField) SetPossibleValues(values []string) {
	if _adae._bef.DdList != nil {
		for _, _agcc := range values {
			_afga := _ec.NewCT_String()
			_afga.ValAttr = _agcc
			_adae._bef.DdList.ListEntry = append(_adae._bef.DdList.ListEntry, _afga)
		}
	}
}

func (_aebeg Styles) initializeStyleDefaults() {
	_geff := _aebeg.AddStyle("\u004e\u006f\u0072\u006d\u0061\u006c", _ec.ST_StyleTypeParagraph, true)
	_geff.SetName("\u004e\u006f\u0072\u006d\u0061\u006c")
	_geff.SetPrimaryStyle(true)
	_bgfda := _aebeg.AddStyle("D\u0065f\u0061\u0075\u006c\u0074\u0050\u0061\u0072\u0061g\u0072\u0061\u0070\u0068Fo\u006e\u0074", _ec.ST_StyleTypeCharacter, true)
	_bgfda.SetName("\u0044\u0065\u0066\u0061ul\u0074\u0020\u0050\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u0046\u006fn\u0074")
	_bgfda.SetUISortOrder(1)
	_bgfda.SetSemiHidden(true)
	_bgfda.SetUnhideWhenUsed(true)
	_aedd := _aebeg.AddStyle("\u0054i\u0074\u006c\u0065\u0043\u0068\u0061r", _ec.ST_StyleTypeCharacter, false)
	_aedd.SetName("\u0054\u0069\u0074\u006c\u0065\u0020\u0043\u0068\u0061\u0072")
	_aedd.SetBasedOn(_bgfda.StyleID())
	_aedd.SetLinkedStyle("\u0054\u0069\u0074l\u0065")
	_aedd.SetUISortOrder(10)
	_aedd.RunProperties().Fonts().SetASCIITheme(_ec.ST_ThemeMajorAscii)
	_aedd.RunProperties().Fonts().SetEastAsiaTheme(_ec.ST_ThemeMajorEastAsia)
	_aedd.RunProperties().Fonts().SetHANSITheme(_ec.ST_ThemeMajorHAnsi)
	_aedd.RunProperties().Fonts().SetCSTheme(_ec.ST_ThemeMajorBidi)
	_aedd.RunProperties().SetSize(28 * _fg.Point)
	_aedd.RunProperties().SetKerning(14 * _fg.Point)
	_aedd.RunProperties().SetCharacterSpacing(-10 * _fg.Twips)
	_ebabb := _aebeg.AddStyle("\u0054\u0069\u0074l\u0065", _ec.ST_StyleTypeParagraph, false)
	_ebabb.SetName("\u0054\u0069\u0074l\u0065")
	_ebabb.SetBasedOn(_geff.StyleID())
	_ebabb.SetNextStyle(_geff.StyleID())
	_ebabb.SetLinkedStyle(_aedd.StyleID())
	_ebabb.SetUISortOrder(10)
	_ebabb.SetPrimaryStyle(true)
	_ebabb.ParagraphProperties().SetContextualSpacing(true)
	_ebabb.RunProperties().Fonts().SetASCIITheme(_ec.ST_ThemeMajorAscii)
	_ebabb.RunProperties().Fonts().SetEastAsiaTheme(_ec.ST_ThemeMajorEastAsia)
	_ebabb.RunProperties().Fonts().SetHANSITheme(_ec.ST_ThemeMajorHAnsi)
	_ebabb.RunProperties().Fonts().SetCSTheme(_ec.ST_ThemeMajorBidi)
	_ebabb.RunProperties().SetSize(28 * _fg.Point)
	_ebabb.RunProperties().SetKerning(14 * _fg.Point)
	_ebabb.RunProperties().SetCharacterSpacing(-10 * _fg.Twips)
	_acceb := _aebeg.AddStyle("T\u0061\u0062\u006c\u0065\u004e\u006f\u0072\u006d\u0061\u006c", _ec.ST_StyleTypeTable, false)
	_acceb.SetName("\u004e\u006f\u0072m\u0061\u006c\u0020\u0054\u0061\u0062\u006c\u0065")
	_acceb.SetUISortOrder(99)
	_acceb.SetSemiHidden(true)
	_acceb.SetUnhideWhenUsed(true)
	_acceb.X().TblPr = _ec.NewCT_TblPrBase()
	_beda := NewTableWidth()
	_acceb.X().TblPr.TblInd = _beda.X()
	_beda.SetValue(0 * _fg.Dxa)
	_acceb.X().TblPr.TblCellMar = _ec.NewCT_TblCellMar()
	_beda = NewTableWidth()
	_acceb.X().TblPr.TblCellMar.Top = _beda.X()
	_beda.SetValue(0 * _fg.Dxa)
	_beda = NewTableWidth()
	_acceb.X().TblPr.TblCellMar.Bottom = _beda.X()
	_beda.SetValue(0 * _fg.Dxa)
	_beda = NewTableWidth()
	_acceb.X().TblPr.TblCellMar.Left = _beda.X()
	_beda.SetValue(108 * _fg.Dxa)
	_beda = NewTableWidth()
	_acceb.X().TblPr.TblCellMar.Right = _beda.X()
	_beda.SetValue(108 * _fg.Dxa)
	_bfef := _aebeg.AddStyle("\u004e\u006f\u004c\u0069\u0073\u0074", _ec.ST_StyleTypeNumbering, false)
	_bfef.SetName("\u004eo\u0020\u004c\u0069\u0073\u0074")
	_bfef.SetUISortOrder(1)
	_bfef.SetSemiHidden(true)
	_bfef.SetUnhideWhenUsed(true)
	_dagg := []_fg.Distance{16, 13, 12, 11, 11, 11, 11, 11, 11}
	_ecdf := []_fg.Distance{240, 40, 40, 40, 40, 40, 40, 40, 40}
	for _cgebf := 0; _cgebf < 9; _cgebf++ {
		_fcadd := _cfc.Sprintf("\u0048e\u0061\u0064\u0069\u006e\u0067\u0025d", _cgebf+1)
		_gfde := _aebeg.AddStyle(_fcadd+"\u0043\u0068\u0061\u0072", _ec.ST_StyleTypeCharacter, false)
		_gfde.SetName(_cfc.Sprintf("\u0048e\u0061d\u0069\u006e\u0067\u0020\u0025\u0064\u0020\u0043\u0068\u0061\u0072", _cgebf+1))
		_gfde.SetBasedOn(_bgfda.StyleID())
		_gfde.SetLinkedStyle(_fcadd)
		_gfde.SetUISortOrder(9 + _cgebf)
		_gfde.RunProperties().SetSize(_dagg[_cgebf] * _fg.Point)
		_gabe := _aebeg.AddStyle(_fcadd, _ec.ST_StyleTypeParagraph, false)
		_gabe.SetName(_cfc.Sprintf("\u0068\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0064", _cgebf+1))
		_gabe.SetNextStyle(_geff.StyleID())
		_gabe.SetLinkedStyle(_gabe.StyleID())
		_gabe.SetUISortOrder(9 + _cgebf)
		_gabe.SetPrimaryStyle(true)
		_gabe.ParagraphProperties().SetKeepNext(true)
		_gabe.ParagraphProperties().SetSpacing(_ecdf[_cgebf]*_fg.Twips, 0)
		_gabe.ParagraphProperties().SetOutlineLevel(_cgebf)
		_gabe.RunProperties().SetSize(_dagg[_cgebf] * _fg.Point)
	}
}

// SetWidth sets the table with to a specified width.
func (_babc TableProperties) SetWidth(d _fg.Distance) {
	_babc._ddac.TblW = _ec.NewCT_TblWidth()
	_babc._ddac.TblW.TypeAttr = _ec.ST_TblWidthDxa
	_babc._ddac.TblW.WAttr = &_ec.ST_MeasurementOrPercent{}
	_babc._ddac.TblW.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_babc._ddac.TblW.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(d / _fg.Twips))
}

// VerticalAlign returns the value of paragraph vertical align.
func (_ddbe ParagraphProperties) VerticalAlignment() _bc.ST_VerticalAlignRun {
	if _bddebg := _ddbe._aeda.RPr.VertAlign; _bddebg != nil {
		return _bddebg.ValAttr
	}
	return 0
}

// X returns the inner wrapped XML type.
func (_dfece Styles) X() *_ec.Styles { return _dfece._gccd }

// IsBold returns true if the run has been set to bold.
func (_ffbb RunProperties) IsBold() bool { return _ffbb.BoldValue() == OnOffValueOn }

// SetTop sets the top border to a specified type, color and thickness.
func (_bagdf TableBorders) SetTop(t _ec.ST_Border, c _ga.Color, thickness _fg.Distance) {
	_bagdf._bcd.Top = _ec.NewCT_Border()
	_edfca(_bagdf._bcd.Top, t, c, thickness)
}

// SetVerticalAlignment controls the vertical alignment of the run, this is used
// to control if text is superscript/subscript.
func (_deeg RunProperties) SetVerticalAlignment(v _bc.ST_VerticalAlignRun) {
	if v == _bc.ST_VerticalAlignRunUnset {
		_deeg._eeab.VertAlign = nil
	} else {
		_deeg._eeab.VertAlign = _ec.NewCT_VerticalAlignRun()
		_deeg._eeab.VertAlign.ValAttr = v
	}
}

// AbstractNumberID returns the ID that is unique within all numbering
// definitions that is used to assign the definition to a paragraph.
func (_gfbg NumberingDefinition) AbstractNumberID() int64 { return _gfbg._gafdd.AbstractNumIdAttr }

// AddFieldWithFormatting adds a field (automatically computed text) to the
// document with field specifc formatting.
func (_acfc Run) AddFieldWithFormatting(code string, fmt string, isDirty bool) {
	_fdfbe := _acfc.newIC()
	_fdfbe.FldChar = _ec.NewCT_FldChar()
	_fdfbe.FldChar.FldCharTypeAttr = _ec.ST_FldCharTypeBegin
	if isDirty {
		_fdfbe.FldChar.DirtyAttr = &_bc.ST_OnOff{}
		_fdfbe.FldChar.DirtyAttr.Bool = _e.Bool(true)
	}
	_fdfbe = _acfc.newIC()
	_fdfbe.InstrText = _ec.NewCT_Text()
	if fmt != "" {
		_fdfbe.InstrText.Content = code + "\u0020" + fmt
	} else {
		_fdfbe.InstrText.Content = code
	}
	_fdfbe = _acfc.newIC()
	_fdfbe.FldChar = _ec.NewCT_FldChar()
	_fdfbe.FldChar.FldCharTypeAttr = _ec.ST_FldCharTypeEnd
}

// X returns the inner wrapped XML type.
func (_abaa TableConditionalFormatting) X() *_ec.CT_TblStylePr { return _abaa._cbdbe }

func _gebc(_ceac *_ec.CT_OnOff) bool { return _ceac != nil }

const (
	OnOffValueUnset OnOffValue = iota
	OnOffValueOff
	OnOffValueOn
)

// RemoveParagraph removes a paragraph from the endnote.
func (_eade Endnote) RemoveParagraph(p Paragraph) {
	for _, _faea := range _eade.content() {
		for _cffc, _edbd := range _faea.P {
			if _edbd == p._bbee {
				copy(_faea.P[_cffc:], _faea.P[_cffc+1:])
				_faea.P = _faea.P[0 : len(_faea.P)-1]
				return
			}
		}
	}
}

// SetRight sets the cell right margin
func (_acd CellMargins) SetRight(d _fg.Distance) {
	_acd._cba.Right = _ec.NewCT_TblWidth()
	_fcf(_acd._cba.Right, d)
}

// Cell is a table cell within a document (not a spreadsheet)
type Cell struct {
	_ged *Document
	_dae *_ec.CT_Tc
}

func (_gaff *Document) tables(_bgcae *_ec.EG_ContentBlockContent) []Table {
	_fbg := []Table{}
	for _, _accb := range _bgcae.Tbl {
		_fbg = append(_fbg, Table{_gaff, _accb})
		for _, _gaag := range _accb.EG_ContentRowContent {
			for _, _ggb := range _gaag.Tr {
				for _, _fdgc := range _ggb.EG_ContentCellContent {
					for _, _deb := range _fdgc.Tc {
						for _, _bgba := range _deb.EG_BlockLevelElts {
							for _, _ecca := range _bgba.EG_ContentBlockContent {
								for _, _babg := range _gaff.tables(_ecca) {
									_fbg = append(_fbg, _babg)
								}
							}
						}
					}
				}
			}
		}
	}
	return _fbg
}

func (_ggfg Paragraph) addEndBookmark(_fcd int64) *_ec.CT_MarkupRange {
	_bdca := _ec.NewEG_PContent()
	_ggfg._bbee.EG_PContent = append(_ggfg._bbee.EG_PContent, _bdca)
	_gefd := _ec.NewEG_ContentRunContent()
	_cegg := _ec.NewEG_RunLevelElts()
	_ggfc := _ec.NewEG_RangeMarkupElements()
	_ccad := _ec.NewCT_MarkupRange()
	_ccad.IdAttr = _fcd
	_ggfc.BookmarkEnd = _ccad
	_bdca.EG_ContentRunContent = append(_bdca.EG_ContentRunContent, _gefd)
	_gefd.EG_RunLevelElts = append(_gefd.EG_RunLevelElts, _cegg)
	_cegg.EG_RangeMarkupElements = append(_cegg.EG_RangeMarkupElements, _ggfc)
	return _ccad
}

// CharacterSpacingMeasure returns paragraph characters spacing with its measure which can be mm, cm, in, pt, pc or pi.
func (_daaf RunProperties) CharacterSpacingMeasure() string {
	if _dcgba := _daaf._eeab.Spacing; _dcgba != nil {
		_fbag := _dcgba.ValAttr
		if _fbag.ST_UniversalMeasure != nil {
			return *_fbag.ST_UniversalMeasure
		}
	}
	return ""
}

// SetColor sets the text color.
func (_aaa RunProperties) SetColor(c _ga.Color) {
	_aaa._eeab.Color = _ec.NewCT_Color()
	_aaa._eeab.Color.ValAttr.ST_HexColorRGB = c.AsRGBString()
}

// SetVAlignment sets the vertical alignment for an anchored image.
func (_fed AnchoredDrawing) SetVAlignment(v _ec.WdST_AlignV) {
	_fed._fc.PositionV.Choice = &_ec.WdCT_PosVChoice{}
	_fed._fc.PositionV.Choice.Align = v
}

// AddImage adds an image to the document package, returning a reference that
// can be used to add the image to a run and place it in the document contents.
func (_gebgd Footer) AddImage(i _gc.Image) (_gc.ImageRef, error) {
	var _bbbb _gc.Relationships
	for _gbbc, _cbeb := range _gebgd._bcf._ead {
		if _cbeb == _gebgd._abd {
			_bbbb = _gebgd._bcf._ecc[_gbbc]
		}
	}
	_decc := _gc.MakeImageRef(i, &_gebgd._bcf.DocBase, _bbbb)
	if i.Data == nil && i.Path == "" {
		return _decc, _bf.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _decc, _bf.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _decc, _bf.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	_gebgd._bcf.Images = append(_gebgd._bcf.Images, _decc)
	_aff := _cfc.Sprintf("\u006d\u0065d\u0069\u0061\u002fi\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", len(_gebgd._bcf.Images), i.Format)
	_dgca := _bbbb.AddRelationship(_aff, _e.ImageType)
	_decc.SetRelID(_dgca.X().IdAttr)
	return _decc, nil
}

// SizeMeasure returns font with its measure which can be mm, cm, in, pt, pc or pi.
func (_bdege ParagraphProperties) SizeMeasure() string {
	if _fbbb := _bdege._aeda.RPr.Sz; _fbbb != nil {
		_afdg := _fbbb.ValAttr
		if _afdg.ST_PositiveUniversalMeasure != nil {
			return *_afdg.ST_PositiveUniversalMeasure
		}
	}
	return ""
}

func (_faaed Paragraph) addFldChar() *_ec.CT_FldChar {
	_bfdc := _faaed.AddRun()
	_faee := _bfdc.X()
	_fbb := _ec.NewEG_RunInnerContent()
	_bbge := _ec.NewCT_FldChar()
	_fbb.FldChar = _bbge
	_faee.EG_RunInnerContent = append(_faee.EG_RunInnerContent, _fbb)
	return _bbge
}

// Tables returns the tables defined in the document.
func (_ddd *Document) Tables() []Table {
	_fgc := []Table{}
	if _ddd._bbef.Body == nil {
		return nil
	}
	for _, _eecf := range _ddd._bbef.Body.EG_BlockLevelElts {
		for _, _fgd := range _eecf.EG_ContentBlockContent {
			for _, _gfe := range _ddd.tables(_fgd) {
				_fgc = append(_fgc, _gfe)
			}
		}
	}
	return _fgc
}

// SetEffect sets a text effect on the run.
func (_bdbee RunProperties) SetEffect(e _ec.ST_TextEffect) {
	if e == _ec.ST_TextEffectUnset {
		_bdbee._eeab.Effect = nil
	} else {
		_bdbee._eeab.Effect = _ec.NewCT_TextEffect()
		_bdbee._eeab.Effect.ValAttr = _ec.ST_TextEffectShimmer
	}
}

func _eccd(_feca *_ec.CT_Tbl, _gede *_ec.CT_P, _abb bool) *_ec.CT_Tbl {
	for _, _fff := range _feca.EG_ContentRowContent {
		for _, _efbe := range _fff.Tr {
			for _, _bfad := range _efbe.EG_ContentCellContent {
				for _, _eac := range _bfad.Tc {
					for _bgbb, _dcgef := range _eac.EG_BlockLevelElts {
						for _, _fcfe := range _dcgef.EG_ContentBlockContent {
							for _eea, _eab := range _fcfe.P {
								if _eab == _gede {
									_aac := _ec.NewEG_BlockLevelElts()
									_dabb := _ec.NewEG_ContentBlockContent()
									_aac.EG_ContentBlockContent = append(_aac.EG_ContentBlockContent, _dabb)
									_gdff := _ec.NewCT_Tbl()
									_dabb.Tbl = append(_dabb.Tbl, _gdff)
									_eac.EG_BlockLevelElts = append(_eac.EG_BlockLevelElts, nil)
									if _abb {
										copy(_eac.EG_BlockLevelElts[_bgbb+1:], _eac.EG_BlockLevelElts[_bgbb:])
										_eac.EG_BlockLevelElts[_bgbb] = _aac
										if _eea != 0 {
											_dcab := _ec.NewEG_BlockLevelElts()
											_bdgd := _ec.NewEG_ContentBlockContent()
											_dcab.EG_ContentBlockContent = append(_dcab.EG_ContentBlockContent, _bdgd)
											_bdgd.P = _fcfe.P[:_eea]
											_eac.EG_BlockLevelElts = append(_eac.EG_BlockLevelElts, nil)
											copy(_eac.EG_BlockLevelElts[_bgbb+1:], _eac.EG_BlockLevelElts[_bgbb:])
											_eac.EG_BlockLevelElts[_bgbb] = _dcab
										}
										_fcfe.P = _fcfe.P[_eea:]
									} else {
										copy(_eac.EG_BlockLevelElts[_bgbb+2:], _eac.EG_BlockLevelElts[_bgbb+1:])
										_eac.EG_BlockLevelElts[_bgbb+1] = _aac
										if _eea != len(_fcfe.P)-1 {
											_bfc := _ec.NewEG_BlockLevelElts()
											_bgca := _ec.NewEG_ContentBlockContent()
											_bfc.EG_ContentBlockContent = append(_bfc.EG_ContentBlockContent, _bgca)
											_bgca.P = _fcfe.P[_eea+1:]
											_eac.EG_BlockLevelElts = append(_eac.EG_BlockLevelElts, nil)
											copy(_eac.EG_BlockLevelElts[_bgbb+3:], _eac.EG_BlockLevelElts[_bgbb+2:])
											_eac.EG_BlockLevelElts[_bgbb+2] = _bfc
										} else {
											_accf := _ec.NewEG_BlockLevelElts()
											_bgf := _ec.NewEG_ContentBlockContent()
											_accf.EG_ContentBlockContent = append(_accf.EG_ContentBlockContent, _bgf)
											_bgf.P = []*_ec.CT_P{_ec.NewCT_P()}
											_eac.EG_BlockLevelElts = append(_eac.EG_BlockLevelElts, nil)
											copy(_eac.EG_BlockLevelElts[_bgbb+3:], _eac.EG_BlockLevelElts[_bgbb+2:])
											_eac.EG_BlockLevelElts[_bgbb+2] = _accf
										}
										_fcfe.P = _fcfe.P[:_eea+1]
									}
									return _gdff
								}
							}
							for _, _geb := range _fcfe.Tbl {
								_ffea := _eccd(_geb, _gede, _abb)
								if _ffea != nil {
									return _ffea
								}
							}
						}
					}
				}
			}
		}
	}
	return nil
}

// SetHangingIndent controls the hanging indent of the paragraph.
func (_dgffe ParagraphStyleProperties) SetHangingIndent(m _fg.Distance) {
	if _dgffe._abef.Ind == nil {
		_dgffe._abef.Ind = _ec.NewCT_Ind()
	}
	if m == _fg.Zero {
		_dgffe._abef.Ind.HangingAttr = nil
	} else {
		_dgffe._abef.Ind.HangingAttr = &_bc.ST_TwipsMeasure{}
		_dgffe._abef.Ind.HangingAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _fg.Twips))
	}
}

// AddParagraph adds a new paragraph to the document body.
func (_bfadc *Document) AddParagraph() Paragraph {
	_ecge := _ec.NewEG_BlockLevelElts()
	_bfadc._bbef.Body.EG_BlockLevelElts = append(_bfadc._bbef.Body.EG_BlockLevelElts, _ecge)
	_gcge := _ec.NewEG_ContentBlockContent()
	_ecge.EG_ContentBlockContent = append(_ecge.EG_ContentBlockContent, _gcge)
	_cae := _ec.NewCT_P()
	_gcge.P = append(_gcge.P, _cae)
	return Paragraph{_bfadc, _cae}
}

// SetSpacing sets the spacing that comes before and after the paragraph.
func (_gcffd ParagraphStyleProperties) SetSpacing(before, after _fg.Distance) {
	if _gcffd._abef.Spacing == nil {
		_gcffd._abef.Spacing = _ec.NewCT_Spacing()
	}
	if before == _fg.Zero {
		_gcffd._abef.Spacing.BeforeAttr = nil
	} else {
		_gcffd._abef.Spacing.BeforeAttr = &_bc.ST_TwipsMeasure{}
		_gcffd._abef.Spacing.BeforeAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(before / _fg.Twips))
	}
	if after == _fg.Zero {
		_gcffd._abef.Spacing.AfterAttr = nil
	} else {
		_gcffd._abef.Spacing.AfterAttr = &_bc.ST_TwipsMeasure{}
		_gcffd._abef.Spacing.AfterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(after / _fg.Twips))
	}
}

// Clear clears the styes.
func (_dafb Styles) Clear() {
	_dafb._gccd.DocDefaults = nil
	_dafb._gccd.LatentStyles = nil
	_dafb._gccd.Style = nil
}

// SetOffset sets the offset of the image relative to the origin, which by
// default this is the top-left corner of the page. Offset is incompatible with
// SetAlignment, whichever is called last is applied.
func (_af AnchoredDrawing) SetOffset(x, y _fg.Distance) { _af.SetXOffset(x); _af.SetYOffset(y) }

// MergeFields returns the list of all mail merge fields found in the document.
func (_fagd Document) MergeFields() []string {
	_gcc := map[string]struct{}{}
	for _, _cgd := range _fagd.mergeFields() {
		_gcc[_cgd._faac] = struct{}{}
	}
	_badf := []string{}
	for _badd := range _gcc {
		_badf = append(_badf, _badd)
	}
	return _badf
}

// SetLinkedStyle sets the style that this style is linked to.
func (_egcc Style) SetLinkedStyle(name string) {
	if name == "" {
		_egcc._dacg.Link = nil
	} else {
		_egcc._dacg.Link = _ec.NewCT_String()
		_egcc._dacg.Link.ValAttr = name
	}
}

func (_cdgd Paragraph) insertRun(_deg Run, _gfcfb bool) Run {
	for _, _aef := range _cdgd._bbee.EG_PContent {
		for _agdff, _abe := range _aef.EG_ContentRunContent {
			if _abe.R == _deg.X() {
				_dggb := _ec.NewCT_R()
				_aef.EG_ContentRunContent = append(_aef.EG_ContentRunContent, nil)
				if _gfcfb {
					copy(_aef.EG_ContentRunContent[_agdff+1:], _aef.EG_ContentRunContent[_agdff:])
					_aef.EG_ContentRunContent[_agdff] = _ec.NewEG_ContentRunContent()
					_aef.EG_ContentRunContent[_agdff].R = _dggb
				} else {
					copy(_aef.EG_ContentRunContent[_agdff+2:], _aef.EG_ContentRunContent[_agdff+1:])
					_aef.EG_ContentRunContent[_agdff+1] = _ec.NewEG_ContentRunContent()
					_aef.EG_ContentRunContent[_agdff+1].R = _dggb
				}
				return Run{_cdgd._baf, _dggb}
			}
			if _abe.Sdt != nil && _abe.Sdt.SdtContent != nil {
				for _, _cdd := range _abe.Sdt.SdtContent.EG_ContentRunContent {
					if _cdd.R == _deg.X() {
						_dbgf := _ec.NewCT_R()
						_abe.Sdt.SdtContent.EG_ContentRunContent = append(_abe.Sdt.SdtContent.EG_ContentRunContent, nil)
						if _gfcfb {
							copy(_abe.Sdt.SdtContent.EG_ContentRunContent[_agdff+1:], _abe.Sdt.SdtContent.EG_ContentRunContent[_agdff:])
							_abe.Sdt.SdtContent.EG_ContentRunContent[_agdff] = _ec.NewEG_ContentRunContent()
							_abe.Sdt.SdtContent.EG_ContentRunContent[_agdff].R = _dbgf
						} else {
							copy(_abe.Sdt.SdtContent.EG_ContentRunContent[_agdff+2:], _abe.Sdt.SdtContent.EG_ContentRunContent[_agdff+1:])
							_abe.Sdt.SdtContent.EG_ContentRunContent[_agdff+1] = _ec.NewEG_ContentRunContent()
							_abe.Sdt.SdtContent.EG_ContentRunContent[_agdff+1].R = _dbgf
						}
						return Run{_cdgd._baf, _dbgf}
					}
				}
			}
		}
	}
	return _cdgd.AddRun()
}

// NewSettings constructs a new empty Settings
func NewSettings() Settings {
	_aede := _ec.NewSettings()
	_aede.Compat = _ec.NewCT_Compat()
	_eefe := _ec.NewCT_CompatSetting()
	_eefe.NameAttr = _e.String("\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074y\u004d\u006f\u0064\u0065")
	_eefe.UriAttr = _e.String("h\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002e\u006d\u0069\u0063\u0072o\u0073\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006fff\u0069\u0063\u0065/\u0077o\u0072\u0064")
	_eefe.ValAttr = _e.String("\u0031\u0035")
	_aede.Compat.CompatSetting = append(_aede.Compat.CompatSetting, _eefe)
	return Settings{_aede}
}

// SetValue sets the value of a FormFieldTypeText or FormFieldTypeDropDown. For
// FormFieldTypeDropDown, the value must be one of the fields possible values.
func (_dedg FormField) SetValue(v string) {
	if _dedg._bef.DdList != nil {
		for _gagb, _dbag := range _dedg.PossibleValues() {
			if _dbag == v {
				_dedg._bef.DdList.Result = _ec.NewCT_DecimalNumber()
				_dedg._bef.DdList.Result.ValAttr = int64(_gagb)
				break
			}
		}
	} else if _dedg._bef.TextInput != nil {
		_dedg._adbc.T = _ec.NewCT_Text()
		_dedg._adbc.T.Content = v
	}
}

// Strike returns true if run is striked.
func (_cced RunProperties) Strike() bool { return _gebc(_cced._eeab.Strike) }

// Header is a header for a document section.
type Header struct {
	_fceb *Document
	_gca  *_ec.Hdr
}

// Runs returns all of the runs in a paragraph.
func (_fbdb Paragraph) Runs() []Run {
	_agfb := []Run{}
	for _, _fadb := range _fbdb._bbee.EG_PContent {
		for _, _agdfa := range _fadb.EG_ContentRunContent {
			if _agdfa.R != nil {
				_agfb = append(_agfb, Run{_fbdb._baf, _agdfa.R})
			}
			if _agdfa.Sdt != nil && _agdfa.Sdt.SdtContent != nil {
				for _, _bcc := range _agdfa.Sdt.SdtContent.EG_ContentRunContent {
					if _bcc.R != nil {
						_agfb = append(_agfb, Run{_fbdb._baf, _bcc.R})
					}
				}
			}
		}
	}
	return _agfb
}

// SetName sets the name of the style.
func (_eegb Style) SetName(name string) {
	_eegb._dacg.Name = _ec.NewCT_String()
	_eegb._dacg.Name.ValAttr = name
}

func _gdbf(_efff *_ec.CT_OnOff) OnOffValue {
	if _efff == nil {
		return OnOffValueUnset
	}
	if _efff.ValAttr != nil && _efff.ValAttr.Bool != nil && *_efff.ValAttr.Bool == false {
		return OnOffValueOff
	}
	return OnOffValueOn
}

// FormFieldType is the type of the form field.
//go:generate stringer -type=FormFieldType
type FormFieldType byte

// CellBorders are the borders for an individual
type CellBorders struct{ _dcb *_ec.CT_TcBorders }

// SetKeepOnOnePage controls if all lines in a paragraph are kept on the same
// page.
func (_dfec ParagraphStyleProperties) SetKeepOnOnePage(b bool) {
	if !b {
		_dfec._abef.KeepLines = nil
	} else {
		_dfec._abef.KeepLines = _ec.NewCT_OnOff()
	}
}

// InlineDrawing is an inlined image within a run.
type InlineDrawing struct {
	_bgga *Document
	_aebg *_ec.WdInline
}

// NewNumbering constructs a new numbering.
func NewNumbering() Numbering { _bdga := _ec.NewNumbering(); return Numbering{_bdga} }

// SetValue sets the width value.
func (_gbgb TableWidth) SetValue(m _fg.Distance) {
	_gbgb._ebef.WAttr = &_ec.ST_MeasurementOrPercent{}
	_gbgb._ebef.WAttr.ST_DecimalNumberOrPercent = &_ec.ST_DecimalNumberOrPercent{}
	_gbgb._ebef.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(m / _fg.Twips))
	_gbgb._ebef.TypeAttr = _ec.ST_TblWidthDxa
}

// ParagraphProperties are the properties for a paragraph.
type ParagraphProperties struct {
	_fgbg *Document
	_aeda *_ec.CT_PPr
}

// DoubleStrike returns true if paragraph is double striked.
func (_aaed ParagraphProperties) DoubleStrike() bool { return _gebc(_aaed._aeda.RPr.Dstrike) }

// Settings controls the document settings.
type Settings struct{ _ebfg *_ec.Settings }

// SetHANSITheme sets the font H ANSI Theme.
func (_cfab Fonts) SetHANSITheme(t _ec.ST_Theme) { _cfab._dcade.HAnsiThemeAttr = t }

func _edfca(_ccaaf *_ec.CT_Border, _edeg _ec.ST_Border, _bbec _ga.Color, _fbdbe _fg.Distance) {
	_ccaaf.ValAttr = _edeg
	_ccaaf.ColorAttr = &_ec.ST_HexColor{}
	if _bbec.IsAuto() {
		_ccaaf.ColorAttr.ST_HexColorAuto = _ec.ST_HexColorAutoAuto
	} else {
		_ccaaf.ColorAttr.ST_HexColorRGB = _bbec.AsRGBString()
	}
	if _fbdbe != _fg.Zero {
		_ccaaf.SzAttr = _e.Uint64(uint64(_fbdbe / _fg.Point * 8))
	}
}

// SetEastAsiaTheme sets the font East Asia Theme.
func (_gaeb Fonts) SetEastAsiaTheme(t _ec.ST_Theme) { _gaeb._dcade.EastAsiaThemeAttr = t }
