//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sharedTypes

import (
	_g "encoding/xml"
	_b "fmt"
	_a "regexp"
)

func (_aefg ST_TrueFalseBlank) Validate() error { return _aefg.ValidateWithPath("") }

func (_bgf *ST_ConformanceClass) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_afda, _gefa := d.Token()
	if _gefa != nil {
		return _gefa
	}
	if _cbf, _fgb := _afda.(_g.EndElement); _fgb && _cbf.Name == start.Name {
		*_bgf = 1
		return nil
	}
	if _aac, _fdfc := _afda.(_g.CharData); !_fdfc {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _afda)
	} else {
		switch string(_aac) {
		case "":
			*_bgf = 0
		case "\u0073\u0074\u0072\u0069\u0063\u0074":
			*_bgf = 1
		case "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c":
			*_bgf = 2
		}
	}
	_afda, _gefa = d.Token()
	if _gefa != nil {
		return _gefa
	}
	if _eag, _gaa := _afda.(_g.EndElement); _gaa && _eag.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _afda)
}

// ST_OnOff is a union type
type ST_OnOff struct {
	Bool      *bool
	ST_OnOff1 ST_OnOff1
}

func (_cc ST_CalendarType) Validate() error { return _cc.ValidateWithPath("") }

func (_dbge ST_AlgType) Validate() error { return _dbge.ValidateWithPath("") }

func (_aa ST_TrueFalse) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ddg := _g.Attr{}
	_ddg.Name = name
	switch _aa {
	case ST_TrueFalseUnset:
		_ddg.Value = ""
	case ST_TrueFalseT:
		_ddg.Value = "\u0074"
	case ST_TrueFalseF:
		_ddg.Value = "\u0066"
	case ST_TrueFalseTrue:
		_ddg.Value = "\u0074\u0072\u0075\u0065"
	case ST_TrueFalseFalse:
		_ddg.Value = "\u0066\u0061\u006cs\u0065"
	}
	return _ddg, nil
}

func (_eee *ST_CryptProv) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_eee = 0
	case "\u0072\u0073\u0061\u0041\u0045\u0053":
		*_eee = 1
	case "\u0072s\u0061\u0046\u0075\u006c\u006c":
		*_eee = 2
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_eee = 3
	}
	return nil
}

const ST_PositivePercentagePattern = "\u005b0\u002d9\u005d\u002b\u0028\u005c\u002e[\u0030\u002d9\u005d\u002b\u0029\u003f\u0025"

const (
	ST_YAlignUnset   ST_YAlign = 0
	ST_YAlignInline  ST_YAlign = 1
	ST_YAlignTop     ST_YAlign = 2
	ST_YAlignCenter  ST_YAlign = 3
	ST_YAlignBottom  ST_YAlign = 4
	ST_YAlignInside  ST_YAlign = 5
	ST_YAlignOutside ST_YAlign = 6
)

const ST_PercentagePattern = "-\u003f[\u0030\u002d\u0039\u005d\u002b\u0028\u005c\u002e[\u0030\u002d\u0039\u005d+)\u003f\u0025"

func (_caa ST_XAlign) Validate() error { return _caa.ValidateWithPath("") }

const ST_GuidPattern = "\u005c\u007b\u005b\u0030\u002d\u0039\u0041\u002d\u0046\u005d\u007b\u0038\u007d\u002d\u005b\u0030\u002d9\u0041\u002d\u0046\u005d\u007b\u0034\u007d\u002d\u005b\u0030-\u0039\u0041\u002d\u0046\u005d\u007b\u0034\u007d\u002d\u005b\u0030\u002d\u0039\u0041\u002d\u0046\u005d\u007b4\u007d\u002d\u005b\u0030\u002d\u0039A\u002d\u0046]\u007b\u00312\u007d\\\u007d"

var ST_PositiveFixedPercentagePatternRe = _a.MustCompile(ST_PositiveFixedPercentagePattern)

const (
	ST_TrueFalseBlankUnset  ST_TrueFalseBlank = 0
	ST_TrueFalseBlankT      ST_TrueFalseBlank = 1
	ST_TrueFalseBlankF      ST_TrueFalseBlank = 2
	ST_TrueFalseBlankTrue   ST_TrueFalseBlank = 3
	ST_TrueFalseBlankFalse  ST_TrueFalseBlank = 4
	ST_TrueFalseBlankTrue_  ST_TrueFalseBlank = 6
	ST_TrueFalseBlankFalse_ ST_TrueFalseBlank = 7
)

type ST_AlgType byte

func (_ef *ST_CalendarType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_ef = 0
	case "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n":
		*_ef = 1
	case "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073":
		*_ef = 2
	case "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068":
		*_ef = 3
	case "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063":
		*_ef = 4
	case "\u0068\u0069\u006ar\u0069":
		*_ef = 5
	case "\u0068\u0065\u0062\u0072\u0065\u0077":
		*_ef = 6
	case "\u0074\u0061\u0069\u0077\u0061\u006e":
		*_ef = 7
	case "\u006a\u0061\u0070a\u006e":
		*_ef = 8
	case "\u0074\u0068\u0061\u0069":
		*_ef = 9
	case "\u006b\u006f\u0072e\u0061":
		*_ef = 10
	case "\u0073\u0061\u006b\u0061":
		*_ef = 11
	case "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068":
		*_ef = 12
	case "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068":
		*_ef = 13
	case "\u006e\u006f\u006e\u0065":
		*_ef = 14
	}
	return nil
}

func (_gegd ST_OnOff1) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gegd.String(), start)
}

func (_f *ST_OnOff) ValidateWithPath(path string) error {
	_ea := []string{}
	if _f.Bool != nil {
		_ea = append(_ea, "\u0042\u006f\u006f\u006c")
	}
	if _f.ST_OnOff1 != ST_OnOff1Unset {
		_ea = append(_ea, "\u0053T\u005f\u004f\u006e\u004f\u0066\u00661")
	}
	if len(_ea) > 1 {
		return _b.Errorf("%\u0073\u0020\u0074\u006f\u006f\u0020m\u0061\u006e\u0079\u0020\u006d\u0065\u006d\u0062\u0065r\u0073\u0020\u0073e\u0074:\u0020\u0025\u0076", path, _ea)
	}
	return nil
}

func (_eaa ST_XAlign) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_egf := _g.Attr{}
	_egf.Name = name
	switch _eaa {
	case ST_XAlignUnset:
		_egf.Value = ""
	case ST_XAlignLeft:
		_egf.Value = "\u006c\u0065\u0066\u0074"
	case ST_XAlignCenter:
		_egf.Value = "\u0063\u0065\u006e\u0074\u0065\u0072"
	case ST_XAlignRight:
		_egf.Value = "\u0072\u0069\u0067h\u0074"
	case ST_XAlignInside:
		_egf.Value = "\u0069\u006e\u0073\u0069\u0064\u0065"
	case ST_XAlignOutside:
		_egf.Value = "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return _egf, nil
}

func (_adg ST_OnOff1) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ebf := _g.Attr{}
	_ebf.Name = name
	switch _adg {
	case ST_OnOff1Unset:
		_ebf.Value = ""
	case ST_OnOff1On:
		_ebf.Value = "\u006f\u006e"
	case ST_OnOff1Off:
		_ebf.Value = "\u006f\u0066\u0066"
	}
	return _ebf, nil
}

const (
	ST_CalendarTypeUnset                ST_CalendarType = 0
	ST_CalendarTypeGregorian            ST_CalendarType = 1
	ST_CalendarTypeGregorianUs          ST_CalendarType = 2
	ST_CalendarTypeGregorianMeFrench    ST_CalendarType = 3
	ST_CalendarTypeGregorianArabic      ST_CalendarType = 4
	ST_CalendarTypeHijri                ST_CalendarType = 5
	ST_CalendarTypeHebrew               ST_CalendarType = 6
	ST_CalendarTypeTaiwan               ST_CalendarType = 7
	ST_CalendarTypeJapan                ST_CalendarType = 8
	ST_CalendarTypeThai                 ST_CalendarType = 9
	ST_CalendarTypeKorea                ST_CalendarType = 10
	ST_CalendarTypeSaka                 ST_CalendarType = 11
	ST_CalendarTypeGregorianXlitEnglish ST_CalendarType = 12
	ST_CalendarTypeGregorianXlitFrench  ST_CalendarType = 13
	ST_CalendarTypeNone                 ST_CalendarType = 14
)

func (_gff ST_AlgType) String() string {
	switch _gff {
	case 0:
		return ""
	case 1:
		return "\u0074y\u0070\u0065\u0041\u006e\u0079"
	case 2:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}

func (_ae *ST_AlgClass) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aef, _gbee := d.Token()
	if _gbee != nil {
		return _gbee
	}
	if _ga, _ce := _aef.(_g.EndElement); _ce && _ga.Name == start.Name {
		*_ae = 1
		return nil
	}
	if _fd, _aeb := _aef.(_g.CharData); !_aeb {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _aef)
	} else {
		switch string(_fd) {
		case "":
			*_ae = 0
		case "\u0068\u0061\u0073\u0068":
			*_ae = 1
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_ae = 2
		}
	}
	_aef, _gbee = d.Token()
	if _gbee != nil {
		return _gbee
	}
	if _dfa, _dag := _aef.(_g.EndElement); _dag && _dfa.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _aef)
}

type ST_ConformanceClass byte

func (_fb ST_CalendarType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_be := _g.Attr{}
	_be.Name = name
	switch _fb {
	case ST_CalendarTypeUnset:
		_be.Value = ""
	case ST_CalendarTypeGregorian:
		_be.Value = "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n"
	case ST_CalendarTypeGregorianUs:
		_be.Value = "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073"
	case ST_CalendarTypeGregorianMeFrench:
		_be.Value = "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068"
	case ST_CalendarTypeGregorianArabic:
		_be.Value = "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063"
	case ST_CalendarTypeHijri:
		_be.Value = "\u0068\u0069\u006ar\u0069"
	case ST_CalendarTypeHebrew:
		_be.Value = "\u0068\u0065\u0062\u0072\u0065\u0077"
	case ST_CalendarTypeTaiwan:
		_be.Value = "\u0074\u0061\u0069\u0077\u0061\u006e"
	case ST_CalendarTypeJapan:
		_be.Value = "\u006a\u0061\u0070a\u006e"
	case ST_CalendarTypeThai:
		_be.Value = "\u0074\u0068\u0061\u0069"
	case ST_CalendarTypeKorea:
		_be.Value = "\u006b\u006f\u0072e\u0061"
	case ST_CalendarTypeSaka:
		_be.Value = "\u0073\u0061\u006b\u0061"
	case ST_CalendarTypeGregorianXlitEnglish:
		_be.Value = "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068"
	case ST_CalendarTypeGregorianXlitFrench:
		_be.Value = "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068"
	case ST_CalendarTypeNone:
		_be.Value = "\u006e\u006f\u006e\u0065"
	}
	return _be, nil
}

func (_egb ST_YAlign) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_egb.String(), start)
}

func (_ec ST_OnOff) String() string {
	if _ec.Bool != nil {
		return _b.Sprintf("\u0025\u0076", *_ec.Bool)
	}
	if _ec.ST_OnOff1 != ST_OnOff1Unset {
		return _ec.ST_OnOff1.String()
	}
	return ""
}

func (_gg *ST_VerticalAlignRun) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cdb, _gea := d.Token()
	if _gea != nil {
		return _gea
	}
	if _ebb, _cgg := _cdb.(_g.EndElement); _cgg && _ebb.Name == start.Name {
		*_gg = 1
		return nil
	}
	if _cag, _bggc := _cdb.(_g.CharData); !_bggc {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cdb)
	} else {
		switch string(_cag) {
		case "":
			*_gg = 0
		case "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":
			*_gg = 1
		case "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074":
			*_gg = 2
		case "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t":
			*_gg = 3
		}
	}
	_cdb, _gea = d.Token()
	if _gea != nil {
		return _gea
	}
	if _dcf, _fbcc := _cdb.(_g.EndElement); _fbcc && _dcf.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cdb)
}

func (_cb ST_TrueFalse) String() string {
	switch _cb {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0066"
	case 3:
		return "\u0074\u0072\u0075\u0065"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}

func (_dbg ST_CryptProv) String() string {
	switch _dbg {
	case 0:
		return ""
	case 1:
		return "\u0072\u0073\u0061\u0041\u0045\u0053"
	case 2:
		return "\u0072s\u0061\u0046\u0075\u006c\u006c"
	case 3:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}

func (_gbb ST_TrueFalseBlank) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gfda := _g.Attr{}
	_gfda.Name = name
	switch _gbb {
	case ST_TrueFalseBlankUnset:
		_gfda.Value = ""
	case ST_TrueFalseBlankT:
		_gfda.Value = "\u0074"
	case ST_TrueFalseBlankF:
		_gfda.Value = "\u0066"
	case ST_TrueFalseBlankTrue:
		_gfda.Value = "\u0074\u0072\u0075\u0065"
	case ST_TrueFalseBlankFalse:
		_gfda.Value = "\u0066\u0061\u006cs\u0065"
	case ST_TrueFalseBlankTrue_:
		_gfda.Value = "\u0054\u0072\u0075\u0065"
	case ST_TrueFalseBlankFalse_:
		_gfda.Value = "\u0046\u0061\u006cs\u0065"
	}
	return _gfda, nil
}

func (_bgg ST_AlgType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ad := _g.Attr{}
	_ad.Name = name
	switch _bgg {
	case ST_AlgTypeUnset:
		_ad.Value = ""
	case ST_AlgTypeTypeAny:
		_ad.Value = "\u0074y\u0070\u0065\u0041\u006e\u0079"
	case ST_AlgTypeCustom:
		_ad.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _ad, nil
}

func (_abb ST_CryptProv) Validate() error { return _abb.ValidateWithPath("") }

func (_ffa *ST_OnOff1) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_eba, _bbf := d.Token()
	if _bbf != nil {
		return _bbf
	}
	if _fdf, _bf := _eba.(_g.EndElement); _bf && _fdf.Name == start.Name {
		*_ffa = 1
		return nil
	}
	if _ffc, _gef := _eba.(_g.CharData); !_gef {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _eba)
	} else {
		switch string(_ffc) {
		case "":
			*_ffa = 0
		case "\u006f\u006e":
			*_ffa = 1
		case "\u006f\u0066\u0066":
			*_ffa = 2
		}
	}
	_eba, _bbf = d.Token()
	if _bbf != nil {
		return _bbf
	}
	if _gfd, _aec := _eba.(_g.EndElement); _aec && _gfd.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _eba)
}

const (
	ST_AlgTypeUnset   ST_AlgType = 0
	ST_AlgTypeTypeAny ST_AlgType = 1
	ST_AlgTypeCustom  ST_AlgType = 2
)

func (_agg ST_CryptProv) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_agg.String(), start)
}

func (_gae *ST_TrueFalse) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gae = 0
	case "\u0074":
		*_gae = 1
	case "\u0066":
		*_gae = 2
	case "\u0074\u0072\u0075\u0065":
		*_gae = 3
	case "\u0066\u0061\u006cs\u0065":
		*_gae = 4
	}
	return nil
}

func (_bdf ST_YAlign) String() string {
	switch _bdf {
	case 0:
		return ""
	case 1:
		return "\u0069\u006e\u006c\u0069\u006e\u0065"
	case 2:
		return "\u0074\u006f\u0070"
	case 3:
		return "\u0063\u0065\u006e\u0074\u0065\u0072"
	case 4:
		return "\u0062\u006f\u0074\u0074\u006f\u006d"
	case 5:
		return "\u0069\u006e\u0073\u0069\u0064\u0065"
	case 6:
		return "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return ""
}

func (_bggg ST_AlgType) ValidateWithPath(path string) error {
	switch _bggg {
	case 0, 1, 2:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bggg))
	}
	return nil
}

func (_fbf ST_TrueFalse) Validate() error { return _fbf.ValidateWithPath("") }

const (
	ST_VerticalAlignRunUnset       ST_VerticalAlignRun = 0
	ST_VerticalAlignRunBaseline    ST_VerticalAlignRun = 1
	ST_VerticalAlignRunSuperscript ST_VerticalAlignRun = 2
	ST_VerticalAlignRunSubscript   ST_VerticalAlignRun = 3
)

var ST_GuidPatternRe = _a.MustCompile(ST_GuidPattern)

func (_dga ST_AlgClass) ValidateWithPath(path string) error {
	switch _dga {
	case 0, 1, 2:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dga))
	}
	return nil
}

const ST_PositiveUniversalMeasurePattern = "\u005b\u0030-9\u005d\u002b\u0028\\\u002e\u005b\u0030\u002d9]+\u0029?(\u006d\u006d\u007c\u0063\u006d\u007c\u0069n|\u0070\u0074\u007c\u0070\u0063\u007c\u0070i\u0029"

func (_dae ST_VerticalAlignRun) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dae.String(), start)
}

type ST_TrueFalseBlank byte

func (_acc ST_YAlign) Validate() error { return _acc.ValidateWithPath("") }

func (_gdg ST_OnOff1) ValidateWithPath(path string) error {
	switch _gdg {
	case 0, 1, 2:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_gdg))
	}
	return nil
}

func (_gbc *ST_CryptProv) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aca, _dca := d.Token()
	if _dca != nil {
		return _dca
	}
	if _fe, _ab := _aca.(_g.EndElement); _ab && _fe.Name == start.Name {
		*_gbc = 1
		return nil
	}
	if _db, _daa := _aca.(_g.CharData); !_daa {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _aca)
	} else {
		switch string(_db) {
		case "":
			*_gbc = 0
		case "\u0072\u0073\u0061\u0041\u0045\u0053":
			*_gbc = 1
		case "\u0072s\u0061\u0046\u0075\u006c\u006c":
			*_gbc = 2
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_gbc = 3
		}
	}
	_aca, _dca = d.Token()
	if _dca != nil {
		return _dca
	}
	if _geg, _dbe := _aca.(_g.EndElement); _dbe && _geg.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _aca)
}

const (
	ST_OnOff1Unset ST_OnOff1 = 0
	ST_OnOff1On    ST_OnOff1 = 1
	ST_OnOff1Off   ST_OnOff1 = 2
)

var ST_PositiveUniversalMeasurePatternRe = _a.MustCompile(ST_PositiveUniversalMeasurePattern)

func (_ca *ST_CalendarType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cf, _cd := d.Token()
	if _cd != nil {
		return _cd
	}
	if _fa, _bb := _cf.(_g.EndElement); _bb && _fa.Name == start.Name {
		*_ca = 1
		return nil
	}
	if _bg, _daf := _cf.(_g.CharData); !_daf {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cf)
	} else {
		switch string(_bg) {
		case "":
			*_ca = 0
		case "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n":
			*_ca = 1
		case "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073":
			*_ca = 2
		case "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068":
			*_ca = 3
		case "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063":
			*_ca = 4
		case "\u0068\u0069\u006ar\u0069":
			*_ca = 5
		case "\u0068\u0065\u0062\u0072\u0065\u0077":
			*_ca = 6
		case "\u0074\u0061\u0069\u0077\u0061\u006e":
			*_ca = 7
		case "\u006a\u0061\u0070a\u006e":
			*_ca = 8
		case "\u0074\u0068\u0061\u0069":
			*_ca = 9
		case "\u006b\u006f\u0072e\u0061":
			*_ca = 10
		case "\u0073\u0061\u006b\u0061":
			*_ca = 11
		case "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068":
			*_ca = 12
		case "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068":
			*_ca = 13
		case "\u006e\u006f\u006e\u0065":
			*_ca = 14
		}
	}
	_cf, _cd = d.Token()
	if _cd != nil {
		return _cd
	}
	if _df, _ebe := _cf.(_g.EndElement); _ebe && _df.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cf)
}

func (_dc ST_CalendarType) String() string {
	switch _dc {
	case 0:
		return ""
	case 1:
		return "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n"
	case 2:
		return "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073"
	case 3:
		return "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068"
	case 4:
		return "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063"
	case 5:
		return "\u0068\u0069\u006ar\u0069"
	case 6:
		return "\u0068\u0065\u0062\u0072\u0065\u0077"
	case 7:
		return "\u0074\u0061\u0069\u0077\u0061\u006e"
	case 8:
		return "\u006a\u0061\u0070a\u006e"
	case 9:
		return "\u0074\u0068\u0061\u0069"
	case 10:
		return "\u006b\u006f\u0072e\u0061"
	case 11:
		return "\u0073\u0061\u006b\u0061"
	case 12:
		return "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068"
	case 13:
		return "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068"
	case 14:
		return "\u006e\u006f\u006e\u0065"
	}
	return ""
}

type ST_AlgClass byte

func (_de ST_CalendarType) ValidateWithPath(path string) error {
	switch _de {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_de))
	}
	return nil
}

func (_egd *ST_XAlign) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_egd = 0
	case "\u006c\u0065\u0066\u0074":
		*_egd = 1
	case "\u0063\u0065\u006e\u0074\u0065\u0072":
		*_egd = 2
	case "\u0072\u0069\u0067h\u0074":
		*_egd = 3
	case "\u0069\u006e\u0073\u0069\u0064\u0065":
		*_egd = 4
	case "\u006fu\u0074\u0073\u0069\u0064\u0065":
		*_egd = 5
	}
	return nil
}

func (_fgg ST_VerticalAlignRun) String() string {
	switch _fgg {
	case 0:
		return ""
	case 1:
		return "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065"
	case 2:
		return "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074"
	case 3:
		return "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t"
	}
	return ""
}

func (_bcg *ST_XAlign) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_agc, _fcc := d.Token()
	if _fcc != nil {
		return _fcc
	}
	if _cff, _cbe := _agc.(_g.EndElement); _cbe && _cff.Name == start.Name {
		*_bcg = 1
		return nil
	}
	if _bgd, _cdd := _agc.(_g.CharData); !_cdd {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _agc)
	} else {
		switch string(_bgd) {
		case "":
			*_bcg = 0
		case "\u006c\u0065\u0066\u0074":
			*_bcg = 1
		case "\u0063\u0065\u006e\u0074\u0065\u0072":
			*_bcg = 2
		case "\u0072\u0069\u0067h\u0074":
			*_bcg = 3
		case "\u0069\u006e\u0073\u0069\u0064\u0065":
			*_bcg = 4
		case "\u006fu\u0074\u0073\u0069\u0064\u0065":
			*_bcg = 5
		}
	}
	_agc, _fcc = d.Token()
	if _fcc != nil {
		return _fcc
	}
	if _fde, _cbb := _agc.(_g.EndElement); _cbb && _fde.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _agc)
}

func (_ee ST_AlgClass) Validate() error { return _ee.ValidateWithPath("") }

const (
	ST_TrueFalseUnset ST_TrueFalse = 0
	ST_TrueFalseT     ST_TrueFalse = 1
	ST_TrueFalseF     ST_TrueFalse = 2
	ST_TrueFalseTrue  ST_TrueFalse = 3
	ST_TrueFalseFalse ST_TrueFalse = 4
)

func (_adad ST_ConformanceClass) String() string {
	switch _adad {
	case 0:
		return ""
	case 1:
		return "\u0073\u0074\u0072\u0069\u0063\u0074"
	case 2:
		return "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c"
	}
	return ""
}

type ST_XAlign byte

func (_beg ST_YAlign) ValidateWithPath(path string) error {
	switch _beg {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_beg))
	}
	return nil
}

// ST_TwipsMeasure is a union type
type ST_TwipsMeasure struct {
	ST_UnsignedDecimalNumber    *uint64
	ST_PositiveUniversalMeasure *string
}

func (_gab ST_CryptProv) ValidateWithPath(path string) error {
	switch _gab {
	case 0, 1, 2, 3:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_gab))
	}
	return nil
}

const (
	ST_AlgClassUnset  ST_AlgClass = 0
	ST_AlgClassHash   ST_AlgClass = 1
	ST_AlgClassCustom ST_AlgClass = 2
)

func (_d *ST_OnOff) Validate() error { return _d.ValidateWithPath("") }

func (_ff ST_AlgClass) String() string {
	switch _ff {
	case 0:
		return ""
	case 1:
		return "\u0068\u0061\u0073\u0068"
	case 2:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}

func (_ffe ST_VerticalAlignRun) Validate() error { return _ffe.ValidateWithPath("") }

func (_ebaa ST_XAlign) String() string {
	switch _ebaa {
	case 0:
		return ""
	case 1:
		return "\u006c\u0065\u0066\u0074"
	case 2:
		return "\u0063\u0065\u006e\u0074\u0065\u0072"
	case 3:
		return "\u0072\u0069\u0067h\u0074"
	case 4:
		return "\u0069\u006e\u0073\u0069\u0064\u0065"
	case 5:
		return "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return ""
}

func (_aee ST_ConformanceClass) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_aee.String(), start)
}

func (_abf *ST_YAlign) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_abf = 0
	case "\u0069\u006e\u006c\u0069\u006e\u0065":
		*_abf = 1
	case "\u0074\u006f\u0070":
		*_abf = 2
	case "\u0063\u0065\u006e\u0074\u0065\u0072":
		*_abf = 3
	case "\u0062\u006f\u0074\u0074\u006f\u006d":
		*_abf = 4
	case "\u0069\u006e\u0073\u0069\u0064\u0065":
		*_abf = 5
	case "\u006fu\u0074\u0073\u0069\u0064\u0065":
		*_abf = 6
	}
	return nil
}

func (_bc *ST_AlgType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bc = 0
	case "\u0074y\u0070\u0065\u0041\u006e\u0079":
		*_bc = 1
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_bc = 2
	}
	return nil
}

func (_gd ST_OnOff1) Validate() error { return _gd.ValidateWithPath("") }

func (_bae ST_OnOff1) String() string {
	switch _bae {
	case 0:
		return ""
	case 1:
		return "\u006f\u006e"
	case 2:
		return "\u006f\u0066\u0066"
	}
	return ""
}

func _eb(_gbe bool) uint8 {
	if _gbe {
		return 1
	}
	return 0
}

func (_dff ST_TrueFalse) ValidateWithPath(path string) error {
	switch _dff {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dff))
	}
	return nil
}

func (_dd ST_OnOff) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _dd.Bool != nil {
		e.EncodeToken(_g.CharData(_b.Sprintf("\u0025\u0064", _eb(*_dd.Bool))))
	}
	if _dd.ST_OnOff1 != ST_OnOff1Unset {
		e.EncodeToken(_g.CharData(_dd.ST_OnOff1.String()))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

var ST_PercentagePatternRe = _a.MustCompile(ST_PercentagePattern)

func (_dfc ST_ConformanceClass) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gefe := _g.Attr{}
	_gefe.Name = name
	switch _dfc {
	case ST_ConformanceClassUnset:
		_gefe.Value = ""
	case ST_ConformanceClassStrict:
		_gefe.Value = "\u0073\u0074\u0072\u0069\u0063\u0074"
	case ST_ConformanceClassTransitional:
		_gefe.Value = "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c"
	}
	return _gefe, nil
}

var ST_PositivePercentagePatternRe = _a.MustCompile(ST_PositivePercentagePattern)

type ST_CryptProv byte

func (_eea ST_ConformanceClass) Validate() error { return _eea.ValidateWithPath("") }

func (_dda ST_TrueFalseBlank) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dda.String(), start)
}

func (_afc ST_XAlign) ValidateWithPath(path string) error {
	switch _afc {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_afc))
	}
	return nil
}

func (_adgb *ST_YAlign) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gfb, _bee := d.Token()
	if _bee != nil {
		return _bee
	}
	if _cce, _fge := _gfb.(_g.EndElement); _fge && _cce.Name == start.Name {
		*_adgb = 1
		return nil
	}
	if _bda, _ceb := _gfb.(_g.CharData); !_ceb {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gfb)
	} else {
		switch string(_bda) {
		case "":
			*_adgb = 0
		case "\u0069\u006e\u006c\u0069\u006e\u0065":
			*_adgb = 1
		case "\u0074\u006f\u0070":
			*_adgb = 2
		case "\u0063\u0065\u006e\u0074\u0065\u0072":
			*_adgb = 3
		case "\u0062\u006f\u0074\u0074\u006f\u006d":
			*_adgb = 4
		case "\u0069\u006e\u0073\u0069\u0064\u0065":
			*_adgb = 5
		case "\u006fu\u0074\u0073\u0069\u0064\u0065":
			*_adgb = 6
		}
	}
	_gfb, _bee = d.Token()
	if _bee != nil {
		return _bee
	}
	if _gdca, _afd := _gfb.(_g.EndElement); _afd && _gdca.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gfb)
}

func (_fad *ST_OnOff1) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fad = 0
	case "\u006f\u006e":
		*_fad = 1
	case "\u006f\u0066\u0066":
		*_fad = 2
	}
	return nil
}

const (
	ST_CryptProvUnset   ST_CryptProv = 0
	ST_CryptProvRsaAES  ST_CryptProv = 1
	ST_CryptProvRsaFull ST_CryptProv = 2
	ST_CryptProvCustom  ST_CryptProv = 3
)

type ST_YAlign byte

func (_c ST_CalendarType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_c.String(), start)
}

func (_bdfb ST_ConformanceClass) ValidateWithPath(path string) error {
	switch _bdfb {
	case 0, 1, 2:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bdfb))
	}
	return nil
}

func (_baab *ST_ConformanceClass) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_baab = 0
	case "\u0073\u0074\u0072\u0069\u0063\u0074":
		*_baab = 1
	case "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c":
		*_baab = 2
	}
	return nil
}

func ParseUnionST_OnOff(s string) (ST_OnOff, error) {
	_ac := ST_OnOff{}
	switch s {
	case "\u0074\u0072\u0075\u0065", "\u0031", "\u006f\u006e":
		_gb := true
		_ac.Bool = &_gb
	default:
		_ge := false
		_ac.Bool = &_ge
	}
	return _ac, nil
}

const (
	ST_XAlignUnset   ST_XAlign = 0
	ST_XAlignLeft    ST_XAlign = 1
	ST_XAlignCenter  ST_XAlign = 2
	ST_XAlignRight   ST_XAlign = 3
	ST_XAlignInside  ST_XAlign = 4
	ST_XAlignOutside ST_XAlign = 5
)

func (_gdc ST_TrueFalseBlank) String() string {
	switch _gdc {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0066"
	case 3:
		return "\u0074\u0072\u0075\u0065"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	case 6:
		return "\u0054\u0072\u0075\u0065"
	case 7:
		return "\u0046\u0061\u006cs\u0065"
	}
	return ""
}

const (
	ST_ConformanceClassUnset        ST_ConformanceClass = 0
	ST_ConformanceClassStrict       ST_ConformanceClass = 1
	ST_ConformanceClassTransitional ST_ConformanceClass = 2
)

type ST_VerticalAlignRun byte

func (_fab ST_AlgClass) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_cdf := _g.Attr{}
	_cdf.Name = name
	switch _fab {
	case ST_AlgClassUnset:
		_cdf.Value = ""
	case ST_AlgClassHash:
		_cdf.Value = "\u0068\u0061\u0073\u0068"
	case ST_AlgClassCustom:
		_cdf.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _cdf, nil
}

const ST_PositiveFixedPercentagePattern = "\u0028\u0028\u0031\u0030\u0030\u0029\u007c\u0028\u005b\u0030\u002d\u0039\u005d\u005b\u0030\u002d\u0039\u005d\u003f\u0029\u0029\u0028\u005c\u002e[\u0030\u002d\u0039\u005d\u005b0\u002d\u0039]\u003f\u0029\u003f\u0025"

func (_gf ST_CryptProv) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gc := _g.Attr{}
	_gc.Name = name
	switch _gf {
	case ST_CryptProvUnset:
		_gc.Value = ""
	case ST_CryptProvRsaAES:
		_gc.Value = "\u0072\u0073\u0061\u0041\u0045\u0053"
	case ST_CryptProvRsaFull:
		_gc.Value = "\u0072s\u0061\u0046\u0075\u006c\u006c"
	case ST_CryptProvCustom:
		_gc.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _gc, nil
}

func (_ed *ST_AlgClass) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_ed = 0
	case "\u0068\u0061\u0073\u0068":
		*_ed = 1
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_ed = 2
	}
	return nil
}

func (_dg ST_TwipsMeasure) String() string {
	if _dg.ST_UnsignedDecimalNumber != nil {
		return _b.Sprintf("\u0025\u0076", *_dg.ST_UnsignedDecimalNumber)
	}
	if _dg.ST_PositiveUniversalMeasure != nil {
		return _b.Sprintf("\u0025\u0076", *_dg.ST_PositiveUniversalMeasure)
	}
	return ""
}

func (_gfa ST_XAlign) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gfa.String(), start)
}

type ST_TrueFalse byte

func (_cef ST_TrueFalse) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cef.String(), start)
}

func (_dagd *ST_TrueFalseBlank) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_af, _dbf := d.Token()
	if _dbf != nil {
		return _dbf
	}
	if _acb, _bfb := _af.(_g.EndElement); _bfb && _acb.Name == start.Name {
		*_dagd = 1
		return nil
	}
	if _fc, _cfe := _af.(_g.CharData); !_cfe {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _af)
	} else {
		switch string(_fc) {
		case "":
			*_dagd = 0
		case "\u0074":
			*_dagd = 1
		case "\u0066":
			*_dagd = 2
		case "\u0074\u0072\u0075\u0065":
			*_dagd = 3
		case "\u0066\u0061\u006cs\u0065":
			*_dagd = 4
		case "\u0054\u0072\u0075\u0065":
			*_dagd = 6
		case "\u0046\u0061\u006cs\u0065":
			*_dagd = 7
		}
	}
	_af, _dbf = d.Token()
	if _dbf != nil {
		return _dbf
	}
	if _cea, _bea := _af.(_g.EndElement); _bea && _cea.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _af)
}

type ST_OnOff1 byte

func (_da *ST_TwipsMeasure) ValidateWithPath(path string) error {
	_eg := []string{}
	if _da.ST_UnsignedDecimalNumber != nil {
		_eg = append(_eg, "\u0053T\u005f\u0055\u006e\u0073\u0069\u0067\u006e\u0065\u0064\u0044\u0065c\u0069\u006d\u0061\u006c\u004e\u0075\u006d\u0062\u0065\u0072")
	}
	if _da.ST_PositiveUniversalMeasure != nil {
		_eg = append(_eg, "S\u0054\u005f\u0050\u006f\u0073\u0069t\u0069\u0076\u0065\u0055\u006e\u0069\u0076\u0065\u0072s\u0061\u006c\u004de\u0061s\u0075\u0072\u0065")
	}
	if len(_eg) > 1 {
		return _b.Errorf("%\u0073\u0020\u0074\u006f\u006f\u0020m\u0061\u006e\u0079\u0020\u006d\u0065\u006d\u0062\u0065r\u0073\u0020\u0073e\u0074:\u0020\u0025\u0076", path, _eg)
	}
	return nil
}

func (_gegf ST_VerticalAlignRun) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_cbd := _g.Attr{}
	_cbd.Name = name
	switch _gegf {
	case ST_VerticalAlignRunUnset:
		_cbd.Value = ""
	case ST_VerticalAlignRunBaseline:
		_cbd.Value = "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065"
	case ST_VerticalAlignRunSuperscript:
		_cbd.Value = "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074"
	case ST_VerticalAlignRunSubscript:
		_cbd.Value = "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t"
	}
	return _cbd, nil
}

var ST_FixedPercentagePatternRe = _a.MustCompile(ST_FixedPercentagePattern)

var ST_UniversalMeasurePatternRe = _a.MustCompile(ST_UniversalMeasurePattern)

func (_cg ST_AlgClass) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cg.String(), start)
}

func (_dagb ST_TrueFalseBlank) ValidateWithPath(path string) error {
	switch _dagb {
	case 0, 1, 2, 3, 4, 6, 7:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dagb))
	}
	return nil
}

func (_ged ST_AlgType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ged.String(), start)
}

func (_ddf ST_YAlign) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fed := _g.Attr{}
	_fed.Name = name
	switch _ddf {
	case ST_YAlignUnset:
		_fed.Value = ""
	case ST_YAlignInline:
		_fed.Value = "\u0069\u006e\u006c\u0069\u006e\u0065"
	case ST_YAlignTop:
		_fed.Value = "\u0074\u006f\u0070"
	case ST_YAlignCenter:
		_fed.Value = "\u0063\u0065\u006e\u0074\u0065\u0072"
	case ST_YAlignBottom:
		_fed.Value = "\u0062\u006f\u0074\u0074\u006f\u006d"
	case ST_YAlignInside:
		_fed.Value = "\u0069\u006e\u0073\u0069\u0064\u0065"
	case ST_YAlignOutside:
		_fed.Value = "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return _fed, nil
}

const ST_UniversalMeasurePattern = "\u002d\u003f\u005b\u0030\u002d\u0039\u005d\u002b\u0028\u005c\u002e\u005b\u0030\u002d\u0039\u005d\u002b\u0029\u003f\u0028\u006d\u006d\u007c\u0063m\u007c\u0069\u006e\u007c\u0070t\u007c\u0070c\u007c\u0070\u0069\u0029"

func (_fbc *ST_VerticalAlignRun) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fbc = 0
	case "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":
		*_fbc = 1
	case "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074":
		*_fbc = 2
	case "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t":
		*_fbc = 3
	}
	return nil
}

func (_def *ST_TrueFalse) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_egg, _gba := d.Token()
	if _gba != nil {
		return _gba
	}
	if _gdf, _dge := _egg.(_g.EndElement); _dge && _gdf.Name == start.Name {
		*_def = 1
		return nil
	}
	if _gcf, _dafa := _egg.(_g.CharData); !_dafa {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _egg)
	} else {
		switch string(_gcf) {
		case "":
			*_def = 0
		case "\u0074":
			*_def = 1
		case "\u0066":
			*_def = 2
		case "\u0074\u0072\u0075\u0065":
			*_def = 3
		case "\u0066\u0061\u006cs\u0065":
			*_def = 4
		}
	}
	_egg, _gba = d.Token()
	if _gba != nil {
		return _gba
	}
	if _fdfb, _eae := _egg.(_g.EndElement); _eae && _fdfb.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _egg)
}

func (_bd *ST_TrueFalseBlank) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bd = 0
	case "\u0074":
		*_bd = 1
	case "\u0066":
		*_bd = 2
	case "\u0074\u0072\u0075\u0065":
		*_bd = 3
	case "\u0066\u0061\u006cs\u0065":
		*_bd = 4
	case "\u0054\u0072\u0075\u0065":
		*_bd = 6
	case "\u0046\u0061\u006cs\u0065":
		*_bd = 7
	}
	return nil
}

type ST_CalendarType byte

func (_fg ST_TwipsMeasure) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _fg.ST_UnsignedDecimalNumber != nil {
		e.EncodeToken(_g.CharData(_b.Sprintf("\u0025\u0064", *_fg.ST_UnsignedDecimalNumber)))
	}
	if _fg.ST_PositiveUniversalMeasure != nil {
		e.EncodeToken(_g.CharData(*_fg.ST_PositiveUniversalMeasure))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

const ST_FixedPercentagePattern = "-\u003f\u0028\u0028\u0031\u0030\u0030\u0029\u007c\u0028\u005b\u0030\u002d\u0039\u005d\u005b\u0030\u002d\u0039]\u003f\u0029\u0029\u0028\u005c\u002e\u005b\u0030\u002d\u0039][\u0030\u002d\u0039]\u003f)\u003f\u0025"

func (_baa ST_VerticalAlignRun) ValidateWithPath(path string) error {
	switch _baa {
	case 0, 1, 2, 3:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_baa))
	}
	return nil
}

func (_ag *ST_TwipsMeasure) Validate() error { return _ag.ValidateWithPath("") }

func (_gbg *ST_AlgType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gce, _ecb := d.Token()
	if _ecb != nil {
		return _ecb
	}
	if _aba, _ccd := _gce.(_g.EndElement); _ccd && _aba.Name == start.Name {
		*_gbg = 1
		return nil
	}
	if _ba, _cee := _gce.(_g.CharData); !_cee {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gce)
	} else {
		switch string(_ba) {
		case "":
			*_gbg = 0
		case "\u0074y\u0070\u0065\u0041\u006e\u0079":
			*_gbg = 1
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_gbg = 2
		}
	}
	_gce, _ecb = d.Token()
	if _ecb != nil {
		return _ecb
	}
	if _bca, _ada := _gce.(_g.EndElement); _ada && _bca.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gce)
}
