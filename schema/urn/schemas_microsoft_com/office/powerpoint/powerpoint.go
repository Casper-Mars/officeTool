//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package powerpoint

import (
	_d "encoding/xml"
	_g "fmt"
	_df "github.com/unidoc/unioffice"
)

// ValidateWithPath validates the Textdata and its children, prefixing error messages with path
func (_cec *Textdata) ValidateWithPath(path string) error {
	if _dab := _cec.CT_Rel.ValidateWithPath(path); _dab != nil {
		return _dab
	}
	return nil
}

func NewCT_Rel() *CT_Rel { _ab := &CT_Rel{}; return _ab }

func (_ca *CT_Empty) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for {
		_b, _ce := d.Token()
		if _ce != nil {
			return _g.Errorf("p\u0061r\u0073\u0069\u006e\u0067\u0020\u0043\u0054\u005fE\u006d\u0070\u0074\u0079: \u0025\u0073", _ce)
		}
		if _a, _dc := _b.(_d.EndElement); _dc && _a.Name == start.Name {
			break
		}
	}
	return nil
}

func (_fcb *Textdata) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072\u006e\u003a\u0073\u0063\u0068e\u006d\u0061\u0073-\u006d\u0069\u0063\u0072o\u0073\u006f\u0066\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065\u003a\u0070\u006f\u0077\u0065\u0072\u0070\u006f\u0069\u006e\u0074"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0074\u0065\u0078\u0074\u0064\u0061\u0074\u0061"
	return _fcb.CT_Rel.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_Rel and its children, prefixing error messages with path
func (_fcd *CT_Rel) ValidateWithPath(path string) error { return nil }

func NewTextdata() *Textdata { _gff := &Textdata{}; _gff.CT_Rel = *NewCT_Rel(); return _gff }

func NewCT_Empty() *CT_Empty { _c := &CT_Empty{}; return _c }

func (_gf *CT_Empty) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

func NewIscomment() *Iscomment { _ag := &Iscomment{}; _ag.CT_Empty = *NewCT_Empty(); return _ag }

// Validate validates the CT_Empty and its children
func (_e *CT_Empty) Validate() error {
	return _e.ValidateWithPath("\u0043\u0054\u005f\u0045\u006d\u0070\u0074\u0079")
}

func (_cf *Iscomment) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072\u006e\u003a\u0073\u0063\u0068e\u006d\u0061\u0073-\u006d\u0069\u0063\u0072o\u0073\u006f\u0066\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065\u003a\u0070\u006f\u0077\u0065\u0072\u0070\u006f\u0069\u006e\u0074"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0069s\u0063\u006f\u006d\u006d\u0065\u006et"
	return _cf.CT_Empty.MarshalXML(e, start)
}

// Validate validates the Iscomment and its children
func (_dfd *Iscomment) Validate() error {
	return _dfd.ValidateWithPath("\u0049s\u0063\u006f\u006d\u006d\u0065\u006et")
}

// ValidateWithPath validates the CT_Empty and its children, prefixing error messages with path
func (_gd *CT_Empty) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_Rel and its children
func (_geb *CT_Rel) Validate() error {
	return _geb.ValidateWithPath("\u0043\u0054\u005f\u0052\u0065\u006c")
}

type Iscomment struct{ CT_Empty }

type CT_Empty struct{}

func (_gfa *Iscomment) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gfa.CT_Empty = *NewCT_Empty()
	for {
		_fd, _fcc := d.Token()
		if _fcc != nil {
			return _g.Errorf("p\u0061\u0072\u0073\u0069ng\u0020I\u0073\u0063\u006f\u006d\u006de\u006e\u0074\u003a\u0020\u0025\u0073", _fcc)
		}
		if _cad, _bb := _fd.(_d.EndElement); _bb && _cad.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Rel struct{ IdAttr *string }

// Validate validates the Textdata and its children
func (_ec *Textdata) Validate() error {
	return _ec.ValidateWithPath("\u0054\u0065\u0078\u0074\u0064\u0061\u0074\u0061")
}

type Textdata struct{ CT_Rel }

func (_ef *Textdata) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ef.CT_Rel = *NewCT_Rel()
	for _, _dd := range start.Attr {
		if _dd.Name.Local == "\u0069\u0064" {
			_ff, _dca := _dd.Value, error(nil)
			if _dca != nil {
				return _dca
			}
			_ef.IdAttr = &_ff
			continue
		}
	}
	for {
		_gb, _dde := d.Token()
		if _dde != nil {
			return _g.Errorf("p\u0061r\u0073\u0069\u006e\u0067\u0020\u0054\u0065\u0078t\u0064\u0061\u0074\u0061: \u0025\u0073", _dde)
		}
		if _gfe, _fb := _gb.(_d.EndElement); _fb && _gfe.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the Iscomment and its children, prefixing error messages with path
func (_bf *Iscomment) ValidateWithPath(path string) error {
	if _eb := _bf.CT_Empty.ValidateWithPath(path); _eb != nil {
		return _eb
	}
	return nil
}

func (_da *CT_Rel) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _da.IdAttr != nil {
		start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0069\u0064"}, Value: _g.Sprintf("\u0025\u0076", *_da.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

func (_ge *CT_Rel) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _aba := range start.Attr {
		if _aba.Name.Local == "\u0069\u0064" {
			_ea, _ga := _aba.Value, error(nil)
			if _ga != nil {
				return _ga
			}
			_ge.IdAttr = &_ea
			continue
		}
	}
	for {
		_abb, _abc := d.Token()
		if _abc != nil {
			return _g.Errorf("\u0070a\u0072s\u0069\u006e\u0067\u0020\u0043T\u005f\u0052e\u006c\u003a\u0020\u0025\u0073", _abc)
		}
		if _af, _fc := _abb.(_d.EndElement); _fc && _af.Name == start.Name {
			break
		}
	}
	return nil
}

func init() {
	_df.RegisterConstructor("\u0075\u0072\u006e\u003a\u0073\u0063\u0068e\u006d\u0061\u0073-\u006d\u0069\u0063\u0072o\u0073\u006f\u0066\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065\u003a\u0070\u006f\u0077\u0065\u0072\u0070\u006f\u0069\u006e\u0074", "\u0043\u0054\u005f\u0045\u006d\u0070\u0074\u0079", NewCT_Empty)
	_df.RegisterConstructor("\u0075\u0072\u006e\u003a\u0073\u0063\u0068e\u006d\u0061\u0073-\u006d\u0069\u0063\u0072o\u0073\u006f\u0066\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065\u003a\u0070\u006f\u0077\u0065\u0072\u0070\u006f\u0069\u006e\u0074", "\u0043\u0054\u005f\u0052\u0065\u006c", NewCT_Rel)
	_df.RegisterConstructor("\u0075\u0072\u006e\u003a\u0073\u0063\u0068e\u006d\u0061\u0073-\u006d\u0069\u0063\u0072o\u0073\u006f\u0066\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065\u003a\u0070\u006f\u0077\u0065\u0072\u0070\u006f\u0069\u006e\u0074", "\u0069s\u0063\u006f\u006d\u006d\u0065\u006et", NewIscomment)
	_df.RegisterConstructor("\u0075\u0072\u006e\u003a\u0073\u0063\u0068e\u006d\u0061\u0073-\u006d\u0069\u0063\u0072o\u0073\u006f\u0066\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065\u003a\u0070\u006f\u0077\u0065\u0072\u0070\u006f\u0069\u006e\u0074", "\u0074\u0065\u0078\u0074\u0064\u0061\u0074\u0061", NewTextdata)
}
