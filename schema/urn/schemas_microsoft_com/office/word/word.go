//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package word

import (
	_a "encoding/xml"
	_d "fmt"
	_e "github.com/Casper-Mars/officeTool"
	_cf "strconv"
)

type ST_WrapSide byte

func (_da *Borderbottom) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_da.CT_Border = *NewCT_Border()
	for _, _ac := range start.Attr {
		if _ac.Name.Local == "\u0074\u0079\u0070\u0065" {
			_da.TypeAttr.UnmarshalXMLAttr(_ac)
			continue
		}
		if _ac.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_ee, _dac := _cf.ParseUint(_ac.Value, 10, 32)
			if _dac != nil {
				return _dac
			}
			_ca := uint32(_ee)
			_da.WidthAttr = &_ca
			continue
		}
		if _ac.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_da.ShadowAttr.UnmarshalXMLAttr(_ac)
			continue
		}
	}
	for {
		_eaa, _dc := d.Token()
		if _dc != nil {
			return _d.Errorf("\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0042\u006f\u0072\u0064\u0065r\u0062\u006f\u0074\u0074\u006f\u006d\u003a\u0020\u0025\u0073", _dc)
		}
		if _ff, _fe := _eaa.(_a.EndElement); _fe && _ff.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the Borderright and its children, prefixing error messages with path
func (_gb *Borderright) ValidateWithPath(path string) error {
	if _cbd := _gb.CT_Border.ValidateWithPath(path); _cbd != nil {
		return _cbd
	}
	return nil
}

func (_gaag ST_HorizontalAnchor) MarshalXMLAttr(name _a.Name) (_a.Attr, error) {
	_cfa := _a.Attr{}
	_cfa.Name = name
	switch _gaag {
	case ST_HorizontalAnchorUnset:
		_cfa.Value = ""
	case ST_HorizontalAnchorMargin:
		_cfa.Value = "\u006d\u0061\u0072\u0067\u0069\u006e"
	case ST_HorizontalAnchorPage:
		_cfa.Value = "\u0070\u0061\u0067\u0065"
	case ST_HorizontalAnchorText:
		_cfa.Value = "\u0074\u0065\u0078\u0074"
	case ST_HorizontalAnchorChar:
		_cfa.Value = "\u0063\u0068\u0061\u0072"
	}
	return _cfa, nil
}

func (_bfb ST_BorderType) ValidateWithPath(path string) error {
	switch _bfb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bfb))
	}
	return nil
}

func (_ffg *ST_HorizontalAnchor) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_gdf, _fggc := d.Token()
	if _fggc != nil {
		return _fggc
	}
	if _gae, _baf := _gdf.(_a.EndElement); _baf && _gae.Name == start.Name {
		*_ffg = 1
		return nil
	}
	if _cae, _cac := _gdf.(_a.CharData); !_cac {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gdf)
	} else {
		switch string(_cae) {
		case "":
			*_ffg = 0
		case "\u006d\u0061\u0072\u0067\u0069\u006e":
			*_ffg = 1
		case "\u0070\u0061\u0067\u0065":
			*_ffg = 2
		case "\u0074\u0065\u0078\u0074":
			*_ffg = 3
		case "\u0063\u0068\u0061\u0072":
			*_ffg = 4
		}
	}
	_gdf, _fggc = d.Token()
	if _fggc != nil {
		return _fggc
	}
	if _faf, _cbe := _gdf.(_a.EndElement); _cbe && _faf.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gdf)
}

func (_bbb ST_VerticalAnchor) ValidateWithPath(path string) error {
	switch _bbb {
	case 0, 1, 2, 3, 4:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bbb))
	}
	return nil
}

// Validate validates the Anchorlock and its children
func (_ge *Anchorlock) Validate() error {
	return _ge.ValidateWithPath("\u0041\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b")
}

// ValidateWithPath validates the Wrap and its children, prefixing error messages with path
func (_cbdd *Wrap) ValidateWithPath(path string) error {
	if _aga := _cbdd.CT_Wrap.ValidateWithPath(path); _aga != nil {
		return _aga
	}
	return nil
}

func (_eeg *Borderleft) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074"
	return _eeg.CT_Border.MarshalXML(e, start)
}

func (_cfb *ST_VerticalAnchor) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_bga, _bdg := d.Token()
	if _bdg != nil {
		return _bdg
	}
	if _caa, _bcba := _bga.(_a.EndElement); _bcba && _caa.Name == start.Name {
		*_cfb = 1
		return nil
	}
	if _bag, _afbf := _bga.(_a.CharData); !_afbf {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bga)
	} else {
		switch string(_bag) {
		case "":
			*_cfb = 0
		case "\u006d\u0061\u0072\u0067\u0069\u006e":
			*_cfb = 1
		case "\u0070\u0061\u0067\u0065":
			*_cfb = 2
		case "\u0074\u0065\u0078\u0074":
			*_cfb = 3
		case "\u006c\u0069\u006e\u0065":
			*_cfb = 4
		}
	}
	_bga, _bdg = d.Token()
	if _bdg != nil {
		return _bdg
	}
	if _dacf, _ccdd := _bga.(_a.EndElement); _ccdd && _dacf.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bga)
}

// ValidateWithPath validates the Borderleft and its children, prefixing error messages with path
func (_caf *Borderleft) ValidateWithPath(path string) error {
	if _be := _caf.CT_Border.ValidateWithPath(path); _be != nil {
		return _be
	}
	return nil
}

func (_dd *Bordertop) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_dd.CT_Border = *NewCT_Border()
	for _, _edf := range start.Attr {
		if _edf.Name.Local == "\u0074\u0079\u0070\u0065" {
			_dd.TypeAttr.UnmarshalXMLAttr(_edf)
			continue
		}
		if _edf.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_bcd, _gge := _cf.ParseUint(_edf.Value, 10, 32)
			if _gge != nil {
				return _gge
			}
			_ccc := uint32(_bcd)
			_dd.WidthAttr = &_ccc
			continue
		}
		if _edf.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_dd.ShadowAttr.UnmarshalXMLAttr(_edf)
			continue
		}
	}
	for {
		_gaa, _deg := d.Token()
		if _deg != nil {
			return _d.Errorf("p\u0061\u0072\u0073\u0069ng\u0020B\u006f\u0072\u0064\u0065\u0072t\u006f\u0070\u003a\u0020\u0025\u0073", _deg)
		}
		if _cdg, _aa := _gaa.(_a.EndElement); _aa && _cdg.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Wrap struct {
	TypeAttr    ST_WrapType
	SideAttr    ST_WrapSide
	AnchorxAttr ST_HorizontalAnchor
	AnchoryAttr ST_VerticalAnchor
}

func (_cg *CT_Border) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	for _, _dgc := range start.Attr {
		if _dgc.Name.Local == "\u0074\u0079\u0070\u0065" {
			_cg.TypeAttr.UnmarshalXMLAttr(_dgc)
			continue
		}
		if _dgc.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_eg, _fff := _cf.ParseUint(_dgc.Value, 10, 32)
			if _fff != nil {
				return _fff
			}
			_add := uint32(_eg)
			_cg.WidthAttr = &_add
			continue
		}
		if _dgc.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_cg.ShadowAttr.UnmarshalXMLAttr(_dgc)
			continue
		}
	}
	for {
		_bgg, _feg := d.Token()
		if _feg != nil {
			return _d.Errorf("p\u0061\u0072\u0073\u0069ng\u0020C\u0054\u005f\u0042\u006f\u0072d\u0065\u0072\u003a\u0020\u0025\u0073", _feg)
		}
		if _cdf, _dcg := _bgg.(_a.EndElement); _dcg && _cdf.Name == start.Name {
			break
		}
	}
	return nil
}

type Borderright struct{ CT_Border }

func (_efgg ST_VerticalAnchor) MarshalXMLAttr(name _a.Name) (_a.Attr, error) {
	_geb := _a.Attr{}
	_geb.Name = name
	switch _efgg {
	case ST_VerticalAnchorUnset:
		_geb.Value = ""
	case ST_VerticalAnchorMargin:
		_geb.Value = "\u006d\u0061\u0072\u0067\u0069\u006e"
	case ST_VerticalAnchorPage:
		_geb.Value = "\u0070\u0061\u0067\u0065"
	case ST_VerticalAnchorText:
		_geb.Value = "\u0074\u0065\u0078\u0074"
	case ST_VerticalAnchorLine:
		_geb.Value = "\u006c\u0069\u006e\u0065"
	}
	return _geb, nil
}

func (_bcg *ST_WrapSide) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_ggec, _dcda := d.Token()
	if _dcda != nil {
		return _dcda
	}
	if _dgd, _dag := _ggec.(_a.EndElement); _dag && _dgd.Name == start.Name {
		*_bcg = 1
		return nil
	}
	if _edb, _fdf := _ggec.(_a.CharData); !_fdf {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _ggec)
	} else {
		switch string(_edb) {
		case "":
			*_bcg = 0
		case "\u0062\u006f\u0074\u0068":
			*_bcg = 1
		case "\u006c\u0065\u0066\u0074":
			*_bcg = 2
		case "\u0072\u0069\u0067h\u0074":
			*_bcg = 3
		case "\u006ca\u0072\u0067\u0065\u0073\u0074":
			*_bcg = 4
		}
	}
	_ggec, _dcda = d.Token()
	if _dcda != nil {
		return _dcda
	}
	if _dfda, _fdbd := _ggec.(_a.EndElement); _fdbd && _dfda.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _ggec)
}

func (_edca *ST_WrapSide) UnmarshalXMLAttr(attr _a.Attr) error {
	switch attr.Value {
	case "":
		*_edca = 0
	case "\u0062\u006f\u0074\u0068":
		*_edca = 1
	case "\u006c\u0065\u0066\u0074":
		*_edca = 2
	case "\u0072\u0069\u0067h\u0074":
		*_edca = 3
	case "\u006ca\u0072\u0067\u0065\u0073\u0074":
		*_edca = 4
	}
	return nil
}

func (_fgd ST_WrapType) ValidateWithPath(path string) error {
	switch _fgd {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_fgd))
	}
	return nil
}

func (_fb *Wrap) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0077\u0072\u0061\u0070"
	return _fb.CT_Wrap.MarshalXML(e, start)
}

func (_ddf ST_BorderType) String() string {
	switch _ddf {
	case 0:
		return ""
	case 1:
		return "\u006e\u006f\u006e\u0065"
	case 2:
		return "\u0073\u0069\u006e\u0067\u006c\u0065"
	case 3:
		return "\u0074\u0068\u0069c\u006b"
	case 4:
		return "\u0064\u006f\u0075\u0062\u006c\u0065"
	case 5:
		return "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065"
	case 6:
		return "\u0064\u006f\u0074"
	case 7:
		return "\u0064\u0061\u0073\u0068"
	case 8:
		return "\u0064o\u0074\u0044\u0061\u0073\u0068"
	case 9:
		return "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074"
	case 10:
		return "\u0074\u0072\u0069\u0070\u006c\u0065"
	case 11:
		return "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c"
	case 12:
		return "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c"
	case 13:
		return "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c"
	case 14:
		return "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k"
	case 15:
		return "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n"
	case 16:
		return "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e"
	case 17:
		return "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065"
	case 18:
		return "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065"
	case 19:
		return "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065"
	case 20:
		return "\u0077\u0061\u0076\u0065"
	case 21:
		return "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065"
	case 22:
		return "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c"
	case 23:
		return "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064"
	case 24:
		return "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073"
	case 25:
		return "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065"
	case 26:
		return "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074"
	case 27:
		return "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t"
	}
	return ""
}

// Validate validates the CT_Wrap and its children
func (_ecg *CT_Wrap) Validate() error {
	return _ecg.ValidateWithPath("\u0043T\u005f\u0057\u0072\u0061\u0070")
}

const (
	ST_WrapTypeUnset        ST_WrapType = 0
	ST_WrapTypeTopAndBottom ST_WrapType = 1
	ST_WrapTypeSquare       ST_WrapType = 2
	ST_WrapTypeNone         ST_WrapType = 3
	ST_WrapTypeTight        ST_WrapType = 4
	ST_WrapTypeThrough      ST_WrapType = 5
)

// ValidateWithPath validates the Anchorlock and its children, prefixing error messages with path
func (_gg *Anchorlock) ValidateWithPath(path string) error {
	if _ae := _gg.CT_AnchorLock.ValidateWithPath(path); _ae != nil {
		return _ae
	}
	return nil
}

type ST_WrapType byte

// ValidateWithPath validates the CT_Border and its children, prefixing error messages with path
func (_ceg *CT_Border) ValidateWithPath(path string) error {
	if _cba := _ceg.TypeAttr.ValidateWithPath(path + "\u002fT\u0079\u0070\u0065\u0041\u0074\u0074r"); _cba != nil {
		return _cba
	}
	if _fdb := _ceg.ShadowAttr.ValidateWithPath(path + "/\u0053\u0068\u0061\u0064\u006f\u0077\u0041\u0074\u0074\u0072"); _fdb != nil {
		return _fdb
	}
	return nil
}

func (_ggdb ST_WrapSide) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	return e.EncodeElement(_ggdb.String(), start)
}

func (_ggb *ST_VerticalAnchor) UnmarshalXMLAttr(attr _a.Attr) error {
	switch attr.Value {
	case "":
		*_ggb = 0
	case "\u006d\u0061\u0072\u0067\u0069\u006e":
		*_ggb = 1
	case "\u0070\u0061\u0067\u0065":
		*_ggb = 2
	case "\u0074\u0065\u0078\u0074":
		*_ggb = 3
	case "\u006c\u0069\u006e\u0065":
		*_ggb = 4
	}
	return nil
}

func (_fce *ST_BorderType) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_ef, _bd := d.Token()
	if _bd != nil {
		return _bd
	}
	if _efg, _dfaa := _ef.(_a.EndElement); _dfaa && _efg.Name == start.Name {
		*_fce = 1
		return nil
	}
	if _gafa, _abf := _ef.(_a.CharData); !_abf {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _ef)
	} else {
		switch string(_gafa) {
		case "":
			*_fce = 0
		case "\u006e\u006f\u006e\u0065":
			*_fce = 1
		case "\u0073\u0069\u006e\u0067\u006c\u0065":
			*_fce = 2
		case "\u0074\u0068\u0069c\u006b":
			*_fce = 3
		case "\u0064\u006f\u0075\u0062\u006c\u0065":
			*_fce = 4
		case "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065":
			*_fce = 5
		case "\u0064\u006f\u0074":
			*_fce = 6
		case "\u0064\u0061\u0073\u0068":
			*_fce = 7
		case "\u0064o\u0074\u0044\u0061\u0073\u0068":
			*_fce = 8
		case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074":
			*_fce = 9
		case "\u0074\u0072\u0069\u0070\u006c\u0065":
			*_fce = 10
		case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c":
			*_fce = 11
		case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c":
			*_fce = 12
		case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c":
			*_fce = 13
		case "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k":
			*_fce = 14
		case "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n":
			*_fce = 15
		case "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e":
			*_fce = 16
		case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065":
			*_fce = 17
		case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065":
			*_fce = 18
		case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065":
			*_fce = 19
		case "\u0077\u0061\u0076\u0065":
			*_fce = 20
		case "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065":
			*_fce = 21
		case "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c":
			*_fce = 22
		case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064":
			*_fce = 23
		case "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073":
			*_fce = 24
		case "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065":
			*_fce = 25
		case "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074":
			*_fce = 26
		case "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t":
			*_fce = 27
		}
	}
	_ef, _bd = d.Token()
	if _bd != nil {
		return _bd
	}
	if _accd, _aad := _ef.(_a.EndElement); _aad && _accd.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _ef)
}

type ST_BorderShadow byte

// Validate validates the Bordertop and its children
func (_fae *Bordertop) Validate() error {
	return _fae.ValidateWithPath("\u0042o\u0072\u0064\u0065\u0072\u0074\u006fp")
}

func (_bbd ST_BorderType) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	return e.EncodeElement(_bbd.String(), start)
}

func (_ggd ST_BorderShadow) ValidateWithPath(path string) error {
	switch _ggd {
	case 0, 1, 2, 3, 4:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ggd))
	}
	return nil
}

func (_eeed *ST_WrapType) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_dbg, _dfb := d.Token()
	if _dfb != nil {
		return _dfb
	}
	if _edd, _acf := _dbg.(_a.EndElement); _acf && _edd.Name == start.Name {
		*_eeed = 1
		return nil
	}
	if _cbaa, _ege := _dbg.(_a.CharData); !_ege {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _dbg)
	} else {
		switch string(_cbaa) {
		case "":
			*_eeed = 0
		case "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d":
			*_eeed = 1
		case "\u0073\u0071\u0075\u0061\u0072\u0065":
			*_eeed = 2
		case "\u006e\u006f\u006e\u0065":
			*_eeed = 3
		case "\u0074\u0069\u0067h\u0074":
			*_eeed = 4
		case "\u0074h\u0072\u006f\u0075\u0067\u0068":
			*_eeed = 5
		}
	}
	_dbg, _dfb = d.Token()
	if _dfb != nil {
		return _dfb
	}
	if _afb, _gfa := _dbg.(_a.EndElement); _gfa && _afb.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _dbg)
}

// ValidateWithPath validates the Borderbottom and its children, prefixing error messages with path
func (_cc *Borderbottom) ValidateWithPath(path string) error {
	if _fg := _cc.CT_Border.ValidateWithPath(path); _fg != nil {
		return _fg
	}
	return nil
}

func (_cfe *ST_HorizontalAnchor) UnmarshalXMLAttr(attr _a.Attr) error {
	switch attr.Value {
	case "":
		*_cfe = 0
	case "\u006d\u0061\u0072\u0067\u0069\u006e":
		*_cfe = 1
	case "\u0070\u0061\u0067\u0065":
		*_cfe = 2
	case "\u0074\u0065\u0078\u0074":
		*_cfe = 3
	case "\u0063\u0068\u0061\u0072":
		*_cfe = 4
	}
	return nil
}

// ValidateWithPath validates the CT_Wrap and its children, prefixing error messages with path
func (_eee *CT_Wrap) ValidateWithPath(path string) error {
	if _bfc := _eee.TypeAttr.ValidateWithPath(path + "\u002fT\u0079\u0070\u0065\u0041\u0074\u0074r"); _bfc != nil {
		return _bfc
	}
	if _ba := _eee.SideAttr.ValidateWithPath(path + "\u002fS\u0069\u0064\u0065\u0041\u0074\u0074r"); _ba != nil {
		return _ba
	}
	if _cgg := _eee.AnchorxAttr.ValidateWithPath(path + "\u002f\u0041\u006ec\u0068\u006f\u0072\u0078\u0041\u0074\u0074\u0072"); _cgg != nil {
		return _cgg
	}
	if _ebf := _eee.AnchoryAttr.ValidateWithPath(path + "\u002f\u0041\u006ec\u0068\u006f\u0072\u0079\u0041\u0074\u0074\u0072"); _ebf != nil {
		return _ebf
	}
	return nil
}

func (_bc *Borderleft) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_bc.CT_Border = *NewCT_Border()
	for _, _ed := range start.Attr {
		if _ed.Name.Local == "\u0074\u0079\u0070\u0065" {
			_bc.TypeAttr.UnmarshalXMLAttr(_ed)
			continue
		}
		if _ed.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_ebg, _bg := _cf.ParseUint(_ed.Value, 10, 32)
			if _bg != nil {
				return _bg
			}
			_ga := uint32(_ebg)
			_bc.WidthAttr = &_ga
			continue
		}
		if _ed.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_bc.ShadowAttr.UnmarshalXMLAttr(_ed)
			continue
		}
	}
	for {
		_fd, _ced := d.Token()
		if _ced != nil {
			return _d.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0042\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074\u003a\u0020%\u0073", _ced)
		}
		if _bcb, _fc := _fd.(_a.EndElement); _fc && _bcb.Name == start.Name {
			break
		}
	}
	return nil
}

func (_bccd ST_HorizontalAnchor) ValidateWithPath(path string) error {
	switch _bccd {
	case 0, 1, 2, 3, 4:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bccd))
	}
	return nil
}

func (_ade ST_VerticalAnchor) String() string {
	switch _ade {
	case 0:
		return ""
	case 1:
		return "\u006d\u0061\u0072\u0067\u0069\u006e"
	case 2:
		return "\u0070\u0061\u0067\u0065"
	case 3:
		return "\u0074\u0065\u0078\u0074"
	case 4:
		return "\u006c\u0069\u006e\u0065"
	}
	return ""
}

func (_aef *CT_Wrap) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	for _, _degf := range start.Attr {
		if _degf.Name.Local == "\u0074\u0079\u0070\u0065" {
			_aef.TypeAttr.UnmarshalXMLAttr(_degf)
			continue
		}
		if _degf.Name.Local == "\u0073\u0069\u0064\u0065" {
			_aef.SideAttr.UnmarshalXMLAttr(_degf)
			continue
		}
		if _degf.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0078" {
			_aef.AnchorxAttr.UnmarshalXMLAttr(_degf)
			continue
		}
		if _degf.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0079" {
			_aef.AnchoryAttr.UnmarshalXMLAttr(_degf)
			continue
		}
	}
	for {
		_cafe, _cff := d.Token()
		if _cff != nil {
			return _d.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0043\u0054\u005f\u0057\u0072\u0061\u0070\u003a\u0020\u0025\u0073", _cff)
		}
		if _ddd, _cdb := _cafe.(_a.EndElement); _cdb && _ddd.Name == start.Name {
			break
		}
	}
	return nil
}

func (_gfag ST_VerticalAnchor) Validate() error { return _gfag.ValidateWithPath("") }

func (_ea *Anchorlock) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_ea.CT_AnchorLock = *NewCT_AnchorLock()
	for {
		_ad, _g := d.Token()
		if _g != nil {
			return _d.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0041\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b\u003a\u0020%\u0073", _g)
		}
		if _ag, _cb := _ad.(_a.EndElement); _cb && _ag.Name == start.Name {
			break
		}
	}
	return nil
}

func NewWrap() *Wrap { _aff := &Wrap{}; _aff.CT_Wrap = *NewCT_Wrap(); return _aff }

func (_acb *ST_BorderType) UnmarshalXMLAttr(attr _a.Attr) error {
	switch attr.Value {
	case "":
		*_acb = 0
	case "\u006e\u006f\u006e\u0065":
		*_acb = 1
	case "\u0073\u0069\u006e\u0067\u006c\u0065":
		*_acb = 2
	case "\u0074\u0068\u0069c\u006b":
		*_acb = 3
	case "\u0064\u006f\u0075\u0062\u006c\u0065":
		*_acb = 4
	case "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065":
		*_acb = 5
	case "\u0064\u006f\u0074":
		*_acb = 6
	case "\u0064\u0061\u0073\u0068":
		*_acb = 7
	case "\u0064o\u0074\u0044\u0061\u0073\u0068":
		*_acb = 8
	case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074":
		*_acb = 9
	case "\u0074\u0072\u0069\u0070\u006c\u0065":
		*_acb = 10
	case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c":
		*_acb = 11
	case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c":
		*_acb = 12
	case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c":
		*_acb = 13
	case "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k":
		*_acb = 14
	case "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n":
		*_acb = 15
	case "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e":
		*_acb = 16
	case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065":
		*_acb = 17
	case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065":
		*_acb = 18
	case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065":
		*_acb = 19
	case "\u0077\u0061\u0076\u0065":
		*_acb = 20
	case "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065":
		*_acb = 21
	case "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c":
		*_acb = 22
	case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064":
		*_acb = 23
	case "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073":
		*_acb = 24
	case "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065":
		*_acb = 25
	case "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074":
		*_acb = 26
	case "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t":
		*_acb = 27
	}
	return nil
}

type ST_VerticalAnchor byte

func (_baa ST_BorderType) MarshalXMLAttr(name _a.Name) (_a.Attr, error) {
	_fcd := _a.Attr{}
	_fcd.Name = name
	switch _baa {
	case ST_BorderTypeUnset:
		_fcd.Value = ""
	case ST_BorderTypeNone:
		_fcd.Value = "\u006e\u006f\u006e\u0065"
	case ST_BorderTypeSingle:
		_fcd.Value = "\u0073\u0069\u006e\u0067\u006c\u0065"
	case ST_BorderTypeThick:
		_fcd.Value = "\u0074\u0068\u0069c\u006b"
	case ST_BorderTypeDouble:
		_fcd.Value = "\u0064\u006f\u0075\u0062\u006c\u0065"
	case ST_BorderTypeHairline:
		_fcd.Value = "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065"
	case ST_BorderTypeDot:
		_fcd.Value = "\u0064\u006f\u0074"
	case ST_BorderTypeDash:
		_fcd.Value = "\u0064\u0061\u0073\u0068"
	case ST_BorderTypeDotDash:
		_fcd.Value = "\u0064o\u0074\u0044\u0061\u0073\u0068"
	case ST_BorderTypeDashDotDot:
		_fcd.Value = "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074"
	case ST_BorderTypeTriple:
		_fcd.Value = "\u0074\u0072\u0069\u0070\u006c\u0065"
	case ST_BorderTypeThinThickSmall:
		_fcd.Value = "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThickThinSmall:
		_fcd.Value = "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThickBetweenThinSmall:
		_fcd.Value = "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThinThick:
		_fcd.Value = "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k"
	case ST_BorderTypeThickThin:
		_fcd.Value = "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n"
	case ST_BorderTypeThickBetweenThin:
		_fcd.Value = "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e"
	case ST_BorderTypeThinThickLarge:
		_fcd.Value = "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065"
	case ST_BorderTypeThickThinLarge:
		_fcd.Value = "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065"
	case ST_BorderTypeThickBetweenThinLarge:
		_fcd.Value = "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065"
	case ST_BorderTypeWave:
		_fcd.Value = "\u0077\u0061\u0076\u0065"
	case ST_BorderTypeDoubleWave:
		_fcd.Value = "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065"
	case ST_BorderTypeDashedSmall:
		_fcd.Value = "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c"
	case ST_BorderTypeDashDotStroked:
		_fcd.Value = "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064"
	case ST_BorderTypeThreeDEmboss:
		_fcd.Value = "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073"
	case ST_BorderTypeThreeDEngrave:
		_fcd.Value = "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065"
	case ST_BorderTypeHTMLOutset:
		_fcd.Value = "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074"
	case ST_BorderTypeHTMLInset:
		_fcd.Value = "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t"
	}
	return _fcd, nil
}

// Validate validates the CT_Border and its children
func (_egb *CT_Border) Validate() error {
	return _egb.ValidateWithPath("\u0043T\u005f\u0042\u006f\u0072\u0064\u0065r")
}

func (_dg *CT_AnchorLock) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_a.EndElement{Name: start.Name})
	return nil
}

func (_fad *ST_WrapType) UnmarshalXMLAttr(attr _a.Attr) error {
	switch attr.Value {
	case "":
		*_fad = 0
	case "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d":
		*_fad = 1
	case "\u0073\u0071\u0075\u0061\u0072\u0065":
		*_fad = 2
	case "\u006e\u006f\u006e\u0065":
		*_fad = 3
	case "\u0074\u0069\u0067h\u0074":
		*_fad = 4
	case "\u0074h\u0072\u006f\u0075\u0067\u0068":
		*_fad = 5
	}
	return nil
}

func (_dcb *ST_BorderShadow) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_eace, _bge := d.Token()
	if _bge != nil {
		return _bge
	}
	if _aag, _bea := _eace.(_a.EndElement); _bea && _aag.Name == start.Name {
		*_dcb = 1
		return nil
	}
	if _ceb, _bfe := _eace.(_a.CharData); !_bfe {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _eace)
	} else {
		switch string(_ceb) {
		case "":
			*_dcb = 0
		case "\u0074":
			*_dcb = 1
		case "\u0074\u0072\u0075\u0065":
			*_dcb = 2
		case "\u0066":
			*_dcb = 3
		case "\u0066\u0061\u006cs\u0065":
			*_dcb = 4
		}
	}
	_eace, _bge = d.Token()
	if _bge != nil {
		return _bge
	}
	if _agab, _gcd := _eace.(_a.EndElement); _gcd && _agab.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _eace)
}

const (
	ST_VerticalAnchorUnset  ST_VerticalAnchor = 0
	ST_VerticalAnchorMargin ST_VerticalAnchor = 1
	ST_VerticalAnchorPage   ST_VerticalAnchor = 2
	ST_VerticalAnchorText   ST_VerticalAnchor = 3
	ST_VerticalAnchorLine   ST_VerticalAnchor = 4
)

func (_dcdac ST_WrapSide) ValidateWithPath(path string) error {
	switch _dcdac {
	case 0, 1, 2, 3, 4:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dcdac))
	}
	return nil
}

func (_cgb *CT_Wrap) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	if _cgb.TypeAttr != ST_WrapTypeUnset {
		_fgb, _eac := _cgb.TypeAttr.MarshalXMLAttr(_a.Name{Local: "\u0074\u0079\u0070\u0065"})
		if _eac != nil {
			return _eac
		}
		start.Attr = append(start.Attr, _fgb)
	}
	if _cgb.SideAttr != ST_WrapSideUnset {
		_cea, _dfe := _cgb.SideAttr.MarshalXMLAttr(_a.Name{Local: "\u0073\u0069\u0064\u0065"})
		if _dfe != nil {
			return _dfe
		}
		start.Attr = append(start.Attr, _cea)
	}
	if _cgb.AnchorxAttr != ST_HorizontalAnchorUnset {
		_dbaa, _af := _cgb.AnchorxAttr.MarshalXMLAttr(_a.Name{Local: "\u0061n\u0063\u0068\u006f\u0072\u0078"})
		if _af != nil {
			return _af
		}
		start.Attr = append(start.Attr, _dbaa)
	}
	if _cgb.AnchoryAttr != ST_VerticalAnchorUnset {
		_abd, _bb := _cgb.AnchoryAttr.MarshalXMLAttr(_a.Name{Local: "\u0061n\u0063\u0068\u006f\u0072\u0079"})
		if _bb != nil {
			return _bb
		}
		start.Attr = append(start.Attr, _abd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_a.EndElement{Name: start.Name})
	return nil
}

func (_cfff ST_HorizontalAnchor) String() string {
	switch _cfff {
	case 0:
		return ""
	case 1:
		return "\u006d\u0061\u0072\u0067\u0069\u006e"
	case 2:
		return "\u0070\u0061\u0067\u0065"
	case 3:
		return "\u0074\u0065\u0078\u0074"
	case 4:
		return "\u0063\u0068\u0061\u0072"
	}
	return ""
}

// Validate validates the Wrap and its children
func (_gd *Wrap) Validate() error { return _gd.ValidateWithPath("\u0057\u0072\u0061\u0070") }

func NewBordertop() *Bordertop { _bcc := &Bordertop{}; _bcc.CT_Border = *NewCT_Border(); return _bcc }

func (_de *Anchorlock) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0061\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b"
	return _de.CT_AnchorLock.MarshalXML(e, start)
}

func (_bggb *Wrap) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_bggb.CT_Wrap = *NewCT_Wrap()
	for _, _bce := range start.Attr {
		if _bce.Name.Local == "\u0074\u0079\u0070\u0065" {
			_bggb.TypeAttr.UnmarshalXMLAttr(_bce)
			continue
		}
		if _bce.Name.Local == "\u0073\u0069\u0064\u0065" {
			_bggb.SideAttr.UnmarshalXMLAttr(_bce)
			continue
		}
		if _bce.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0078" {
			_bggb.AnchorxAttr.UnmarshalXMLAttr(_bce)
			continue
		}
		if _bce.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0079" {
			_bggb.AnchoryAttr.UnmarshalXMLAttr(_bce)
			continue
		}
	}
	for {
		_dfa, _dfd := d.Token()
		if _dfd != nil {
			return _d.Errorf("\u0070\u0061r\u0073\u0069\u006eg\u0020\u0057\u0072\u0061\u0070\u003a\u0020\u0025\u0073", _dfd)
		}
		if _dgcf, _ggg := _dfa.(_a.EndElement); _ggg && _dgcf.Name == start.Name {
			break
		}
	}
	return nil
}

type Borderbottom struct{ CT_Border }

func (_bgc ST_BorderShadow) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	return e.EncodeElement(_bgc.String(), start)
}

// Validate validates the Borderbottom and its children
func (_bf *Borderbottom) Validate() error {
	return _bf.ValidateWithPath("\u0042\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d")
}

type Borderleft struct{ CT_Border }

func NewBorderleft() *Borderleft {
	_acc := &Borderleft{}
	_acc.CT_Border = *NewCT_Border()
	return _acc
}

func (_dcbb ST_HorizontalAnchor) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	return e.EncodeElement(_dcbb.String(), start)
}

func (_baab ST_BorderShadow) MarshalXMLAttr(name _a.Name) (_a.Attr, error) {
	_aed := _a.Attr{}
	_aed.Name = name
	switch _baab {
	case ST_BorderShadowUnset:
		_aed.Value = ""
	case ST_BorderShadowT:
		_aed.Value = "\u0074"
	case ST_BorderShadowTrue:
		_aed.Value = "\u0074\u0072\u0075\u0065"
	case ST_BorderShadowF:
		_aed.Value = "\u0066"
	case ST_BorderShadowFalse:
		_aed.Value = "\u0066\u0061\u006cs\u0065"
	}
	return _aed, nil
}

type Wrap struct{ CT_Wrap }

func (_dad ST_WrapType) String() string {
	switch _dad {
	case 0:
		return ""
	case 1:
		return "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d"
	case 2:
		return "\u0073\u0071\u0075\u0061\u0072\u0065"
	case 3:
		return "\u006e\u006f\u006e\u0065"
	case 4:
		return "\u0074\u0069\u0067h\u0074"
	case 5:
		return "\u0074h\u0072\u006f\u0075\u0067\u0068"
	}
	return ""
}

// Validate validates the Borderright and its children
func (_ecd *Borderright) Validate() error {
	return _ecd.ValidateWithPath("B\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074")
}

const (
	ST_HorizontalAnchorUnset  ST_HorizontalAnchor = 0
	ST_HorizontalAnchorMargin ST_HorizontalAnchor = 1
	ST_HorizontalAnchorPage   ST_HorizontalAnchor = 2
	ST_HorizontalAnchorText   ST_HorizontalAnchor = 3
	ST_HorizontalAnchorChar   ST_HorizontalAnchor = 4
)

func NewCT_AnchorLock() *CT_AnchorLock { _ace := &CT_AnchorLock{}; return _ace }

func (_fcg ST_WrapType) MarshalXMLAttr(name _a.Name) (_a.Attr, error) {
	_cfg := _a.Attr{}
	_cfg.Name = name
	switch _fcg {
	case ST_WrapTypeUnset:
		_cfg.Value = ""
	case ST_WrapTypeTopAndBottom:
		_cfg.Value = "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d"
	case ST_WrapTypeSquare:
		_cfg.Value = "\u0073\u0071\u0075\u0061\u0072\u0065"
	case ST_WrapTypeNone:
		_cfg.Value = "\u006e\u006f\u006e\u0065"
	case ST_WrapTypeTight:
		_cfg.Value = "\u0074\u0069\u0067h\u0074"
	case ST_WrapTypeThrough:
		_cfg.Value = "\u0074h\u0072\u006f\u0075\u0067\u0068"
	}
	return _cfg, nil
}

func (_aec ST_WrapSide) Validate() error { return _aec.ValidateWithPath("") }

type CT_AnchorLock struct{}

type ST_BorderType byte

func (_ebfb *ST_BorderShadow) UnmarshalXMLAttr(attr _a.Attr) error {
	switch attr.Value {
	case "":
		*_ebfb = 0
	case "\u0074":
		*_ebfb = 1
	case "\u0074\u0072\u0075\u0065":
		*_ebfb = 2
	case "\u0066":
		*_ebfb = 3
	case "\u0066\u0061\u006cs\u0065":
		*_ebfb = 4
	}
	return nil
}

func NewBorderright() *Borderright {
	_bff := &Borderright{}
	_bff.CT_Border = *NewCT_Border()
	return _bff
}

func (_dce *Borderright) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	_dce.CT_Border = *NewCT_Border()
	for _, _aee := range start.Attr {
		if _aee.Name.Local == "\u0074\u0079\u0070\u0065" {
			_dce.TypeAttr.UnmarshalXMLAttr(_aee)
			continue
		}
		if _aee.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_gf, _dcd := _cf.ParseUint(_aee.Value, 10, 32)
			if _dcd != nil {
				return _dcd
			}
			_gfd := uint32(_gf)
			_dce.WidthAttr = &_gfd
			continue
		}
		if _aee.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_dce.ShadowAttr.UnmarshalXMLAttr(_aee)
			continue
		}
	}
	for {
		_ggf, _ec := d.Token()
		if _ec != nil {
			return _d.Errorf("\u0070\u0061\u0072si\u006e\u0067\u0020\u0042\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074\u003a\u0020\u0025\u0073", _ec)
		}
		if _db, _daa := _ggf.(_a.EndElement); _daa && _db.Name == start.Name {
			break
		}
	}
	return nil
}

func (_fa *Borderright) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "b\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074"
	return _fa.CT_Border.MarshalXML(e, start)
}

func (_gee ST_BorderShadow) String() string {
	switch _gee {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0074\u0072\u0075\u0065"
	case 3:
		return "\u0066"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}

type Bordertop struct{ CT_Border }

func (_cca *Bordertop) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062o\u0072\u0064\u0065\u0072\u0074\u006fp"
	return _cca.CT_Border.MarshalXML(e, start)
}

const (
	ST_WrapSideUnset   ST_WrapSide = 0
	ST_WrapSideBoth    ST_WrapSide = 1
	ST_WrapSideLeft    ST_WrapSide = 2
	ST_WrapSideRight   ST_WrapSide = 3
	ST_WrapSideLargest ST_WrapSide = 4
)

const (
	ST_BorderTypeUnset                 ST_BorderType = 0
	ST_BorderTypeNone                  ST_BorderType = 1
	ST_BorderTypeSingle                ST_BorderType = 2
	ST_BorderTypeThick                 ST_BorderType = 3
	ST_BorderTypeDouble                ST_BorderType = 4
	ST_BorderTypeHairline              ST_BorderType = 5
	ST_BorderTypeDot                   ST_BorderType = 6
	ST_BorderTypeDash                  ST_BorderType = 7
	ST_BorderTypeDotDash               ST_BorderType = 8
	ST_BorderTypeDashDotDot            ST_BorderType = 9
	ST_BorderTypeTriple                ST_BorderType = 10
	ST_BorderTypeThinThickSmall        ST_BorderType = 11
	ST_BorderTypeThickThinSmall        ST_BorderType = 12
	ST_BorderTypeThickBetweenThinSmall ST_BorderType = 13
	ST_BorderTypeThinThick             ST_BorderType = 14
	ST_BorderTypeThickThin             ST_BorderType = 15
	ST_BorderTypeThickBetweenThin      ST_BorderType = 16
	ST_BorderTypeThinThickLarge        ST_BorderType = 17
	ST_BorderTypeThickThinLarge        ST_BorderType = 18
	ST_BorderTypeThickBetweenThinLarge ST_BorderType = 19
	ST_BorderTypeWave                  ST_BorderType = 20
	ST_BorderTypeDoubleWave            ST_BorderType = 21
	ST_BorderTypeDashedSmall           ST_BorderType = 22
	ST_BorderTypeDashDotStroked        ST_BorderType = 23
	ST_BorderTypeThreeDEmboss          ST_BorderType = 24
	ST_BorderTypeThreeDEngrave         ST_BorderType = 25
	ST_BorderTypeHTMLOutset            ST_BorderType = 26
	ST_BorderTypeHTMLInset             ST_BorderType = 27
)

func NewBorderbottom() *Borderbottom {
	_b := &Borderbottom{}
	_b.CT_Border = *NewCT_Border()
	return _b
}

type Anchorlock struct{ CT_AnchorLock }

func (_dbc ST_BorderShadow) Validate() error { return _dbc.ValidateWithPath("") }

func (_ccd ST_WrapType) Validate() error { return _ccd.ValidateWithPath("") }

func (_gfe ST_HorizontalAnchor) Validate() error { return _gfe.ValidateWithPath("") }

func NewCT_Wrap() *CT_Wrap { _aceb := &CT_Wrap{}; return _aceb }

// ValidateWithPath validates the CT_AnchorLock and its children, prefixing error messages with path
func (_ecdd *CT_AnchorLock) ValidateWithPath(path string) error { return nil }

func NewCT_Border() *CT_Border { _gea := &CT_Border{}; return _gea }

func (_gac ST_WrapType) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	return e.EncodeElement(_gac.String(), start)
}

func NewAnchorlock() *Anchorlock {
	_eb := &Anchorlock{}
	_eb.CT_AnchorLock = *NewCT_AnchorLock()
	return _eb
}

func (_agac ST_BorderType) Validate() error { return _agac.ValidateWithPath("") }

func (_adb ST_WrapSide) MarshalXMLAttr(name _a.Name) (_a.Attr, error) {
	_ece := _a.Attr{}
	_ece.Name = name
	switch _adb {
	case ST_WrapSideUnset:
		_ece.Value = ""
	case ST_WrapSideBoth:
		_ece.Value = "\u0062\u006f\u0074\u0068"
	case ST_WrapSideLeft:
		_ece.Value = "\u006c\u0065\u0066\u0074"
	case ST_WrapSideRight:
		_ece.Value = "\u0072\u0069\u0067h\u0074"
	case ST_WrapSideLargest:
		_ece.Value = "\u006ca\u0072\u0067\u0065\u0073\u0074"
	}
	return _ece, nil
}

const (
	ST_BorderShadowUnset ST_BorderShadow = 0
	ST_BorderShadowT     ST_BorderShadow = 1
	ST_BorderShadowTrue  ST_BorderShadow = 2
	ST_BorderShadowF     ST_BorderShadow = 3
	ST_BorderShadowFalse ST_BorderShadow = 4
)

type ST_HorizontalAnchor byte

// Validate validates the CT_AnchorLock and its children
func (_fgf *CT_AnchorLock) Validate() error {
	return _fgf.ValidateWithPath("\u0043\u0054\u005f\u0041\u006e\u0063\u0068\u006f\u0072\u004c\u006f\u0063\u006b")
}

func (_ded *CT_Border) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	if _ded.TypeAttr != ST_BorderTypeUnset {
		_df, _ffb := _ded.TypeAttr.MarshalXMLAttr(_a.Name{Local: "\u0074\u0079\u0070\u0065"})
		if _ffb != nil {
			return _ffb
		}
		start.Attr = append(start.Attr, _df)
	}
	if _ded.WidthAttr != nil {
		start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0077\u0069\u0064t\u0068"}, Value: _d.Sprintf("\u0025\u0076", *_ded.WidthAttr)})
	}
	if _ded.ShadowAttr != ST_BorderShadowUnset {
		_edc, _gc := _ded.ShadowAttr.MarshalXMLAttr(_a.Name{Local: "\u0073\u0068\u0061\u0064\u006f\u0077"})
		if _gc != nil {
			return _gc
		}
		start.Attr = append(start.Attr, _edc)
	}
	e.EncodeToken(start)
	e.EncodeToken(_a.EndElement{Name: start.Name})
	return nil
}

type CT_Border struct {
	TypeAttr   ST_BorderType
	WidthAttr  *uint32
	ShadowAttr ST_BorderShadow
}

func (_dfc ST_VerticalAnchor) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	return e.EncodeElement(_dfc.String(), start)
}

func (_acef *CT_AnchorLock) UnmarshalXML(d *_a.Decoder, start _a.StartElement) error {
	for {
		_bcdf, _fgg := d.Token()
		if _fgg != nil {
			return _d.Errorf("\u0070a\u0072\u0073\u0069\u006eg\u0020\u0043\u0054\u005f\u0041n\u0063h\u006fr\u004c\u006f\u0063\u006b\u003a\u0020\u0025s", _fgg)
		}
		if _dba, _dgf := _bcdf.(_a.EndElement); _dgf && _dba.Name == start.Name {
			break
		}
	}
	return nil
}

func (_ce *Borderbottom) MarshalXML(e *_a.Encoder, start _a.StartElement) error {
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _a.Attr{Name: _a.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d"
	return _ce.CT_Border.MarshalXML(e, start)
}

// ValidateWithPath validates the Bordertop and its children, prefixing error messages with path
func (_cda *Bordertop) ValidateWithPath(path string) error {
	if _dee := _cda.CT_Border.ValidateWithPath(path); _dee != nil {
		return _dee
	}
	return nil
}

func (_aaf ST_WrapSide) String() string {
	switch _aaf {
	case 0:
		return ""
	case 1:
		return "\u0062\u006f\u0074\u0068"
	case 2:
		return "\u006c\u0065\u0066\u0074"
	case 3:
		return "\u0072\u0069\u0067h\u0074"
	case 4:
		return "\u006ca\u0072\u0067\u0065\u0073\u0074"
	}
	return ""
}

// Validate validates the Borderleft and its children
func (_ab *Borderleft) Validate() error {
	return _ab.ValidateWithPath("\u0042\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074")
}

func init() {
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043T\u005f\u0042\u006f\u0072\u0064\u0065r", NewCT_Border)
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043T\u005f\u0057\u0072\u0061\u0070", NewCT_Wrap)
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043\u0054\u005f\u0041\u006e\u0063\u0068\u006f\u0072\u004c\u006f\u0063\u006b", NewCT_AnchorLock)
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062o\u0072\u0064\u0065\u0072\u0074\u006fp", NewBordertop)
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074", NewBorderleft)
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "b\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074", NewBorderright)
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d", NewBorderbottom)
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0077\u0072\u0061\u0070", NewWrap)
	_e.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0061\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b", NewAnchorlock)
}
