//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package wildcard

func Match(pattern, name string) (_e bool) {
	if pattern == "" {
		return name == pattern
	}
	if pattern == "\u002a" {
		return true
	}
	_gdf := make([]rune, 0, len(name))
	_fc := make([]rune, 0, len(pattern))
	for _, _ag := range name {
		_gdf = append(_gdf, _ag)
	}
	for _, _dg := range pattern {
		_fc = append(_fc, _dg)
	}
	_db := false
	return _ec(_gdf, _fc, _db)
}

func _ec(_dcf, _ea []rune, _gf bool) bool {
	for len(_ea) > 0 {
		switch _ea[0] {
		default:
			if len(_dcf) == 0 || _dcf[0] != _ea[0] {
				return false
			}
		case '?':
			if len(_dcf) == 0 && !_gf {
				return false
			}
		case '*':
			return _ec(_dcf, _ea[1:], _gf) || (len(_dcf) > 0 && _ec(_dcf[1:], _ea, _gf))
		}
		_dcf = _dcf[1:]
		_ea = _ea[1:]
	}
	return len(_dcf) == 0 && len(_ea) == 0
}

func _dga(_bf, _bfa []rune, _fb int) int {
	for len(_bfa) > 0 {
		switch _bfa[0] {
		default:
			if len(_bf) == 0 {
				return -1
			}
			if _bf[0] != _bfa[0] {
				return _dga(_bf[1:], _bfa, _fb+1)
			}
		case '?':
			if len(_bf) == 0 {
				return -1
			}
		case '*':
			if len(_bf) == 0 {
				return -1
			}
			_ece := _dga(_bf, _bfa[1:], _fb)
			if _ece != -1 {
				return _fb
			} else {
				_ece = _dga(_bf[1:], _bfa, _fb)
				if _ece != -1 {
					return _fb
				} else {
					return -1
				}
			}
		}
		_bf = _bf[1:]
		_bfa = _bfa[1:]
	}
	return _fb
}

func Index(pattern, name string) (_df int) {
	if pattern == "" || pattern == "\u002a" {
		return 0
	}
	_bg := make([]rune, 0, len(name))
	_efc := make([]rune, 0, len(pattern))
	for _, _da := range name {
		_bg = append(_bg, _da)
	}
	for _, _ae := range pattern {
		_efc = append(_efc, _ae)
	}
	return _dga(_bg, _efc, 0)
}

func MatchSimple(pattern, name string) bool {
	if pattern == "" {
		return name == pattern
	}
	if pattern == "\u002a" {
		return true
	}
	_b := make([]rune, 0, len(name))
	_d := make([]rune, 0, len(pattern))
	for _, _a := range name {
		_b = append(_b, _a)
	}
	for _, _gd := range pattern {
		_d = append(_d, _gd)
	}
	_ba := true
	return _ec(_b, _d, _ba)
}
