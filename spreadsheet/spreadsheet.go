//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet

import (
	_aa "archive/zip"
	_gb "errors"
	_c "fmt"
	_d "github.com/Casper-Mars/officeTool"
	_dee "github.com/Casper-Mars/officeTool/chart"
	_cg "github.com/Casper-Mars/officeTool/color"
	_cb "github.com/Casper-Mars/officeTool/common"
	_gg "github.com/Casper-Mars/officeTool/common/license"
	_bb "github.com/Casper-Mars/officeTool/common/tempstorage"
	_ae "github.com/Casper-Mars/officeTool/measurement"
	_fe "github.com/Casper-Mars/officeTool/schema/soo/dml"
	_ba "github.com/Casper-Mars/officeTool/schema/soo/dml/chart"
	_ce "github.com/Casper-Mars/officeTool/schema/soo/dml/spreadsheetDrawing"
	_aag "github.com/Casper-Mars/officeTool/schema/soo/pkg/relationships"
	_ggd "github.com/Casper-Mars/officeTool/schema/soo/sml"
	_ga "github.com/Casper-Mars/officeTool/spreadsheet/format"
	_aec "github.com/Casper-Mars/officeTool/spreadsheet/formula"
	_eg "github.com/Casper-Mars/officeTool/spreadsheet/reference"
	_gaf "github.com/Casper-Mars/officeTool/spreadsheet/update"
	_cc "github.com/Casper-Mars/officeTool/vmldrawing"
	_ad "github.com/Casper-Mars/officeTool/zippkg"
	_db "image"
	_dg "image/jpeg"
	_ec "io"
	_g "log"
	_bg "math"
	_dd "math/big"
	_b "os"
	_f "path/filepath"
	_fb "regexp"
	_a "sort"
	_de "strconv"
	_dgd "strings"
	_dga "time"
)

// BottomRight is a no-op.
func (_efff OneCellAnchor) BottomRight() CellMarker { return CellMarker{} }

// BottomRight is a no-op.
func (_cedg AbsoluteAnchor) BottomRight() CellMarker { return CellMarker{} }

// SetColOffset sets a column offset in absolute distance.
func (_cedf CellMarker) SetColOffset(m _ae.Distance) {
	_cedf._bcb.ColOff.ST_CoordinateUnqualified = _d.Int64(int64(m / _ae.EMU))
}

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_bcab StyleSheet) RemoveFont(f Font) error {
	for _gbae, _fcgb := range _bcab._gcac.Fonts.Font {
		if _fcgb == f.X() {
			_bcab._gcac.Fonts.Font = append(_bcab._gcac.Fonts.Font[:_gbae], _bcab._gcac.Fonts.Font[_gbae+1:]...)
			return nil
		}
	}
	return _gb.New("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

var (
	_ebgca = [...]uint8{0, 21, 46, 61, 76, 91}
	_afbc  = [...]uint8{0, 21, 37, 53, 69, 85, 103, 119, 135, 151, 167, 185, 201, 217, 239}
	_ffage = [...]uint8{0, 16, 32, 48, 64}
	_dcgb  = [...]uint8{0, 16, 32, 48, 64, 80}
)

// Wrapped returns true if the cell will wrap text.
func (_ddbd CellStyle) Wrapped() bool {
	if _ddbd._cae.Alignment == nil {
		return false
	}
	if _ddbd._cae.Alignment.WrapTextAttr == nil {
		return false
	}
	return *_ddbd._cae.Alignment.WrapTextAttr
}

func (_ccb Border) SetBottom(style _ggd.ST_BorderStyle, c _cg.Color) {
	if _ccb._aac.Bottom == nil {
		_ccb._aac.Bottom = _ggd.NewCT_BorderPr()
	}
	_ccb._aac.Bottom.Color = _ggd.NewCT_Color()
	_ccb._aac.Bottom.Color.RgbAttr = c.AsRGBAString()
	_ccb._aac.Bottom.StyleAttr = style
}

// MoveTo is a no-op.
func (_ef AbsoluteAnchor) MoveTo(x, y int32) {}

// CellMarker represents a cell position
type CellMarker struct{ _bcb *_ce.CT_Marker }

// X returns the inner XML entity for a stylesheet.
func (_bec StyleSheet) X() *_ggd.StyleSheet { return _bec._gcac }

const _cf = "\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300"

// SetSize sets the text size for a rich text run.
func (_aee RichTextRun) SetSize(m _ae.Distance) {
	_aee.ensureRpr()
	_aee._aggb.RPr.Sz = _ggd.NewCT_FontSize()
	_aee._aggb.RPr.Sz.ValAttr = float64(m / _ae.Point)
}

// AddFormatValue adds a format value (databars require two).
func (_gaab DataBarScale) AddFormatValue(t _ggd.ST_CfvoType, val string) {
	_bbbd := _ggd.NewCT_Cfvo()
	_bbbd.TypeAttr = t
	_bbbd.ValAttr = _d.String(val)
	_gaab._edfg.Cfvo = append(_gaab._edfg.Cfvo, _bbbd)
}

// TopLeft is a no-op.
func (_fd AbsoluteAnchor) TopLeft() CellMarker { return CellMarker{} }

// SetPriority sets the rule priority
func (_age ConditionalFormattingRule) SetPriority(p int32) { _age._dbed.PriorityAttr = p }

// X returns the inner wrapped XML type.
func (_eag *Workbook) X() *_ggd.Workbook { return _eag._bbae }

// Type returns the type of anchor
func (_cfaf TwoCellAnchor) Type() AnchorType { return AnchorTypeTwoCell }

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_edc Cell) SetBool(v bool) {
	_edc.clearValue()
	_edc._dbd.V = _d.String(_de.Itoa(_bbfd(v)))
	_edc._dbd.TAttr = _ggd.ST_CellTypeB
}

// Rows returns all of the rows in a sheet.
func (_fbg *Sheet) Rows() []Row {
	_eee := []Row{}
	for _, _aadc := range _fbg._bcgb.SheetData.Row {
		_eee = append(_eee, Row{_fbg._bdb, _fbg, _aadc})
	}
	return _eee
}

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_gcb Comment) CellReference() string { return _gcb._gbfb.RefAttr }

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_fac ConditionalFormattingRule) SetIcons() IconScale {
	_fac.clear()
	_fac.SetType(_ggd.ST_CfTypeIconSet)
	_fac._dbed.IconSet = _ggd.NewCT_IconSet()
	_dcab := IconScale{_fac._dbed.IconSet}
	_dcab.SetIcons(_ggd.ST_IconSetType3TrafficLights1)
	return _dcab
}

func (_cfe DataValidation) clear() {
	_cfe._fcc.Formula1 = _d.String("\u0030")
	_cfe._fcc.Formula2 = _d.String("\u0030")
}

// GetWidth returns a worksheet's column width.
func (_abgd *evalContext) GetWidth(colIdx int) float64 {
	colIdx++
	for _, _bgb := range _abgd._afdd.X().Cols[0].Col {
		if int(_bgb.MinAttr) <= colIdx && colIdx <= int(_bgb.MaxAttr) {
			return float64(int(*_bgb.WidthAttr))
		}
	}
	return 0
}

func _fafc() *_ce.CT_TwoCellAnchor {
	_gegb := _ce.NewCT_TwoCellAnchor()
	_gegb.EditAsAttr = _ce.ST_EditAsOneCell
	_gegb.From.Col = 5
	_gegb.From.Row = 0
	_gegb.From.ColOff.ST_CoordinateUnqualified = _d.Int64(0)
	_gegb.From.RowOff.ST_CoordinateUnqualified = _d.Int64(0)
	_gegb.To.Col = 10
	_gegb.To.Row = 20
	_gegb.To.ColOff.ST_CoordinateUnqualified = _d.Int64(0)
	_gegb.To.RowOff.ST_CoordinateUnqualified = _d.Int64(0)
	return _gegb
}

// Col returns the column of the cell marker.
func (_dbc CellMarker) Col() int32 { return _dbc._bcb.Col }

// GetEpoch returns a workbook's time epoch.
func (_ebed *evalContext) GetEpoch() _dga.Time { return _ebed._afdd._bdb.Epoch() }

func (_fge Fill) Index() uint32 {
	if _fge._cabg == nil {
		return 0
	}
	for _dbb, _eadg := range _fge._cabg.Fill {
		if _fge._bcbc == _eadg {
			return uint32(_dbb)
		}
	}
	return 0
}

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_dbac StyleSheet) GetOrCreateStandardNumberFormat(f StandardFormat) CellStyle {
	for _, _cecf := range _dbac.CellStyles() {
		if _cecf.HasNumberFormat() && _cecf.NumberFormat() == uint32(f) {
			return _cecf
		}
	}
	_dde := _dbac.AddCellStyle()
	_dde.SetNumberFormatStandard(f)
	return _dde
}

// MakeComments constructs a new Comments wrapper.
func MakeComments(w *Workbook, x *_ggd.Comments) Comments { return Comments{w, x} }

// StyleSheet is a document style sheet.
type StyleSheet struct {
	_cecga *Workbook
	_gcac  *_ggd.StyleSheet
}

// AddGradientStop adds a color gradient stop.
func (_bdd ColorScale) AddGradientStop(color _cg.Color) {
	_aacf := _ggd.NewCT_Color()
	_aacf.RgbAttr = color.AsRGBAString()
	_bdd._aaed.Color = append(_bdd._aaed.Color, _aacf)
}

// SetError sets the cell type to error and the value to the given error message.
func (_bcg Cell) SetError(msg string) {
	_bcg.clearValue()
	_bcg._dbd.V = _d.String(msg)
	_bcg._dbd.TAttr = _ggd.ST_CellTypeE
}

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{ _begb *_ggd.CT_Rst }

// IsError returns true if the cell is an error type cell.
func (_cec Cell) IsError() bool { return _cec._dbd.TAttr == _ggd.ST_CellTypeE }

// X returns the inner wrapped XML type.
func (_ffdg Row) X() *_ggd.CT_Row { return _ffdg._dggg }

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct {
	_acdg *_ggd.CT_ConditionalFormatting
}

// Priority returns the rule priority
func (_efd ConditionalFormattingRule) Priority() int32 { return _efd._dbed.PriorityAttr }

// SetHidden marks the defined name as hidden.
func (_ggc DefinedName) SetHidden(b bool) { _ggc._cecc.HiddenAttr = _d.Bool(b) }

// SetWidth sets the width of the anchored object.
func (_cbf AbsoluteAnchor) SetWidth(w _ae.Distance) { _cbf._cd.Ext.CxAttr = int64(w / _ae.EMU) }

func (_bbb Cell) getFormat() string {
	if _bbb._dbd.SAttr == nil {
		return "\u0047e\u006e\u0065\u0072\u0061\u006c"
	}
	_dad := *_bbb._dbd.SAttr
	_ceda := _bbb._ebb.StyleSheet.GetCellStyle(_dad)
	_ddbe := _bbb._ebb.StyleSheet.GetNumberFormat(_ceda.NumberFormat())
	return _ddbe.GetFormat()
}

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte

// SetLocked sets cell locked or not.
func (_ead *evalContext) SetLocked(cellRef string, locked bool) {
	_ead._afdd.Cell(cellRef).setLocked(locked)
}

// HasFormula returns true if the cell has an asoociated formula.
func (_efe Cell) HasFormula() bool { return _efe._dbd.F != nil }

func (_adcd Sheet) validateMergedCells() error {
	_gebe := map[uint64]struct{}{}
	for _, _cea := range _adcd.MergedCells() {
		_eace, _cbfe, _fcbf := _eg.ParseRangeReference(_cea.Reference())
		if _fcbf != nil {
			return _c.Errorf("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073", _adcd.Name(), _cea.Reference())
		}
		for _dcef := _eace.RowIdx; _dcef <= _cbfe.RowIdx; _dcef++ {
			for _cbg := _eace.ColumnIdx; _cbg <= _cbfe.ColumnIdx; _cbg++ {
				_afbf := uint64(_dcef)<<32 | uint64(_cbg)
				if _, _bdaf := _gebe[_afbf]; _bdaf {
					return _c.Errorf("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065", _adcd.Name())
				}
				_gebe[_afbf] = struct{}{}
			}
		}
	}
	return nil
}

// AnchorType is the type of anchor.
type AnchorType byte

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_cgfa *Sheet) AddHyperlink(url string) _cb.Hyperlink {
	for _gadc, _adgf := range _cgfa._bdb._fbed {
		if _adgf == _cgfa._bcgb {
			return _cgfa._bdb._fdbe[_gadc].AddHyperlink(url)
		}
	}
	return _cb.Hyperlink{}
}

// X returns the inner wrapped XML type.
func (_cdc DefinedName) X() *_ggd.CT_DefinedName { return _cdc._cecc }

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_baaa *Sheet) AddConditionalFormatting(cellRanges []string) ConditionalFormatting {
	_gaac := _ggd.NewCT_ConditionalFormatting()
	_baaa._bcgb.ConditionalFormatting = append(_baaa._bcgb.ConditionalFormatting, _gaac)
	_aegf := make(_ggd.ST_Sqref, 0, 0)
	_gaac.SqrefAttr = &_aegf
	for _, _ddfb := range cellRanges {
		*_gaac.SqrefAttr = append(*_gaac.SqrefAttr, _ddfb)
	}
	return ConditionalFormatting{_gaac}
}

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_ee Cell) SetFormulaRaw(s string) {
	_ee.clearValue()
	_ee._dbd.TAttr = _ggd.ST_CellTypeStr
	_ee._dbd.F = _ggd.NewCT_CellFormula()
	_ee._dbd.F.Content = s
}

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_ddgc *Sheet) SetFrozen(firstRow, firstCol bool) {
	_ddgc._bcgb.SheetViews = nil
	_gadf := _ddgc.AddView()
	_gadf.SetState(_ggd.ST_PaneStateFrozen)
	switch {
	case firstRow && firstCol:
		_gadf.SetYSplit(1)
		_gadf.SetXSplit(1)
		_gadf.SetTopLeft("\u0042\u0032")
	case firstRow:
		_gadf.SetYSplit(1)
		_gadf.SetTopLeft("\u0041\u0032")
	case firstCol:
		_gadf.SetXSplit(1)
		_gadf.SetTopLeft("\u0042\u0031")
	}
}

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_fdgb Sheet) Validate() error {
	_ecbe := []func() error{_fdgb.validateRowCellNumbers, _fdgb.validateMergedCells, _fdgb.validateSheetNames}
	for _, _bgd := range _ecbe {
		if _cbfae := _bgd(); _cbfae != nil {
			return _cbfae
		}
	}
	if _dbda := _fdgb._bcgb.Validate(); _dbda != nil {
		return _dbda
	}
	return _fdgb._bcgb.Validate()
}

// X returns the inner wrapped XML type.
func (_gab NumberFormat) X() *_ggd.CT_NumFmt { return _gab._geef }

// GetValueAsNumber retrieves the cell's value as a number
func (_ada Cell) GetValueAsNumber() (float64, error) {
	if _ada._dbd.V == nil && _ada._dbd.Is == nil {
		return 0, nil
	}
	if _ada._dbd.TAttr == _ggd.ST_CellTypeS || !_ga.IsNumber(*_ada._dbd.V) {
		return _bg.NaN(), _gb.New("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065")
	}
	return _de.ParseFloat(*_ada._dbd.V, 64)
}

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct {
	_gce  *_ggd.Sst
	_daff map[string]int
}

func (_gcbb *Sheet) setList(_bffe string, _bafbc _aec.Result) error {
	_fdba, _abfg := _eg.ParseCellReference(_bffe)
	if _abfg != nil {
		return _abfg
	}
	_efgc := _gcbb.Row(_fdba.RowIdx)
	for _gcbc, _fgbb := range _bafbc.ValueList {
		_egdd := _efgc.Cell(_eg.IndexToColumn(_fdba.ColumnIdx + uint32(_gcbc)))
		if _fgbb.Type != _aec.ResultTypeEmpty {
			if _fgbb.IsBoolean {
				_egdd.SetBool(_fgbb.ValueNumber != 0)
			} else {
				_egdd.SetCachedFormulaResult(_fgbb.String())
			}
		}
	}
	return nil
}

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash(s string) string {
	_fbb := uint16(0)
	if len(s) > 0 {
		for _dfeb := len(s) - 1; _dfeb >= 0; _dfeb-- {
			_adbf := s[_dfeb]
			_fbb = ((_fbb >> 14) & 0x01) | ((_fbb << 1) & 0x7fff)
			_fbb ^= uint16(_adbf)
		}
		_fbb = ((_fbb >> 14) & 0x01) | ((_fbb << 1) & 0x7fff)
		_fbb ^= uint16(len(s))
		_fbb ^= (0x8000 | ('N' << 8) | 'K')
	}
	return _c.Sprintf("\u0025\u0030\u0034\u0058", uint64(_fbb))
}

// Clear clears the cell's value and type.
func (_ffa Cell) Clear() { _ffa.clearValue(); _ffa._dbd.TAttr = _ggd.ST_CellTypeUnset }

// AddCommentWithStyle adds a new comment styled in a default way
func (_dea Comments) AddCommentWithStyle(cellRef string, author string, comment string) error {
	_afa := _dea.AddComment(cellRef, author)
	_ebcb := _afa.AddRun()
	_ebcb.SetBold(true)
	_ebcb.SetSize(10)
	_ebcb.SetColor(_cg.Black)
	_ebcb.SetFont("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_ebcb.SetText(author + "\u003a")
	_ebcb = _afa.AddRun()
	_ebcb.SetSize(10)
	_ebcb.SetFont("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_ebcb.SetColor(_cg.Black)
	_ebcb.SetText("\u000d\u000a" + comment + "\u000d\u000a")
	_fgd, _dfe := _eg.ParseCellReference(cellRef)
	if _dfe != nil {
		return _dfe
	}
	_dea._aeff._cbbfe[0].Shape = append(_dea._aeff._cbbfe[0].Shape, _cc.NewCommentShape(int64(_fgd.ColumnIdx), int64(_fgd.RowIdx-1)))
	return nil
}

// SetWrapped configures the cell to wrap text.
func (_ega CellStyle) SetWrapped(b bool) {
	if _ega._cae.Alignment == nil {
		_ega._cae.Alignment = _ggd.NewCT_CellAlignment()
	}
	if !b {
		_ega._cae.Alignment.WrapTextAttr = nil
	} else {
		_ega._cae.Alignment.WrapTextAttr = _d.Bool(true)
		_ega._cae.ApplyAlignmentAttr = _d.Bool(true)
	}
}

var _accg = _d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.SharedStringsType, 0)

func (_edg DataValidationCompare) SetValue2(v string) { _edg._fefg.Formula2 = &v }

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_aad Cell) SetDate(d _dga.Time) {
	_aad.clearValue()
	d = _cde(d)
	_dfda := _aad._ebb.Epoch()
	if d.Before(_dfda) {
		_d.Log("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064")
		return
	}
	_cac := d.Sub(_dfda)
	_ebbe := new(_dd.Float)
	_acf := new(_dd.Float)
	_acf.SetPrec(128)
	_acf.SetUint64(uint64(_cac))
	_gee := new(_dd.Float)
	_gee.SetUint64(24 * 60 * 60 * 1e9)
	_ebbe.Quo(_acf, _gee)
	_ffb, _ := _ebbe.Uint64()
	_aad._dbd.V = _d.Stringf("\u0025\u0064", _ffb)
}

// X returns the inner wrapped XML type.
func (_adc Comment) X() *_ggd.CT_Comment { return _adc._gbfb }

func (_agec DataValidation) SetList() DataValidationList {
	_agec.clear()
	_agec._fcc.TypeAttr = _ggd.ST_DataValidationTypeList
	_agec._fcc.OperatorAttr = _ggd.ST_DataValidationOperatorEqual
	return DataValidationList{_agec._fcc}
}

// HasFormula returns true if the cell contains formula.
func (_bbc *evalContext) HasFormula(cellRef string) bool {
	return _bbc._afdd.Cell(cellRef).HasFormula()
}

// X returns the inner wrapped XML type.
func (_egad Comments) X() *_ggd.Comments { return _egad._fcd }

func (_fcb RichTextRun) ensureRpr() {
	if _fcb._aggb.RPr == nil {
		_fcb._aggb.RPr = _ggd.NewCT_RPrElt()
	}
}

// X returns the inner wrapped XML type.
func (_aedd RichTextRun) X() *_ggd.CT_RElt { return _aedd._aggb }

// SetRotation configures the cell to be rotated.
func (_dfdaa CellStyle) SetRotation(deg uint8) {
	if _dfdaa._cae.Alignment == nil {
		_dfdaa._cae.Alignment = _ggd.NewCT_CellAlignment()
	}
	_dfdaa._cae.ApplyAlignmentAttr = _d.Bool(true)
	_dfdaa._cae.Alignment.TextRotationAttr = _d.Uint8(deg)
}

func (_gge Font) SetName(name string) { _gge._beba.Name = []*_ggd.CT_FontName{{ValAttr: name}} }

// SetWidth is a no-op.
func (_gdcfg TwoCellAnchor) SetWidth(w _ae.Distance) {}

func (_aaaf PatternFill) ClearBgColor() { _aaaf._aaac.BgColor = nil }

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_egaae *Workbook) AddImage(i _cb.Image) (_cb.ImageRef, error) {
	_gbfbd := _cb.MakeImageRef(i, &_egaae.DocBase, _egaae._adebd)
	if i.Data == nil && i.Path == "" {
		return _gbfbd, _gb.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _gbfbd, _gb.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _gbfbd, _gb.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	if i.Path != "" {
		_fbad := _bb.Add(i.Path)
		if _fbad != nil {
			return _gbfbd, _fbad
		}
	}
	_egaae.Images = append(_egaae.Images, _gbfbd)
	return _gbfbd, nil
}

// Comment is a single comment within a sheet.
type Comment struct {
	_aab  *Workbook
	_gbfb *_ggd.CT_Comment
	_adb  *_ggd.Comments
}

type DifferentialStyle struct {
	_dggf  *_ggd.CT_Dxf
	_fefge *Workbook
	_cgf   *_ggd.CT_Dxfs
}

// IsStructureLocked returns whether the workbook structure is locked.
func (_gedgb WorkbookProtection) IsStructureLocked() bool {
	return _gedgb._decb.LockStructureAttr != nil && *_gedgb._decb.LockStructureAttr
}

// SetHeight is a nop-op.
func (_egdc TwoCellAnchor) SetHeight(h _ae.Distance) {}

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_cbb *evalContext) LastRow(col string) int {
	_gfbc := _cbb._afdd
	_gfd := int(_eg.ColumnToIndex(col))
	_ddfa := 1
	for _, _bddc := range _gfbc._bcgb.SheetData.Row {
		if _bddc.RAttr != nil {
			_afea := Row{_gfbc._bdb, _gfbc, _bddc}
			_adab := len(_afea.Cells())
			if _adab > _gfd {
				_ddfa = int(_afea.RowNumber())
			}
		}
	}
	return _ddfa
}

// Cell is a single cell within a sheet.
type Cell struct {
	_ebb  *Workbook
	_dbag *Sheet
	_ebe  *_ggd.CT_Row
	_dbd  *_ggd.CT_Cell
}

// SetItalic causes the text to be displayed in italic.
func (_fae RichTextRun) SetItalic(b bool) {
	_fae.ensureRpr()
	_fae._aggb.RPr.I = _ggd.NewCT_BooleanProperty()
	_fae._aggb.RPr.I.ValAttr = _d.Bool(b)
}

// AddHyperlink creates and sets a hyperlink on a cell.
func (_gbg Cell) AddHyperlink(url string) {
	for _baf, _aagg := range _gbg._ebb._fbed {
		if _aagg == _gbg._dbag._bcgb {
			_gbg.SetHyperlink(_gbg._ebb._fdbe[_baf].AddHyperlink(url))
			return
		}
	}
}

// SetTopLeft sets the top left visible cell after the split.
func (_dggfa SheetView) SetTopLeft(cellRef string) {
	_dggfa.ensurePane()
	_dggfa._baef.Pane.TopLeftCellAttr = &cellRef
}

func (_deg CellStyle) SetShrinkToFit(b bool) {
	if _deg._cae.Alignment == nil {
		_deg._cae.Alignment = _ggd.NewCT_CellAlignment()
	}
	_deg._cae.ApplyAlignmentAttr = _d.Bool(true)
	if !b {
		_deg._cae.Alignment.ShrinkToFitAttr = nil
	} else {
		_deg._cae.Alignment.ShrinkToFitAttr = _d.Bool(b)
	}
}

// Open opens and reads a workbook from a file (.xlsx).
func Open(filename string) (*Workbook, error) {
	_agga, _ege := _b.Open(filename)
	if _ege != nil {
		return nil, _c.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _ege)
	}
	defer _agga.Close()
	_bae, _ege := _b.Stat(filename)
	if _ege != nil {
		return nil, _c.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _ege)
	}
	_gac, _ege := Read(_agga, _bae.Size())
	if _ege != nil {
		return nil, _ege
	}
	_bca, _ := _f.Abs(_f.Dir(filename))
	_gac._bbeed = _f.Join(_bca, filename)
	return _gac, nil
}

func (_ede *evalContext) NamedRange(ref string) _aec.Reference {
	for _, _gcbf := range _ede._afdd._bdb.DefinedNames() {
		if _gcbf.Name() == ref {
			return _aec.MakeRangeReference(_gcbf.Content())
		}
	}
	for _, _aefe := range _ede._afdd._bdb.Tables() {
		if _aefe.Name() == ref {
			return _aec.MakeRangeReference(_c.Sprintf("\u0025\u0073\u0021%\u0073", _ede._afdd.Name(), _aefe.Reference()))
		}
	}
	return _aec.ReferenceInvalid
}

// SaveToFile writes the workbook out to a file.
func (_fdgg *Workbook) SaveToFile(path string) error {
	_fdbc, _gfcd := _b.Create(path)
	if _gfcd != nil {
		return _gfcd
	}
	defer _fdbc.Close()
	return _fdgg.Save(_fdbc)
}

// AddView adds a sheet view.
func (_fad *Sheet) AddView() SheetView {
	if _fad._bcgb.SheetViews == nil {
		_fad._bcgb.SheetViews = _ggd.NewCT_SheetViews()
	}
	_dfa := _ggd.NewCT_SheetView()
	_fad._bcgb.SheetViews.SheetView = append(_fad._bcgb.SheetViews.SheetView, _dfa)
	return SheetView{_dfa}
}

func (_bbe Comments) getOrCreateAuthor(_dbe string) uint32 {
	for _bfg, _ebbb := range _bbe._fcd.Authors.Author {
		if _ebbb == _dbe {
			return uint32(_bfg)
		}
	}
	_acc := uint32(len(_bbe._fcd.Authors.Author))
	_bbe._fcd.Authors.Author = append(_bbe._fcd.Authors.Author, _dbe)
	return _acc
}

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_bfa Cell) SetFormulaShared(formula string, rows, cols uint32) error {
	_bfa.clearValue()
	_bfa._dbd.TAttr = _ggd.ST_CellTypeStr
	_bfa._dbd.F = _ggd.NewCT_CellFormula()
	_bfa._dbd.F.TAttr = _ggd.ST_CellFormulaTypeShared
	_bfa._dbd.F.Content = formula
	_bgad, _ca := _eg.ParseCellReference(_bfa.Reference())
	if _ca != nil {
		return _ca
	}
	_gad := uint32(0)
	for _, _eca := range _bfa._dbag.Rows() {
		for _, _faf := range _eca._dggg.C {
			if _faf.F != nil && _faf.F.SiAttr != nil && *_faf.F.SiAttr >= _gad {
				_gad = *_faf.F.SiAttr
			}
		}
	}
	_gad++
	_bc := _c.Sprintf("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d", _bgad.Column, _bgad.RowIdx, _eg.IndexToColumn(_bgad.ColumnIdx+cols), _bgad.RowIdx+rows)
	_bfa._dbd.F.RefAttr = _d.String(_bc)
	_bfa._dbd.F.SiAttr = _d.Uint32(_gad)
	_gbd := Sheet{_bfa._ebb, _bfa._dbag._adae, _bfa._dbag._bcgb}
	for _fef := _bgad.RowIdx; _fef <= _bgad.RowIdx+rows; _fef++ {
		for _bac := _bgad.ColumnIdx; _bac <= _bgad.ColumnIdx+cols; _bac++ {
			if _fef == _bgad.RowIdx && _bac == _bgad.ColumnIdx {
				continue
			}
			_ecg := _c.Sprintf("\u0025\u0073\u0025\u0064", _eg.IndexToColumn(_bac), _fef)
			_gbd.Cell(_ecg).Clear()
			_gbd.Cell(_ecg).X().F = _ggd.NewCT_CellFormula()
			_gbd.Cell(_ecg).X().F.TAttr = _ggd.ST_CellFormulaTypeShared
			_gbd.Cell(_ecg).X().F.SiAttr = _d.Uint32(_gad)
		}
	}
	return nil
}

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_cacf NumberFormat) ID() uint32 { return _cacf._geef.NumFmtIdAttr }

func (_eef Cell) getLabelPrefix() string {
	if _eef._dbd.SAttr == nil {
		return ""
	}
	_acg := *_eef._dbd.SAttr
	_aea := _eef._ebb.StyleSheet.GetCellStyle(_acg)
	switch _aea._cae.Alignment.HorizontalAttr {
	case _ggd.ST_HorizontalAlignmentLeft:
		return "\u0027"
	case _ggd.ST_HorizontalAlignmentRight:
		return "\u0022"
	case _ggd.ST_HorizontalAlignmentCenter:
		return "\u005e"
	case _ggd.ST_HorizontalAlignmentFill:
		return "\u005c"
	default:
		return ""
	}
}

// X returns the inner wrapped XML type.
func (_beff DataBarScale) X() *_ggd.CT_DataBar { return _beff._edfg }

// ClearBorder clears any border configuration from the cell style.
func (_cbce CellStyle) ClearBorder() {
	_cbce._cae.BorderIdAttr = nil
	_cbce._cae.ApplyBorderAttr = nil
}

const (
	DVCompareOpEqual        = DVCompareOp(_ggd.ST_DataValidationOperatorEqual)
	DVCompareOpBetween      = DVCompareOp(_ggd.ST_DataValidationOperatorBetween)
	DVCompareOpNotBetween   = DVCompareOp(_ggd.ST_DataValidationOperatorNotBetween)
	DVCompareOpNotEqual     = DVCompareOp(_ggd.ST_DataValidationOperatorNotEqual)
	DVCompareOpGreater      = DVCompareOp(_ggd.ST_DataValidationOperatorGreaterThan)
	DVCompareOpGreaterEqual = DVCompareOp(_ggd.ST_DataValidationOperatorGreaterThanOrEqual)
	DVCompareOpLess         = DVCompareOp(_ggd.ST_DataValidationOperatorLessThan)
	DVCompareOpLessEqual    = DVCompareOp(_ggd.ST_DataValidationOperatorLessThanOrEqual)
)

// IsBool returns true if the cell is a boolean type cell.
func (_acb Cell) IsBool() bool { return _acb._dbd.TAttr == _ggd.ST_CellTypeB }

// AddMergedCells merges cells within a sheet.
func (_fgcd *Sheet) AddMergedCells(fromRef, toRef string) MergedCell {
	if _fgcd._bcgb.MergeCells == nil {
		_fgcd._bcgb.MergeCells = _ggd.NewCT_MergeCells()
	}
	_aafa := _ggd.NewCT_MergeCell()
	_aafa.RefAttr = _c.Sprintf("\u0025\u0073\u003a%\u0073", fromRef, toRef)
	_fgcd._bcgb.MergeCells.MergeCell = append(_fgcd._bcgb.MergeCells.MergeCell, _aafa)
	_fgcd._bcgb.MergeCells.CountAttr = _d.Uint32(uint32(len(_fgcd._bcgb.MergeCells.MergeCell)))
	return MergedCell{_fgcd._bdb, _fgcd, _aafa}
}

// LockSheet controls the locking of the sheet.
func (_cagb SheetProtection) LockSheet(b bool) {
	if !b {
		_cagb._bcef.SheetAttr = nil
	} else {
		_cagb._bcef.SheetAttr = _d.Bool(true)
	}
}

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_adead *Sheet) InsertRow(rowNum int) Row {
	_baab := uint32(rowNum)
	for _, _eec := range _adead.Rows() {
		if _eec._dggg.RAttr != nil && *_eec._dggg.RAttr >= _baab {
			*_eec._dggg.RAttr++
			for _, _gff := range _eec.Cells() {
				_aff, _aga := _eg.ParseCellReference(_gff.Reference())
				if _aga != nil {
					continue
				}
				_aff.RowIdx++
				_gff._dbd.RAttr = _d.String(_aff.String())
			}
		}
	}
	for _, _gcf := range _adead.MergedCells() {
		_fbdf, _aeca, _fcfg := _eg.ParseRangeReference(_gcf.Reference())
		if _fcfg != nil {
			continue
		}
		if int(_fbdf.RowIdx) >= rowNum {
			_fbdf.RowIdx++
		}
		if int(_aeca.RowIdx) >= rowNum {
			_aeca.RowIdx++
		}
		_beac := _c.Sprintf("\u0025\u0073\u003a%\u0073", _fbdf, _aeca)
		_gcf.SetReference(_beac)
	}
	return _adead.AddNumberedRow(_baab)
}

func (_edca SortOrder) String() string {
	if _edca >= SortOrder(len(_aeae)-1) {
		return _c.Sprintf("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029", _edca)
	}
	return _cdgd[_aeae[_edca]:_aeae[_edca+1]]
}

// AddSheet adds a new sheet to a workbook.
func (_cada *Workbook) AddSheet() Sheet {
	_fcbd := _ggd.NewCT_Sheet()
	_fcbd.SheetIdAttr = 1
	for _, _decea := range _cada._bbae.Sheets.Sheet {
		if _fcbd.SheetIdAttr <= _decea.SheetIdAttr {
			_fcbd.SheetIdAttr = _decea.SheetIdAttr + 1
		}
	}
	_cada._bbae.Sheets.Sheet = append(_cada._bbae.Sheets.Sheet, _fcbd)
	_fcbd.NameAttr = _c.Sprintf("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064", _fcbd.SheetIdAttr)
	_gcgf := _ggd.NewWorksheet()
	_gcgf.Dimension = _ggd.NewCT_SheetDimension()
	_gcgf.Dimension.RefAttr = "\u0041\u0031"
	_cada._fbed = append(_cada._fbed, _gcgf)
	_ecbg := _cb.NewRelationships()
	_cada._fdbe = append(_cada._fdbe, _ecbg)
	_gcgf.SheetData = _ggd.NewCT_SheetData()
	_cada._cbge = append(_cada._cbge, nil)
	_gcace := _d.DocTypeSpreadsheet
	_gefaa := _cada._adebd.AddAutoRelationship(_gcace, _d.OfficeDocumentType, len(_cada._bbae.Sheets.Sheet), _d.WorksheetType)
	_fcbd.IdAttr = _gefaa.ID()
	_cada.ContentTypes.AddOverride(_d.AbsoluteFilename(_gcace, _d.WorksheetContentType, len(_cada._bbae.Sheets.Sheet)), _d.WorksheetContentType)
	return Sheet{_cada, _fcbd, _gcgf}
}

// AddDataValidation adds a data validation rule to a sheet.
func (_dfcge *Sheet) AddDataValidation() DataValidation {
	if _dfcge._bcgb.DataValidations == nil {
		_dfcge._bcgb.DataValidations = _ggd.NewCT_DataValidations()
	}
	_egcg := _ggd.NewCT_DataValidation()
	_egcg.ShowErrorMessageAttr = _d.Bool(true)
	_dfcge._bcgb.DataValidations.DataValidation = append(_dfcge._bcgb.DataValidations.DataValidation, _egcg)
	_dfcge._bcgb.DataValidations.CountAttr = _d.Uint32(uint32(len(_dfcge._bcgb.DataValidations.DataValidation)))
	return DataValidation{_egcg}
}

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_geba *Workbook) SetActiveSheetIndex(idx uint32) {
	if _geba._bbae.BookViews == nil {
		_geba._bbae.BookViews = _ggd.NewCT_BookViews()
	}
	if len(_geba._bbae.BookViews.WorkbookView) == 0 {
		_geba._bbae.BookViews.WorkbookView = append(_geba._bbae.BookViews.WorkbookView, _ggd.NewCT_BookView())
	}
	_geba._bbae.BookViews.WorkbookView[0].ActiveTabAttr = _d.Uint32(idx)
}

// GetFormat sets the number format code.
func (_daa NumberFormat) GetFormat() string { return _daa._geef.FormatCodeAttr }

// DataValidation controls cell validation
type DataValidation struct{ _fcc *_ggd.CT_DataValidation }

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_feaf *Workbook) CopySheetByName(name, copiedSheetName string) (Sheet, error) {
	_gbffg := -1
	for _dgb, _gafg := range _feaf.Sheets() {
		if name == _gafg.Name() {
			_gbffg = _dgb
			break
		}
	}
	if _gbffg == -1 {
		return Sheet{}, ErrorNotFound
	}
	return _feaf.CopySheet(_gbffg, copiedSheetName)
}

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_edfc TwoCellAnchor) SetWidthCells(w int32) {
	_edbg := _edfc.TopLeft()
	_fbgb := _edfc.BottomRight()
	_fbgb.SetCol(_edbg.Col() + w)
}

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{ Order SortOrder }

// X returns the inner wrapped XML type.
func (_ebg Column) X() *_ggd.CT_Col { return _ebg._eccb }

// X returns the inner wrapped XML type.
func (_fab CellMarker) X() *_ce.CT_Marker { return _fab._bcb }

func (_bfgg ConditionalFormattingRule) InitializeDefaults() {
	_bfgg.SetType(_ggd.ST_CfTypeCellIs)
	_bfgg.SetOperator(_ggd.ST_ConditionalFormattingOperatorGreaterThan)
	_bfgg.SetPriority(1)
}

// X returns the inner wrapped XML type.
func (_edf ColorScale) X() *_ggd.CT_ColorScale { return _edf._aaed }

// SetValues sets the possible values. This is incompatible with SetRange.
func (_edec DataValidationList) SetValues(values []string) {
	_edec._eea.Formula1 = _d.String("\u0022" + _dgd.Join(values, "\u002c") + "\u0022")
	_edec._eea.Formula2 = _d.String("\u0030")
}

func (_aaegf *evalContext) SetOffset(col, row uint32) { _aaegf._cga = col; _aaegf._fba = row }

func (_fafe Sheet) validateRowCellNumbers() error {
	_afee := map[uint32]struct{}{}
	for _, _acad := range _fafe._bcgb.SheetData.Row {
		if _acad.RAttr != nil {
			if _, _dagb := _afee[*_acad.RAttr]; _dagb {
				return _c.Errorf("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064", _fafe.Name(), *_acad.RAttr)
			}
			_afee[*_acad.RAttr] = struct{}{}
		}
		_egc := map[string]struct{}{}
		for _, _afde := range _acad.C {
			if _afde.RAttr == nil {
				continue
			}
			if _, _daac := _egc[*_afde.RAttr]; _daac {
				return _c.Errorf("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073", _fafe.Name(), *_afde.RAttr)
			}
			_egc[*_afde.RAttr] = struct{}{}
		}
	}
	return nil
}

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_dfd Cell) GetFormattedValue() string {
	_cbfa := _dfd.getFormat()
	switch _dfd._dbd.TAttr {
	case _ggd.ST_CellTypeB:
		_gcc, _ := _dfd.GetValueAsBool()
		if _gcc {
			return "\u0054\u0052\u0055\u0045"
		}
		return "\u0046\u0041\u004cS\u0045"
	case _ggd.ST_CellTypeN:
		_bba, _ := _dfd.GetValueAsNumber()
		return _ga.Number(_bba, _cbfa)
	case _ggd.ST_CellTypeE:
		if _dfd._dbd.V != nil {
			return *_dfd._dbd.V
		}
		return ""
	case _ggd.ST_CellTypeS, _ggd.ST_CellTypeInlineStr:
		return _ga.String(_dfd.GetString(), _cbfa)
	case _ggd.ST_CellTypeStr:
		_cgdd := _dfd.GetString()
		if _ga.IsNumber(_cgdd) {
			_ccf, _ := _de.ParseFloat(_cgdd, 64)
			return _ga.Number(_ccf, _cbfa)
		}
		return _ga.String(_cgdd, _cbfa)
	case _ggd.ST_CellTypeUnset:
		fallthrough
	default:
		_abe, _ := _dfd.GetRawValue()
		if len(_abe) == 0 {
			return ""
		}
		_cgc, _ece := _dfd.GetValueAsNumber()
		if _ece == nil {
			return _ga.Number(_cgc, _cbfa)
		}
		return _ga.String(_abe, _cbfa)
	}
}

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{ _eea *_ggd.CT_DataValidation }

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_fcdd Row) RowNumber() uint32 {
	if _fcdd._dggg.RAttr != nil {
		return *_fcdd._dggg.RAttr
	}
	return 0
}

// Index returns the index of the differential style.
func (_adbg DifferentialStyle) Index() uint32 {
	for _cca, _edd := range _adbg._cgf.Dxf {
		if _adbg._dggf == _edd {
			return uint32(_cca)
		}
	}
	return 0
}

const (
	DVCompareTypeWholeNumber = DVCompareType(_ggd.ST_DataValidationTypeWhole)
	DVCompareTypeDecimal     = DVCompareType(_ggd.ST_DataValidationTypeDecimal)
	DVCompareTypeDate        = DVCompareType(_ggd.ST_DataValidationTypeDate)
	DVCompareTypeTime        = DVCompareType(_ggd.ST_DataValidationTypeTime)
	DVompareTypeTextLength   = DVCompareType(_ggd.ST_DataValidationTypeTextLength)
)

// Name returns the name of the defined name.
func (_bad DefinedName) Name() string { return _bad._cecc.NameAttr }

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_ebef Cell) SetFormulaArray(s string) {
	_ebef.clearValue()
	_ebef._dbd.TAttr = _ggd.ST_CellTypeStr
	_ebef._dbd.F = _ggd.NewCT_CellFormula()
	_ebef._dbd.F.TAttr = _ggd.ST_CellFormulaTypeArray
	_ebef._dbd.F.Content = s
}

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_dada *Sheet) FormulaContext() _aec.Context { return _gba(_dada) }

// X returns the inner wrapped XML type.
func (_caac WorkbookProtection) X() *_ggd.CT_WorkbookProtection { return _caac._decb }

// SetStyle sets the style to be used for conditional rules
func (_bea ConditionalFormattingRule) SetStyle(d DifferentialStyle) {
	_bea._dbed.DxfIdAttr = _d.Uint32(d.Index())
}

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_bgf TwoCellAnchor) BottomRight() CellMarker { return CellMarker{_bgf._babb.To} }

type PatternFill struct {
	_aaac *_ggd.CT_PatternFill
	_daae *_ggd.CT_Fill
}

// SetFormat sets the number format code.
func (_ggdb NumberFormat) SetFormat(f string) { _ggdb._geef.FormatCodeAttr = f }

// IsHidden returns whether the row is hidden or not.
func (_cacfg Row) IsHidden() bool { return _cacfg._dggg.HiddenAttr != nil && *_cacfg._dggg.HiddenAttr }

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_gfba *Sheet) Column(idx uint32) Column {
	for _, _beedg := range _gfba._bcgb.Cols {
		for _, _aefb := range _beedg.Col {
			if idx >= _aefb.MinAttr && idx <= _aefb.MaxAttr {
				return Column{_aefb}
			}
		}
	}
	var _bceg *_ggd.CT_Cols
	if len(_gfba._bcgb.Cols) == 0 {
		_bceg = _ggd.NewCT_Cols()
		_gfba._bcgb.Cols = append(_gfba._bcgb.Cols, _bceg)
	} else {
		_bceg = _gfba._bcgb.Cols[0]
	}
	_dgag := _ggd.NewCT_Col()
	_dgag.MinAttr = idx
	_dgag.MaxAttr = idx
	_bceg.Col = append(_bceg.Col, _dgag)
	return Column{_dgag}
}

// Tables returns a slice of all defined tables in the workbook.
func (_dacff *Workbook) Tables() []Table {
	if _dacff._caaa == nil {
		return nil
	}
	_gae := []Table{}
	for _, _ccdf := range _dacff._caaa {
		_gae = append(_gae, Table{_ccdf})
	}
	return _gae
}

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_daga *Sheet) Sort(column string, firstRow uint32, order SortOrder) {
	_cead := _daga._bcgb.SheetData.Row
	_eabc := _daga.Rows()
	for _gbeg, _dcedg := range _eabc {
		if _dcedg.RowNumber() == firstRow {
			_cead = _daga._bcgb.SheetData.Row[_gbeg:]
			break
		}
	}
	_aafbd := Comparer{Order: order}
	_a.Slice(_cead, func(_febc, _afgg int) bool {
		return _aafbd.LessRows(column, Row{_daga._bdb, _daga, _cead[_febc]}, Row{_daga._bdb, _daga, _cead[_afgg]})
	})
	for _ggag, _gcfb := range _daga.Rows() {
		_cag := uint32(_ggag + 1)
		if _gcfb.RowNumber() != _cag {
			_gcfb.renumberAs(_cag)
		}
	}
}

type Table struct{ _cbab *_ggd.Table }

// SetContent sets the defined name content.
func (_fgfb DefinedName) SetContent(s string) { _fgfb._cecc.Content = s }

// SetWidth controls the width of a column.
func (_fdg Column) SetWidth(w _ae.Distance) {
	_fdg._eccb.WidthAttr = _d.Float64(float64(w / _ae.Character))
}

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct {
	_beba *_ggd.CT_Font
	_fccf *_ggd.StyleSheet
}

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_adef *Sheet) SetAutoFilter(rangeRef string) {
	rangeRef = _dgd.Replace(rangeRef, "\u0024", "", -1)
	_adef._bcgb.AutoFilter = _ggd.NewCT_AutoFilter()
	_adef._bcgb.AutoFilter.RefAttr = _d.String(rangeRef)
	_ebda := "\u0027" + _adef.Name() + "\u0027\u0021"
	var _bfbe DefinedName
	for _, _ccgg := range _adef._bdb.DefinedNames() {
		if _ccgg.Name() == _aaag {
			if _dgd.HasPrefix(_ccgg.Content(), _ebda) {
				_bfbe = _ccgg
				_bfbe.SetContent(_adef.RangeReference(rangeRef))
				break
			}
		}
	}
	if _bfbe.X() == nil {
		_bfbe = _adef._bdb.AddDefinedName(_aaag, _adef.RangeReference(rangeRef))
	}
	for _dgcd, _adegg := range _adef._bdb._fbed {
		if _adegg == _adef._bcgb {
			_bfbe.SetLocalSheetID(uint32(_dgcd))
		}
	}
}

func _cdf() *_ce.CT_AbsoluteAnchor { _fgb := _ce.NewCT_AbsoluteAnchor(); return _fgb }

// SetHidden hides or unhides the row
func (_fbf Row) SetHidden(hidden bool) {
	if !hidden {
		_fbf._dggg.HiddenAttr = nil
	} else {
		_fbf._dggg.HiddenAttr = _d.Bool(true)
	}
}

func (_dcae *Sheet) slideCellsLeft(_gbbe []*_ggd.CT_Cell) []*_ggd.CT_Cell {
	for _, _dfaa := range _gbbe {
		_agag, _cge := _eg.ParseCellReference(*_dfaa.RAttr)
		if _cge != nil {
			return _gbbe
		}
		_ffbg := _agag.ColumnIdx - 1
		_ddab := _eg.IndexToColumn(_ffbg) + _c.Sprintf("\u0025\u0064", _agag.RowIdx)
		_dfaa.RAttr = &_ddab
	}
	return _gbbe
}

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_deae Drawing) AddChart(at AnchorType) (_dee.Chart, Anchor) {
	_gbdb := _ba.NewChartSpace()
	_deae._debc._fgcda = append(_deae._debc._fgcda, _gbdb)
	_cbfd := _d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.ChartContentType, len(_deae._debc._fgcda))
	_deae._debc.ContentTypes.AddOverride(_cbfd, _d.ChartContentType)
	var _gfab string
	for _cfa, _eeg := range _deae._debc._cefe {
		if _eeg == _deae._fefc {
			_gdd := _d.RelativeFilename(_d.DocTypeSpreadsheet, _d.DrawingType, _d.ChartType, len(_deae._debc._fgcda))
			_deba := _deae._debc._fcbeb[_cfa].AddRelationship(_gdd, _d.ChartType)
			_gfab = _deba.ID()
			break
		}
	}
	var _edb Anchor
	var _dgde *_ce.CT_GraphicalObjectFrame
	switch at {
	case AnchorTypeAbsolute:
		_feg := _cdf()
		_deae._fefc.EG_Anchor = append(_deae._fefc.EG_Anchor, &_ce.EG_Anchor{AbsoluteAnchor: _feg})
		_feg.Choice = &_ce.EG_ObjectChoicesChoice{}
		_feg.Choice.GraphicFrame = _ce.NewCT_GraphicalObjectFrame()
		_dgde = _feg.Choice.GraphicFrame
		_edb = AbsoluteAnchor{_feg}
	case AnchorTypeOneCell:
		_aefef := _gbga()
		_deae._fefc.EG_Anchor = append(_deae._fefc.EG_Anchor, &_ce.EG_Anchor{OneCellAnchor: _aefef})
		_aefef.Choice = &_ce.EG_ObjectChoicesChoice{}
		_aefef.Choice.GraphicFrame = _ce.NewCT_GraphicalObjectFrame()
		_dgde = _aefef.Choice.GraphicFrame
		_edb = OneCellAnchor{_aefef}
	case AnchorTypeTwoCell:
		_bee := _fafc()
		_deae._fefc.EG_Anchor = append(_deae._fefc.EG_Anchor, &_ce.EG_Anchor{TwoCellAnchor: _bee})
		_bee.Choice = &_ce.EG_ObjectChoicesChoice{}
		_bee.Choice.GraphicFrame = _ce.NewCT_GraphicalObjectFrame()
		_dgde = _bee.Choice.GraphicFrame
		_edb = TwoCellAnchor{_bee}
	}
	_dgde.NvGraphicFramePr = _ce.NewCT_GraphicalObjectFrameNonVisual()
	_dgde.NvGraphicFramePr.CNvPr.IdAttr = uint32(len(_deae._fefc.EG_Anchor))
	_dgde.NvGraphicFramePr.CNvPr.NameAttr = "\u0043\u0068\u0061r\u0074"
	_dgde.Graphic = _fe.NewGraphic()
	_dgde.Graphic.GraphicData.UriAttr = "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074"
	_agfd := _ba.NewChart()
	_agfd.IdAttr = _gfab
	_dgde.Graphic.GraphicData.Any = []_d.Any{_agfd}
	_facg := _dee.MakeChart(_gbdb)
	_facg.Properties().SetSolidFill(_cg.White)
	_facg.SetDisplayBlanksAs(_ba.ST_DispBlanksAsGap)
	return _facg, _edb
}

// SetHeightCells is a no-op.
func (_ddb AbsoluteAnchor) SetHeightCells(int32) {}

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_bgff *Workbook) Save(w _ec.Writer) error {
	if !_gg.GetLicenseKey().IsLicensed() && !_bgab {
		_c.Println("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065")
		_c.Println("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
		return _gb.New("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064")
	}
	_ecgc := _aa.NewWriter(w)
	defer _ecgc.Close()
	_bada := _d.DocTypeSpreadsheet
	if _cdcba := _ad.MarshalXML(_ecgc, _d.BaseRelsFilename, _bgff.Rels.X()); _cdcba != nil {
		return _cdcba
	}
	if _bgfg := _ad.MarshalXMLByType(_ecgc, _bada, _d.ExtendedPropertiesType, _bgff.AppProperties.X()); _bgfg != nil {
		return _bgfg
	}
	if _dbca := _ad.MarshalXMLByType(_ecgc, _bada, _d.CorePropertiesType, _bgff.CoreProperties.X()); _dbca != nil {
		return _dbca
	}
	_gbce := _d.AbsoluteFilename(_bada, _d.OfficeDocumentType, 0)
	if _aceee := _ad.MarshalXML(_ecgc, _gbce, _bgff._bbae); _aceee != nil {
		return _aceee
	}
	if _gbef := _ad.MarshalXML(_ecgc, _ad.RelationsPathFor(_gbce), _bgff._adebd.X()); _gbef != nil {
		return _gbef
	}
	if _ggcba := _ad.MarshalXMLByType(_ecgc, _bada, _d.StylesType, _bgff.StyleSheet.X()); _ggcba != nil {
		return _ggcba
	}
	for _cgbf, _fce := range _bgff._bgea {
		if _adce := _ad.MarshalXMLByTypeIndex(_ecgc, _bada, _d.ThemeType, _cgbf+1, _fce); _adce != nil {
			return _adce
		}
	}
	for _cgdf, _ggbdc := range _bgff._fbed {
		_ggbdc.Dimension.RefAttr = Sheet{_bgff, nil, _ggbdc}.Extents()
		_gefg := _d.AbsoluteFilename(_bada, _d.WorksheetType, _cgdf+1)
		_ad.MarshalXML(_ecgc, _gefg, _ggbdc)
		_ad.MarshalXML(_ecgc, _ad.RelationsPathFor(_gefg), _bgff._fdbe[_cgdf].X())
	}
	if _defd := _ad.MarshalXMLByType(_ecgc, _bada, _d.SharedStringsType, _bgff.SharedStrings.X()); _defd != nil {
		return _defd
	}
	if _bgff.CustomProperties.X() != nil {
		if _gdga := _ad.MarshalXMLByType(_ecgc, _bada, _d.CustomPropertiesType, _bgff.CustomProperties.X()); _gdga != nil {
			return _gdga
		}
	}
	if _bgff.Thumbnail != nil {
		_bdga := _d.AbsoluteFilename(_bada, _d.ThumbnailType, 0)
		_gabf, _agcf := _ecgc.Create(_bdga)
		if _agcf != nil {
			return _agcf
		}
		if _eggc := _dg.Encode(_gabf, _bgff.Thumbnail, nil); _eggc != nil {
			return _eggc
		}
	}
	for _agca, _adec := range _bgff._fgcda {
		_gaaa := _d.AbsoluteFilename(_bada, _d.ChartType, _agca+1)
		_ad.MarshalXML(_ecgc, _gaaa, _adec)
	}
	for _fcdc, _abcc := range _bgff._caaa {
		_bbcf := _d.AbsoluteFilename(_bada, _d.TableType, _fcdc+1)
		_ad.MarshalXML(_ecgc, _bbcf, _abcc)
	}
	for _acgca, _aace := range _bgff._cefe {
		_aece := _d.AbsoluteFilename(_bada, _d.DrawingType, _acgca+1)
		_ad.MarshalXML(_ecgc, _aece, _aace)
		if !_bgff._fcbeb[_acgca].IsEmpty() {
			_ad.MarshalXML(_ecgc, _ad.RelationsPathFor(_aece), _bgff._fcbeb[_acgca].X())
		}
	}
	for _gabc, _gefc := range _bgff._cbbfe {
		_ad.MarshalXML(_ecgc, _d.AbsoluteFilename(_bada, _d.VMLDrawingType, _gabc+1), _gefc)
	}
	for _fbedc, _bbeg := range _bgff.Images {
		if _eccc := _cb.AddImageToZip(_ecgc, _bbeg, _fbedc+1, _d.DocTypeSpreadsheet); _eccc != nil {
			return _eccc
		}
	}
	if _cegd := _ad.MarshalXML(_ecgc, _d.ContentTypesFilename, _bgff.ContentTypes.X()); _cegd != nil {
		return _cegd
	}
	for _ceeb, _bebe := range _bgff._cbge {
		if _bebe == nil {
			continue
		}
		_ad.MarshalXML(_ecgc, _d.AbsoluteFilename(_bada, _d.CommentsType, _ceeb+1), _bebe)
	}
	if _cdcg := _bgff.WriteExtraFiles(_ecgc); _cdcg != nil {
		return _cdcg
	}
	return _ecgc.Close()
}

func (_dfcg PatternFill) SetBgColor(c _cg.Color) {
	_dfcg._aaac.BgColor = _ggd.NewCT_Color()
	_dfcg._aaac.BgColor.RgbAttr = c.AsRGBAString()
}

// SetConditionValue sets the condition value to be used for style applicaton.
func (_ecda ConditionalFormattingRule) SetConditionValue(v string) {
	_ecda._dbed.Formula = []string{v}
}

func (_cbcc Cell) getRawSortValue() (string, bool) {
	if _cbcc.HasFormula() {
		_gga := _cbcc.GetCachedFormulaResult()
		return _gga, _ga.IsNumber(_gga)
	}
	_cdga, _ := _cbcc.GetRawValue()
	return _cdga, _ga.IsNumber(_cdga)
}

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_ea CellStyle) NumberFormat() uint32 {
	if _ea._cae.NumFmtIdAttr == nil {
		return 0
	}
	return *_ea._cae.NumFmtIdAttr
}

// IsWindowLocked returns whether the workbook windows are locked.
func (_efda WorkbookProtection) IsWindowLocked() bool {
	return _efda._decb.LockWindowsAttr != nil && *_efda._decb.LockWindowsAttr
}

func NewPatternFill(fills *_ggd.CT_Fills) PatternFill {
	_agfa := _ggd.NewCT_Fill()
	_agfa.PatternFill = _ggd.NewCT_PatternFill()
	return PatternFill{_agfa.PatternFill, _agfa}
}

func (_afdc *Sheet) removeColumnFromNamedRanges(_egdg uint32) error {
	for _, _gadfd := range _afdc._bdb.DefinedNames() {
		_bcag := _gadfd.Name()
		_cdcb := _gadfd.Content()
		_gagf := _dgd.Split(_cdcb, "\u0021")
		if len(_gagf) != 2 {
			return _gb.New("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a" + _cdcb)
		}
		_cbag := _gagf[0]
		if _afdc.Name() == _cbag {
			_eccd := _afdc._bdb.RemoveDefinedName(_gadfd)
			if _eccd != nil {
				return _eccd
			}
			_ffgc := _cfab(_gagf[1], _egdg, true)
			if _ffgc != "" {
				_cgcd := _cbag + "\u0021" + _ffgc
				_afdc._bdb.AddDefinedName(_bcag, _cgcd)
			}
		}
	}
	_bcbg := 0
	if _afdc._bcgb.TableParts != nil && _afdc._bcgb.TableParts.TablePart != nil {
		_bcbg = len(_afdc._bcgb.TableParts.TablePart)
	}
	if _bcbg != 0 {
		_dgca := 0
		for _, _dacf := range _afdc._bdb.Sheets() {
			if _dacf.Name() == _afdc.Name() {
				break
			} else {
				if _dacf._bcgb.TableParts != nil && _dacf._bcgb.TableParts.TablePart != nil {
					_dgca += len(_dacf._bcgb.TableParts.TablePart)
				}
			}
		}
		_ccca := _afdc._bdb._caaa[_dgca : _dgca+_bcbg]
		for _edaf, _fcbe := range _ccca {
			_gbge := _fcbe
			_gbge.RefAttr = _cfab(_gbge.RefAttr, _egdg, false)
			_afdc._bdb._caaa[_dgca+_edaf] = _gbge
		}
	}
	return nil
}

func (_geg *evalContext) Sheet(name string) _aec.Context {
	for _, _cfg := range _geg._afdd._bdb.Sheets() {
		if _cfg.Name() == name {
			return _cfg.FormulaContext()
		}
	}
	return _aec.InvalidReferenceContext
}

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_efad *Workbook) Close() error {
	if _efad.TmpPath != "" {
		return _bb.RemoveAll(_efad.TmpPath)
	}
	return nil
}

// LockStructure controls the locking of the workbook structure.
func (_dabf WorkbookProtection) LockStructure(b bool) {
	if !b {
		_dabf._decb.LockStructureAttr = nil
	} else {
		_dabf._decb.LockStructureAttr = _d.Bool(true)
	}
}

// GetFormat returns a cell data format.
func (_gbff *evalContext) GetFormat(cellRef string) string {
	return _gbff._afdd.Cell(cellRef).getFormat()
}

func (_bfc Border) SetDiagonal(style _ggd.ST_BorderStyle, c _cg.Color, up, down bool) {
	if _bfc._aac.Diagonal == nil {
		_bfc._aac.Diagonal = _ggd.NewCT_BorderPr()
	}
	_bfc._aac.Diagonal.Color = _ggd.NewCT_Color()
	_bfc._aac.Diagonal.Color.RgbAttr = c.AsRGBAString()
	_bfc._aac.Diagonal.StyleAttr = style
	if up {
		_bfc._aac.DiagonalUpAttr = _d.Bool(true)
	}
	if down {
		_bfc._aac.DiagonalDownAttr = _d.Bool(true)
	}
}

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_agg Comment) SetCellReference(cellRef string) { _agg._gbfb.RefAttr = cellRef }

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_deaa Row) Cells() []Cell {
	_bgc := []Cell{}
	_fdfa := -1
	for _, _dag := range _deaa._dggg.C {
		if _dag.RAttr == nil {
			_d.Log("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e")
			continue
		}
		_gefb, _eadb := _eg.ParseCellReference(*_dag.RAttr)
		if _eadb != nil {
			_d.Log("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020" + *_dag.RAttr + ",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e")
			continue
		}
		_fbfd := int(_gefb.ColumnIdx)
		if _fbfd-_fdfa > 1 {
			for _abed := _fdfa + 1; _abed < _fbfd; _abed++ {
				_bgc = append(_bgc, _deaa.Cell(_eg.IndexToColumn(uint32(_abed))))
			}
		}
		_fdfa = _fbfd
		_bgc = append(_bgc, Cell{_deaa._fcba, _deaa._dafa, _deaa._dggg, _dag})
	}
	return _bgc
}

// SetMaxLength sets the maximum bar length in percent.
func (_dgg DataBarScale) SetMaxLength(l uint32) { _dgg._edfg.MaxLengthAttr = _d.Uint32(l) }

// AddFont adds a new empty font to the stylesheet.
func (_gefa StyleSheet) AddFont() Font {
	_fbgf := _ggd.NewCT_Font()
	_gefa._gcac.Fonts.Font = append(_gefa._gcac.Fonts.Font, _fbgf)
	_gefa._gcac.Fonts.CountAttr = _d.Uint32(uint32(len(_gefa._gcac.Fonts.Font)))
	return Font{_fbgf, _gefa._gcac}
}

// SetHeightCells is a no-op.
func (_gbe OneCellAnchor) SetHeightCells(int32) {}

// Row is a row within a spreadsheet.
type Row struct {
	_fcba *Workbook
	_dafa *Sheet
	_dggg *_ggd.CT_Row
}

// AddRun adds a new run of text to the cell.
func (_cbdc RichText) AddRun() RichTextRun {
	_cecg := _ggd.NewCT_RElt()
	_cbdc._begb.R = append(_cbdc._begb.R, _cecg)
	return RichTextRun{_cecg}
}

func (_ddgcd *Sheet) removeColumnFromMergedCells(_fbbca uint32) error {
	if _ddgcd._bcgb.MergeCells == nil || _ddgcd._bcgb.MergeCells.MergeCell == nil {
		return nil
	}
	_bfeb := []*_ggd.CT_MergeCell{}
	for _, _fcad := range _ddgcd.MergedCells() {
		_cbad := _cfab(_fcad.Reference(), _fbbca, true)
		if _cbad != "" {
			_fcad.SetReference(_cbad)
			_bfeb = append(_bfeb, _fcad.X())
		}
	}
	_ddgcd._bcgb.MergeCells.MergeCell = _bfeb
	return nil
}

// SetPassword sets the password hash to a hash of the input password.
func (_dcdg WorkbookProtection) SetPassword(pw string) { _dcdg.SetPasswordHash(PasswordHash(pw)) }

// ClearAutoFilter removes the autofilters from the sheet.
func (_dagc *Sheet) ClearAutoFilter() {
	_dagc._bcgb.AutoFilter = nil
	_agd := "\u0027" + _dagc.Name() + "\u0027\u0021"
	for _, _bcad := range _dagc._bdb.DefinedNames() {
		if _bcad.Name() == _aaag {
			if _dgd.HasPrefix(_bcad.Content(), _agd) {
				_dagc._bdb.RemoveDefinedName(_bcad)
				break
			}
		}
	}
}

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{ _cd *_ce.CT_AbsoluteAnchor }

// Type returns the type of the rule
func (_ccfb ConditionalFormattingRule) Type() _ggd.ST_CfType { return _ccfb._dbed.TypeAttr }

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{ _eccb *_ggd.CT_Col }

func (_cdae PatternFill) X() *_ggd.CT_PatternFill { return _cdae._aaac }

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte

func (_agfg *Sheet) setArray(_ccagc string, _gfda _aec.Result) error {
	_afg, _bcdg := _eg.ParseCellReference(_ccagc)
	if _bcdg != nil {
		return _bcdg
	}
	for _dbbd, _dbeb := range _gfda.ValueArray {
		_cbga := _agfg.Row(_afg.RowIdx + uint32(_dbbd))
		for _ggff, _gdce := range _dbeb {
			_cbfag := _cbga.Cell(_eg.IndexToColumn(_afg.ColumnIdx + uint32(_ggff)))
			if _gdce.Type != _aec.ResultTypeEmpty {
				if _gdce.IsBoolean {
					_cbfag.SetBool(_gdce.ValueNumber != 0)
				} else {
					_cbfag.SetCachedFormulaResult(_gdce.String())
				}
			}
		}
	}
	return nil
}

const (
	StandardFormatGeneral     StandardFormat = 0
	StandardFormat0           StandardFormat = 0
	StandardFormatWholeNumber StandardFormat = 1
	StandardFormat1           StandardFormat = 1
	StandardFormat2           StandardFormat = 2
	StandardFormat3           StandardFormat = 3
	StandardFormat4           StandardFormat = 4
	StandardFormatPercent     StandardFormat = 9
	StandardFormat9           StandardFormat = 9
	StandardFormat10          StandardFormat = 10
	StandardFormat11          StandardFormat = 11
	StandardFormat12          StandardFormat = 12
	StandardFormat13          StandardFormat = 13
	StandardFormatDate        StandardFormat = 14
	StandardFormat14          StandardFormat = 14
	StandardFormat15          StandardFormat = 15
	StandardFormat16          StandardFormat = 16
	StandardFormat17          StandardFormat = 17
	StandardFormat18          StandardFormat = 18
	StandardFormatTime        StandardFormat = 19
	StandardFormat19          StandardFormat = 19
	StandardFormat20          StandardFormat = 20
	StandardFormat21          StandardFormat = 21
	StandardFormatDateTime    StandardFormat = 22
	StandardFormat22          StandardFormat = 22
	StandardFormat37          StandardFormat = 37
	StandardFormat38          StandardFormat = 38
	StandardFormat39          StandardFormat = 39
	StandardFormat40          StandardFormat = 40
	StandardFormat45          StandardFormat = 45
	StandardFormat46          StandardFormat = 46
	StandardFormat47          StandardFormat = 47
	StandardFormat48          StandardFormat = 48
	StandardFormat49          StandardFormat = 49
)

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings() SharedStrings {
	return SharedStrings{_gce: _ggd.NewSst(), _daff: make(map[string]int)}
}

func (_gde *Sheet) setShared(_acgc string, _egbg, _cecb _eg.CellReference, _bddfd string) {
	_accc := _gde.FormulaContext()
	_aafbf := _aec.NewEvaluator()
	for _egae := _egbg.RowIdx; _egae <= _cecb.RowIdx; _egae++ {
		for _ccfg := _egbg.ColumnIdx; _ccfg <= _cecb.ColumnIdx; _ccfg++ {
			_dced := _egae - _egbg.RowIdx
			_cacc := _ccfg - _egbg.ColumnIdx
			_accc.SetOffset(_cacc, _dced)
			_egba := _aafbf.Eval(_accc, _bddfd)
			_bfbf := _c.Sprintf("\u0025\u0073\u0025\u0064", _eg.IndexToColumn(_ccfg), _egae)
			_facec := _gde.Cell(_bfbf)
			if _egba.Type == _aec.ResultTypeNumber {
				_facec.X().TAttr = _ggd.ST_CellTypeN
			} else {
				_facec.X().TAttr = _ggd.ST_CellTypeInlineStr
			}
			_facec.X().V = _d.String(_egba.Value())
		}
	}
	_ = _aafbf
	_ = _accc
}

// SetAllowBlank controls if blank values are accepted.
func (_fda DataValidation) SetAllowBlank(b bool) {
	if !b {
		_fda._fcc.AllowBlankAttr = nil
	} else {
		_fda._fcc.AllowBlankAttr = _d.Bool(true)
	}
}

// SetStyle sets the cell style for an entire column.
func (_deb Column) SetStyle(cs CellStyle) { _deb._eccb.StyleAttr = _d.Uint32(cs.Index()) }

func (_adg Cell) clearValue() {
	_adg._dbd.F = nil
	_adg._dbd.Is = nil
	_adg._dbd.V = nil
	_adg._dbd.TAttr = _ggd.ST_CellTypeUnset
}

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_fee *Sheet) ClearSheetViews() { _fee._bcgb.SheetViews = nil }

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_fcda *evalContext) GetLabelPrefix(cellRef string) string {
	return _fcda._afdd.Cell(cellRef).getLabelPrefix()
}

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_dacg DataValidationCompare) SetValue(v string) { _dacg._fefg.Formula1 = &v }

func (_fdd Border) SetTop(style _ggd.ST_BorderStyle, c _cg.Color) {
	if _fdd._aac.Top == nil {
		_fdd._aac.Top = _ggd.NewCT_BorderPr()
	}
	_fdd._aac.Top.Color = _ggd.NewCT_Color()
	_fdd._aac.Top.Color.RgbAttr = c.AsRGBAString()
	_fdd._aac.Top.StyleAttr = style
}

func CreateDefaultNumberFormat(id StandardFormat) NumberFormat {
	_ged := NumberFormat{_geef: _ggd.NewCT_NumFmt()}
	_ged._geef.NumFmtIdAttr = uint32(id)
	_ged._geef.FormatCodeAttr = "\u0047e\u006e\u0065\u0072\u0061\u006c"
	switch id {
	case StandardFormat0:
		_ged._geef.FormatCodeAttr = "\u0047e\u006e\u0065\u0072\u0061\u006c"
	case StandardFormat1:
		_ged._geef.FormatCodeAttr = "\u0030"
	case StandardFormat2:
		_ged._geef.FormatCodeAttr = "\u0030\u002e\u0030\u0030"
	case StandardFormat3:
		_ged._geef.FormatCodeAttr = "\u0023\u002c\u0023#\u0030"
	case StandardFormat4:
		_ged._geef.FormatCodeAttr = "\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030"
	case StandardFormat9:
		_ged._geef.FormatCodeAttr = "\u0030\u0025"
	case StandardFormat10:
		_ged._geef.FormatCodeAttr = "\u0030\u002e\u00300\u0025"
	case StandardFormat11:
		_ged._geef.FormatCodeAttr = "\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030"
	case StandardFormat12:
		_ged._geef.FormatCodeAttr = "\u0023\u0020\u003f/\u003f"
	case StandardFormat13:
		_ged._geef.FormatCodeAttr = "\u0023 \u003f\u003f\u002f\u003f\u003f"
	case StandardFormat14:
		_ged._geef.FormatCodeAttr = "\u006d\u002f\u0064\u002f\u0079\u0079"
	case StandardFormat15:
		_ged._geef.FormatCodeAttr = "\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079"
	case StandardFormat16:
		_ged._geef.FormatCodeAttr = "\u0064\u002d\u006dm\u006d"
	case StandardFormat17:
		_ged._geef.FormatCodeAttr = "\u006d\u006d\u006d\u002d\u0079\u0079"
	case StandardFormat18:
		_ged._geef.FormatCodeAttr = "\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d"
	case StandardFormat19:
		_ged._geef.FormatCodeAttr = "\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d"
	case StandardFormat20:
		_ged._geef.FormatCodeAttr = "\u0068\u003a\u006d\u006d"
	case StandardFormat21:
		_ged._geef.FormatCodeAttr = "\u0068:\u006d\u006d\u003a\u0073\u0073"
	case StandardFormat22:
		_ged._geef.FormatCodeAttr = "m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d"
	case StandardFormat37:
		_ged._geef.FormatCodeAttr = "\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029"
	case StandardFormat38:
		_ged._geef.FormatCodeAttr = "\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029"
	case StandardFormat39:
		_ged._geef.FormatCodeAttr = "\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029"
	case StandardFormat40:
		_ged._geef.FormatCodeAttr = "\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029"
	case StandardFormat45:
		_ged._geef.FormatCodeAttr = "\u006d\u006d\u003as\u0073"
	case StandardFormat46:
		_ged._geef.FormatCodeAttr = "\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s"
	case StandardFormat47:
		_ged._geef.FormatCodeAttr = "\u006dm\u003a\u0073\u0073\u002e\u0030"
	case StandardFormat48:
		_ged._geef.FormatCodeAttr = "\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030"
	case StandardFormat49:
		_ged._geef.FormatCodeAttr = "\u0040"
	}
	return _ged
}

// Comments returns the list of comments for this sheet
func (_afe Comments) Comments() []Comment {
	_fg := []Comment{}
	for _, _gdc := range _afe._fcd.CommentList.Comment {
		_fg = append(_fg, Comment{_afe._aeff, _gdc, _afe._fcd})
	}
	return _fg
}

func (_dece Sheet) IsValid() bool { return _dece._bcgb != nil }

// Cell returns the actual cell behind the merged region
func (_bggb MergedCell) Cell() Cell {
	_eebb := _bggb.Reference()
	if _bccc := _dgd.Index(_bggb.Reference(), "\u003a"); _bccc != -1 {
		_eebb = _eebb[0:_bccc]
		return _bggb._bdfc.Cell(_eebb)
	}
	return Cell{}
}

func (_egdcd *Workbook) ensureSharedStringsRelationships() {
	_ecdab := false
	for _, _fcff := range _egdcd.ContentTypes.X().Override {
		if _fcff.ContentTypeAttr == _d.SharedStringsContentType {
			_ecdab = true
			break
		}
	}
	if !_ecdab {
		_egdcd.ContentTypes.AddOverride(_accg, _d.SharedStringsContentType)
	}
	_ecfb := false
	for _, _faec := range _egdcd._adebd.Relationships() {
		if _faec.X().TargetAttr == _edeb {
			_ecfb = true
			break
		}
	}
	if !_ecfb {
		_egdcd._adebd.AddRelationship(_edeb, _d.SharedStringsType)
	}
}

// IsSheetLocked returns whether the sheet is locked.
func (_eeba SheetProtection) IsSheetLocked() bool {
	return _eeba._bcef.SheetAttr != nil && *_eeba._bcef.SheetAttr
}

// PasswordHash returns the hash of the workbook password.
func (_ffbb WorkbookProtection) PasswordHash() string {
	if _ffbb._decb.WorkbookPasswordAttr == nil {
		return ""
	}
	return *_ffbb._decb.WorkbookPasswordAttr
}

// TopLeft returns the top-left corner of the anchored object.
func (_adcc OneCellAnchor) TopLeft() CellMarker { return CellMarker{_adcc._bbaac.From} }

func _cde(_aaf _dga.Time) _dga.Time {
	_aaf = _aaf.Local()
	return _dga.Date(_aaf.Year(), _aaf.Month(), _aaf.Day(), _aaf.Hour(), _aaf.Minute(), _aaf.Second(), _aaf.Nanosecond(), _dga.UTC)
}

// Name returns the sheet name
func (_edcb Sheet) Name() string { return _edcb._adae.NameAttr }

// Read reads a workbook from an io.Reader(.xlsx).
func Read(r _ec.ReaderAt, size int64) (*Workbook, error) {
	_gdde := New()
	_faff, _ddde := _bb.TempDir("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078")
	if _ddde != nil {
		return nil, _ddde
	}
	_gdde.TmpPath = _faff
	_cgad, _ddde := _aa.NewReader(r, size)
	if _ddde != nil {
		return nil, _c.Errorf("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073", _ddde)
	}
	_beg := []*_aa.File{}
	_beg = append(_beg, _cgad.File...)
	_cba := false
	for _, _cbff := range _beg {
		if _cbff.FileHeader.Name == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
			_cba = true
			break
		}
	}
	if _cba {
		_gdde.createCustomProperties()
	}
	_gag := _ad.DecodeMap{}
	_gag.SetOnNewRelationshipFunc(_gdde.onNewRelationship)
	_gag.AddTarget(_d.ContentTypesFilename, _gdde.ContentTypes.X(), "", 0)
	_gag.AddTarget(_d.BaseRelsFilename, _gdde.Rels.X(), "", 0)
	if _cff := _gag.Decode(_beg); _cff != nil {
		return nil, _cff
	}
	for _, _face := range _beg {
		if _face == nil {
			continue
		}
		if _egd := _gdde.AddExtraFileFromZip(_face); _egd != nil {
			return nil, _egd
		}
	}
	if _cba {
		_bccb := false
		for _, _bcbb := range _gdde.Rels.X().Relationship {
			if _bcbb.TargetAttr == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
				_bccb = true
				break
			}
		}
		if !_bccb {
			_gdde.addCustomRelationships()
		}
	}
	return _gdde, nil
}

// DefinedNames returns a slice of all defined names in the workbook.
func (_ecgg *Workbook) DefinedNames() []DefinedName {
	if _ecgg._bbae.DefinedNames == nil {
		return nil
	}
	_edecb := []DefinedName{}
	for _, _eaec := range _ecgg._bbae.DefinedNames.DefinedName {
		_edecb = append(_edecb, DefinedName{_eaec})
	}
	return _edecb
}

func _gcd(_gfg _dga.Time) _dga.Time {
	_gfg = _gfg.UTC()
	return _dga.Date(_gfg.Year(), _gfg.Month(), _gfg.Day(), _gfg.Hour(), _gfg.Minute(), _gfg.Second(), _gfg.Nanosecond(), _dga.Local)
}

const (
	_gbfc = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034"
	_fgdf = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065"
	_dbeg = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030"
	_fecb = "\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039"
)

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_dbace StyleSheet) Fills() Fills { return Fills{_dbace._gcac.Fills} }

func (_ggb ConditionalFormattingRule) clear() {
	_ggb._dbed.OperatorAttr = _ggd.ST_ConditionalFormattingOperatorUnset
	_ggb._dbed.ColorScale = nil
	_ggb._dbed.IconSet = nil
	_ggb._dbed.Formula = nil
}

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_agab *Workbook) AddDefinedName(name, ref string) DefinedName {
	if _agab._bbae.DefinedNames == nil {
		_agab._bbae.DefinedNames = _ggd.NewCT_DefinedNames()
	}
	_gcea := _ggd.NewCT_DefinedName()
	_gcea.Content = ref
	_gcea.NameAttr = name
	_agab._bbae.DefinedNames.DefinedName = append(_agab._bbae.DefinedNames.DefinedName, _gcea)
	return DefinedName{_gcea}
}

// Validate attempts to validate the structure of a workbook.
func (_egca *Workbook) Validate() error {
	if _egca == nil || _egca._bbae == nil {
		return _gb.New("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065")
	}
	_faab := uint32(0)
	for _, _cagc := range _egca._bbae.Sheets.Sheet {
		if _cagc.SheetIdAttr > _faab {
			_faab = _cagc.SheetIdAttr
		}
	}
	if _faab != uint32(len(_egca._fbed)) {
		return _c.Errorf("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073", _faab, len(_egca._fbed))
	}
	_ecac := map[string]struct{}{}
	for _bace, _cfdb := range _egca._bbae.Sheets.Sheet {
		_gdfg := Sheet{_egca, _cfdb, _egca._fbed[_bace]}
		if _, _beae := _ecac[_gdfg.Name()]; _beae {
			return _c.Errorf("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027", _bace, _gdfg.Name())
		}
		_ecac[_gdfg.Name()] = struct{}{}
		if _aeec := _gdfg.ValidateWithPath(_c.Sprintf("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d", _bace)); _aeec != nil {
			return _aeec
		}
		if _aeaf := _gdfg.Validate(); _aeaf != nil {
			return _aeaf
		}
	}
	return nil
}

func (_cdd *Sheet) addNumberedRowFast(_gfe uint32) Row {
	_ffgb := _ggd.NewCT_Row()
	_ffgb.RAttr = _d.Uint32(_gfe)
	_cdd._bcgb.SheetData.Row = append(_cdd._bcgb.SheetData.Row, _ffgb)
	return Row{_cdd._bdb, _cdd, _ffgb}
}

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_facgb *Sheet) RemoveColumn(column string) error {
	_bfbb, _dacc := _facgb.getAllCellsInFormulaArraysForColumn()
	if _dacc != nil {
		return _dacc
	}
	_fgfg := _eg.ColumnToIndex(column)
	for _, _cdgg := range _facgb.Rows() {
		_ebfa := _c.Sprintf("\u0025\u0073\u0025\u0064", column, *_cdgg.X().RAttr)
		if _, _acbb := _bfbb[_ebfa]; _acbb {
			return nil
		}
	}
	for _, _cfed := range _facgb.Rows() {
		_gece := _cfed._dggg.C
		for _agecb, _ffcd := range _gece {
			_bacd, _egcge := _eg.ParseCellReference(*_ffcd.RAttr)
			if _egcge != nil {
				return _egcge
			}
			if _bacd.ColumnIdx == _fgfg {
				_cfed._dggg.C = append(_gece[:_agecb], _facgb.slideCellsLeft(_gece[_agecb+1:])...)
				break
			} else if _bacd.ColumnIdx > _fgfg {
				_cfed._dggg.C = append(_gece[:_agecb], _facgb.slideCellsLeft(_gece[_agecb:])...)
				break
			}
		}
	}
	_dacc = _facgb.updateAfterRemove(_fgfg, _gaf.UpdateActionRemoveColumn)
	if _dacc != nil {
		return _dacc
	}
	_dacc = _facgb.removeColumnFromNamedRanges(_fgfg)
	if _dacc != nil {
		return _dacc
	}
	_dacc = _facgb.removeColumnFromMergedCells(_fgfg)
	if _dacc != nil {
		return _dacc
	}
	for _, _aagc := range _facgb._bdb.Sheets() {
		_aagc.RecalculateFormulas()
	}
	return nil
}

// AddBorder creates a new empty border that can be applied to a cell style.
func (_fbfb StyleSheet) AddBorder() Border {
	_begbg := _ggd.NewCT_Border()
	_fbfb._gcac.Borders.Border = append(_fbfb._gcac.Borders.Border, _begbg)
	_fbfb._gcac.Borders.CountAttr = _d.Uint32(uint32(len(_fbfb._gcac.Borders.Border)))
	return Border{_begbg, _fbfb._gcac.Borders}
}

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_cggc SheetView) SetState(st _ggd.ST_PaneState) {
	_cggc.ensurePane()
	_cggc._baef.Pane.StateAttr = st
}

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_ebgc *Sheet) SetBorder(cellRange string, border Border) error {
	_edcc, _ggdg, _ebgf := _eg.ParseRangeReference(cellRange)
	if _ebgf != nil {
		return _ebgf
	}
	_adefd := _ebgc._bdb.StyleSheet.AddCellStyle()
	_fdge := _ebgc._bdb.StyleSheet.AddBorder()
	_adefd.SetBorder(_fdge)
	_fdge._aac.Top = border._aac.Top
	_fdge._aac.Left = border._aac.Left
	_dcaa := _ebgc._bdb.StyleSheet.AddCellStyle()
	_fdb := _ebgc._bdb.StyleSheet.AddBorder()
	_dcaa.SetBorder(_fdb)
	_fdb._aac.Top = border._aac.Top
	_fdb._aac.Right = border._aac.Right
	_fccd := _ebgc._bdb.StyleSheet.AddCellStyle()
	_beaff := _ebgc._bdb.StyleSheet.AddBorder()
	_fccd.SetBorder(_beaff)
	_beaff._aac.Top = border._aac.Top
	_ccaf := _ebgc._bdb.StyleSheet.AddCellStyle()
	_fdef := _ebgc._bdb.StyleSheet.AddBorder()
	_ccaf.SetBorder(_fdef)
	_fdef._aac.Left = border._aac.Left
	_dbcfc := _ebgc._bdb.StyleSheet.AddCellStyle()
	_ddfe := _ebgc._bdb.StyleSheet.AddBorder()
	_dbcfc.SetBorder(_ddfe)
	_ddfe._aac.Right = border._aac.Right
	_fabf := _ebgc._bdb.StyleSheet.AddCellStyle()
	_ccbee := _ebgc._bdb.StyleSheet.AddBorder()
	_fabf.SetBorder(_ccbee)
	_ccbee._aac.Bottom = border._aac.Bottom
	_dfgb := _ebgc._bdb.StyleSheet.AddCellStyle()
	_fbdb := _ebgc._bdb.StyleSheet.AddBorder()
	_dfgb.SetBorder(_fbdb)
	_fbdb._aac.Bottom = border._aac.Bottom
	_fbdb._aac.Left = border._aac.Left
	_baed := _ebgc._bdb.StyleSheet.AddCellStyle()
	_fbbc := _ebgc._bdb.StyleSheet.AddBorder()
	_baed.SetBorder(_fbbc)
	_fbbc._aac.Bottom = border._aac.Bottom
	_fbbc._aac.Right = border._aac.Right
	_acee := _edcc.RowIdx
	_gebb := _edcc.ColumnIdx
	_dda := _ggdg.RowIdx
	_debaf := _ggdg.ColumnIdx
	for _dcce := _acee; _dcce <= _dda; _dcce++ {
		for _adad := _gebb; _adad <= _debaf; _adad++ {
			_fddf := _c.Sprintf("\u0025\u0073\u0025\u0064", _eg.IndexToColumn(_adad), _dcce)
			switch {
			case _dcce == _acee && _adad == _gebb:
				_ebgc.Cell(_fddf).SetStyle(_adefd)
			case _dcce == _acee && _adad == _debaf:
				_ebgc.Cell(_fddf).SetStyle(_dcaa)
			case _dcce == _dda && _adad == _gebb:
				_ebgc.Cell(_fddf).SetStyle(_dfgb)
			case _dcce == _dda && _adad == _debaf:
				_ebgc.Cell(_fddf).SetStyle(_baed)
			case _dcce == _acee:
				_ebgc.Cell(_fddf).SetStyle(_fccd)
			case _dcce == _dda:
				_ebgc.Cell(_fddf).SetStyle(_fabf)
			case _adad == _gebb:
				_ebgc.Cell(_fddf).SetStyle(_ccaf)
			case _adad == _debaf:
				_ebgc.Cell(_fddf).SetStyle(_dbcfc)
			}
		}
	}
	return nil
}

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gcab *Sheet) RecalculateFormulas() {
	_bfbd := _aec.NewEvaluator()
	_fedc := _gcab.FormulaContext()
	for _, _cdca := range _gcab.Rows() {
		for _, _fgbc := range _cdca.Cells() {
			if _fgbc.X().F != nil {
				_gdba := _fgbc.X().F.Content
				if _fgbc.X().F.TAttr == _ggd.ST_CellFormulaTypeShared && len(_gdba) == 0 {
					continue
				}
				_bgcb := _bfbd.Eval(_fedc, _gdba).AsString()
				if _bgcb.Type == _aec.ResultTypeError {
					_d.Log("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073", _gdba, _bgcb.ErrorMessage)
					_fgbc.X().V = nil
				} else {
					if _bgcb.Type == _aec.ResultTypeNumber {
						_fgbc.X().TAttr = _ggd.ST_CellTypeN
					} else {
						_fgbc.X().TAttr = _ggd.ST_CellTypeInlineStr
					}
					_fgbc.X().V = _d.String(_bgcb.Value())
					if _fgbc.X().F.TAttr == _ggd.ST_CellFormulaTypeArray {
						if _bgcb.Type == _aec.ResultTypeArray {
							_gcab.setArray(_fgbc.Reference(), _bgcb)
						} else if _bgcb.Type == _aec.ResultTypeList {
							_gcab.setList(_fgbc.Reference(), _bgcb)
						}
					} else if _fgbc.X().F.TAttr == _ggd.ST_CellFormulaTypeShared && _fgbc.X().F.RefAttr != nil {
						_fdedf, _gdcf, _efbd := _eg.ParseRangeReference(*_fgbc.X().F.RefAttr)
						if _efbd != nil {
							_g.Printf("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073", _efbd)
							continue
						}
						_gcab.setShared(_fgbc.Reference(), _fdedf, _gdcf, _gdba)
					}
				}
			}
		}
	}
}

// MoveTo moves the top-left of the anchored object.
func (_caba OneCellAnchor) MoveTo(col, row int32) {
	_caba.TopLeft().SetCol(col)
	_caba.TopLeft().SetRow(row)
}

func (_bafg Font) SetBold(b bool) {
	if b {
		_bafg._beba.B = []*_ggd.CT_BooleanProperty{{}}
	} else {
		_bafg._beba.B = nil
	}
}

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_cgeb *Workbook) RemoveCalcChain() {
	var _gffc string
	for _, _gceg := range _cgeb._adebd.Relationships() {
		if _gceg.Type() == "ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e" {
			_gffc = "\u0078\u006c\u002f" + _gceg.Target()
			_cgeb._adebd.Remove(_gceg)
			break
		}
	}
	if _gffc == "" {
		return
	}
	_cgeb.ContentTypes.RemoveOverride(_gffc)
	for _eeab, _ebacd := range _cgeb.ExtraFiles {
		if _ebacd.ZipPath == _gffc {
			_cgeb.ExtraFiles[_eeab] = _cgeb.ExtraFiles[len(_cgeb.ExtraFiles)-1]
			_cgeb.ExtraFiles = _cgeb.ExtraFiles[:len(_cgeb.ExtraFiles)-1]
			return
		}
	}
}

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct {
	_cb.DocBase
	_bbae         *_ggd.Workbook
	StyleSheet    StyleSheet
	SharedStrings SharedStrings
	_cbge         []*_ggd.Comments
	_fbed         []*_ggd.Worksheet
	_fdbe         []_cb.Relationships
	_adebd        _cb.Relationships
	_bgea         []*_fe.Theme
	_cefe         []*_ce.WsDr
	_fcbeb        []_cb.Relationships
	_cbbfe        []*_cc.Container
	_fgcda        []*_ba.ChartSpace
	_caaa         []*_ggd.Table
	_bbeed        string
}

// MaxColumnIdx returns the max used column of the sheet.
func (_bgca Sheet) MaxColumnIdx() uint32 {
	_cfeg := uint32(0)
	for _, _eed := range _bgca.Rows() {
		_dgef := _eed._dggg.C
		if len(_dgef) > 0 {
			_aggba := _dgef[len(_dgef)-1]
			_ggab, _ := _eg.ParseCellReference(*_aggba.RAttr)
			if _cfeg < _ggab.ColumnIdx {
				_cfeg = _ggab.ColumnIdx
			}
		}
	}
	return _cfeg
}

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_cab Drawing) AddImage(img _cb.ImageRef, at AnchorType) Anchor {
	_bff := 0
	for _cabe, _afb := range _cab._debc.Images {
		if _afb == img {
			_bff = _cabe + 1
			break
		}
	}
	var _badb string
	for _ceg, _aaege := range _cab._debc._cefe {
		if _aaege == _cab._fefc {
			_ccbfb := _c.Sprintf("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", _bff, img.Format())
			_aba := _cab._debc._fcbeb[_ceg].AddRelationship(_ccbfb, _d.ImageType)
			_badb = _aba.ID()
			break
		}
	}
	var _adeb Anchor
	var _dcg *_ce.CT_Picture
	switch at {
	case AnchorTypeAbsolute:
		_ebga := _cdf()
		_cab._fefc.EG_Anchor = append(_cab._fefc.EG_Anchor, &_ce.EG_Anchor{AbsoluteAnchor: _ebga})
		_ebga.Choice = &_ce.EG_ObjectChoicesChoice{}
		_ebga.Choice.Pic = _ce.NewCT_Picture()
		_dcg = _ebga.Choice.Pic
		_adeb = AbsoluteAnchor{_ebga}
	case AnchorTypeOneCell:
		_bgbd := _gbga()
		_cab._fefc.EG_Anchor = append(_cab._fefc.EG_Anchor, &_ce.EG_Anchor{OneCellAnchor: _bgbd})
		_bgbd.Choice = &_ce.EG_ObjectChoicesChoice{}
		_bgbd.Choice.Pic = _ce.NewCT_Picture()
		_dcg = _bgbd.Choice.Pic
		_adeb = OneCellAnchor{_bgbd}
	case AnchorTypeTwoCell:
		_fde := _fafc()
		_cab._fefc.EG_Anchor = append(_cab._fefc.EG_Anchor, &_ce.EG_Anchor{TwoCellAnchor: _fde})
		_fde.Choice = &_ce.EG_ObjectChoicesChoice{}
		_fde.Choice.Pic = _ce.NewCT_Picture()
		_dcg = _fde.Choice.Pic
		_adeb = TwoCellAnchor{_fde}
	}
	_dcg.NvPicPr.CNvPr.IdAttr = uint32(len(_cab._fefc.EG_Anchor))
	_dcg.NvPicPr.CNvPr.NameAttr = "\u0049\u006d\u0061g\u0065"
	_dcg.BlipFill.Blip = _fe.NewCT_Blip()
	_dcg.BlipFill.Blip.EmbedAttr = _d.String(_badb)
	_dcg.BlipFill.Stretch = _fe.NewCT_StretchInfoProperties()
	_dcg.SpPr = _fe.NewCT_ShapeProperties()
	_dcg.SpPr.Xfrm = _fe.NewCT_Transform2D()
	_dcg.SpPr.Xfrm.Off = _fe.NewCT_Point2D()
	_dcg.SpPr.Xfrm.Off.XAttr.ST_CoordinateUnqualified = _d.Int64(0)
	_dcg.SpPr.Xfrm.Off.YAttr.ST_CoordinateUnqualified = _d.Int64(0)
	_dcg.SpPr.Xfrm.Ext = _fe.NewCT_PositiveSize2D()
	_dcg.SpPr.Xfrm.Ext.CxAttr = int64(float64(img.Size().X*_ae.Pixel72) / _ae.EMU)
	_dcg.SpPr.Xfrm.Ext.CyAttr = int64(float64(img.Size().Y*_ae.Pixel72) / _ae.EMU)
	_dcg.SpPr.PrstGeom = _fe.NewCT_PresetGeometry2D()
	_dcg.SpPr.PrstGeom.PrstAttr = _fe.ST_ShapeTypeRect
	_dcg.SpPr.Ln = _fe.NewCT_LineProperties()
	_dcg.SpPr.Ln.NoFill = _fe.NewCT_NoFillProperties()
	return _adeb
}

func _cfab(_cafb string, _cbca uint32, _bebb bool) string {
	_aggfa, _fbfc, _abee := _eg.ParseRangeReference(_cafb)
	if _abee == nil {
		_bgeb, _bbbb := _aggfa.ColumnIdx, _fbfc.ColumnIdx
		if _cbca >= _bgeb && _cbca <= _bbbb {
			if _bgeb == _bbbb {
				if _bebb {
					return ""
				} else {
					return _cafb
				}
			} else {
				_feggg := _fbfc.Update(_gaf.UpdateActionRemoveColumn)
				return _c.Sprintf("\u0025\u0073\u003a%\u0073", _aggfa.String(), _feggg.String())
			}
		} else if _cbca < _bgeb {
			_bfd := _aggfa.Update(_gaf.UpdateActionRemoveColumn)
			_aaef := _fbfc.Update(_gaf.UpdateActionRemoveColumn)
			return _c.Sprintf("\u0025\u0073\u003a%\u0073", _bfd.String(), _aaef.String())
		}
	} else {
		_dcfb, _debag, _gbac := _eg.ParseColumnRangeReference(_cafb)
		if _gbac != nil {
			return ""
		}
		_gbde, _feeg := _dcfb.ColumnIdx, _debag.ColumnIdx
		if _cbca >= _gbde && _cbca <= _feeg {
			if _gbde == _feeg {
				if _bebb {
					return ""
				} else {
					return _cafb
				}
			} else {
				_cefb := _debag.Update(_gaf.UpdateActionRemoveColumn)
				return _c.Sprintf("\u0025\u0073\u003a%\u0073", _dcfb.String(), _cefb.String())
			}
		} else if _cbca < _gbde {
			_caeea := _dcfb.Update(_gaf.UpdateActionRemoveColumn)
			_dgeg := _debag.Update(_gaf.UpdateActionRemoveColumn)
			return _c.Sprintf("\u0025\u0073\u003a%\u0073", _caeea.String(), _dgeg.String())
		}
	}
	return ""
}

func (_agb Font) SetSize(size float64) { _agb._beba.Sz = []*_ggd.CT_FontSize{{ValAttr: size}} }

// PasswordHash returns the hash of the workbook password.
func (_eegf SheetProtection) PasswordHash() string {
	if _eegf._bcef.PasswordAttr == nil {
		return ""
	}
	return *_eegf._bcef.PasswordAttr
}

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_ddfg *Workbook) GetFilename() string { return _ddfg._bbeed }

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_deed StyleSheet) AddNumberFormat() NumberFormat {
	if _deed._gcac.NumFmts == nil {
		_deed._gcac.NumFmts = _ggd.NewCT_NumFmts()
	}
	_gege := _ggd.NewCT_NumFmt()
	_gege.NumFmtIdAttr = uint32(200 + len(_deed._gcac.NumFmts.NumFmt))
	_deed._gcac.NumFmts.NumFmt = append(_deed._gcac.NumFmts.NumFmt, _gege)
	_deed._gcac.NumFmts.CountAttr = _d.Uint32(uint32(len(_deed._gcac.NumFmts.NumFmt)))
	return NumberFormat{_deed._cecga, _gege}
}

// X returns the inner wrapped XML type.
func (_ebab RichText) X() *_ggd.CT_Rst { return _ebab._begb }

// IsSheetLocked returns whether the sheet objects are locked.
func (_cadf SheetProtection) IsObjectLocked() bool {
	return _cadf._bcef.ObjectsAttr != nil && *_cadf._bcef.ObjectsAttr
}

// CellStyle is a formatting style for a cell.  CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct {
	_aaeg *Workbook
	_cae  *_ggd.CT_Xf
	_ggf  *_ggd.CT_CellXfs
}

const _aaag = "_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065"

// X returns the inner wrapped XML type.
func (_fa Cell) X() *_ggd.CT_Cell { return _fa._dbd }

func (_bbbc PatternFill) ClearFgColor() { _bbbc._aaac.FgColor = nil }

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{ _aggb *_ggd.CT_RElt }

func (_ddd Border) SetRight(style _ggd.ST_BorderStyle, c _cg.Color) {
	if _ddd._aac.Right == nil {
		_ddd._aac.Right = _ggd.NewCT_BorderPr()
	}
	_ddd._aac.Right.Color = _ggd.NewCT_Color()
	_ddd._aac.Right.Color.RgbAttr = c.AsRGBAString()
	_ddd._aac.Right.StyleAttr = style
}

type MergedCell struct {
	_fgdg *Workbook
	_bdfc *Sheet
	_ddge *_ggd.CT_MergeCell
}

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte

// RowOffset returns the offset from the row cell.
func (_abg CellMarker) RowOffset() _ae.Distance {
	if _abg._bcb.RowOff.ST_CoordinateUnqualified == nil {
		return 0
	}
	return _ae.Distance(float64(*_abg._bcb.RowOff.ST_CoordinateUnqualified) * _ae.EMU)
}

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_bdgg *Workbook) GetSheet(name string) (Sheet, error) {
	for _, _ecba := range _bdgg.Sheets() {
		if _ecba.Name() == name {
			return _ecba, nil
		}
	}
	return Sheet{}, ErrorNotFound
}

type WorkbookProtection struct{ _decb *_ggd.CT_WorkbookProtection }

var _aeae = [...]uint8{0, 18, 37}

// X returns the inner wrapped XML type.
func (_cbd Font) X() *_ggd.CT_Font { return _cbd._beba }

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_adf Cell) SetNumberWithStyle(v float64, f StandardFormat) {
	_adf.SetNumber(v)
	_adf.SetStyle(_adf._ebb.StyleSheet.GetOrCreateStandardNumberFormat(f))
}

func (_dbdc DataValidation) SetComparison(t DVCompareType, op DVCompareOp) DataValidationCompare {
	_dbdc.clear()
	_dbdc._fcc.TypeAttr = _ggd.ST_DataValidationType(t)
	_dbdc._fcc.OperatorAttr = _ggd.ST_DataValidationOperator(op)
	return DataValidationCompare{_dbdc._fcc}
}

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_bbea *Sheet) Row(rowNum uint32) Row {
	for _, _gbgd := range _bbea._bcgb.SheetData.Row {
		if _gbgd.RAttr != nil && *_gbgd.RAttr == rowNum {
			return Row{_bbea._bdb, _bbea, _gbgd}
		}
	}
	return _bbea.AddNumberedRow(rowNum)
}

// GetValueAsBool retrieves the cell's value as a boolean
func (_gfb Cell) GetValueAsBool() (bool, error) {
	if _gfb._dbd.TAttr != _ggd.ST_CellTypeB {
		return false, _gb.New("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065")
	}
	if _gfb._dbd.V == nil {
		return false, _gb.New("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065")
	}
	return _de.ParseBool(*_gfb._dbd.V)
}

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_fafa *Workbook) Epoch() _dga.Time {
	if _fafa.Uses1904Dates() {
		_dga.Date(1904, 1, 1, 0, 0, 0, 0, _dga.UTC)
	}
	return _dga.Date(1899, 12, 30, 0, 0, 0, 0, _dga.UTC)
}

// SetFont applies a font to a cell style.  The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_aagd CellStyle) SetFont(f Font) {
	_aagd._cae.FontIdAttr = _d.Uint32(f.Index())
	_aagd._cae.ApplyFontAttr = _d.Bool(true)
}

type Fills struct{ _bbee *_ggd.CT_Fills }

// Fonts returns the list of fonts defined in the stylesheet.
func (_ecce StyleSheet) Fonts() []Font {
	_ffga := []Font{}
	for _, _bgdc := range _ecce._gcac.Fonts.Font {
		_ffga = append(_ffga, Font{_bgdc, _ecce._gcac})
	}
	return _ffga
}

// IsNumber returns true if the cell is a number type cell.
func (_fea Cell) IsNumber() bool {
	switch _fea._dbd.TAttr {
	case _ggd.ST_CellTypeN:
		return true
	case _ggd.ST_CellTypeS, _ggd.ST_CellTypeB:
		return false
	}
	return _fea._dbd.V != nil && _ga.IsNumber(*_fea._dbd.V)
}

// SetMinLength sets the minimum bar length in percent.
func (_abc DataBarScale) SetMinLength(l uint32) { _abc._edfg.MinLengthAttr = _d.Uint32(l) }

func (_cgag *Workbook) onNewRelationship(_aggag *_ad.DecodeMap, _fedbd, _dcag string, _geea []*_aa.File, _gcdf *_aag.Relationship, _aaga _ad.Target) error {
	_ccdee := _d.DocTypeSpreadsheet
	switch _dcag {
	case _d.OfficeDocumentType:
		_cgag._bbae = _ggd.NewWorkbook()
		_aggag.AddTarget(_fedbd, _cgag._bbae, _dcag, 0)
		_cgag._adebd = _cb.NewRelationships()
		_aggag.AddTarget(_ad.RelationsPathFor(_fedbd), _cgag._adebd.X(), _dcag, 0)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, 0)
	case _d.CorePropertiesType:
		_aggag.AddTarget(_fedbd, _cgag.CoreProperties.X(), _dcag, 0)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, 0)
	case _d.CustomPropertiesType:
		_aggag.AddTarget(_fedbd, _cgag.CustomProperties.X(), _dcag, 0)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, 0)
	case _d.ExtendedPropertiesType:
		_aggag.AddTarget(_fedbd, _cgag.AppProperties.X(), _dcag, 0)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, 0)
	case _d.WorksheetType:
		_aagcf := _ggd.NewWorksheet()
		_fecf := uint32(len(_cgag._fbed))
		_cgag._fbed = append(_cgag._fbed, _aagcf)
		_aggag.AddTarget(_fedbd, _aagcf, _dcag, _fecf)
		_ddag := _cb.NewRelationships()
		_aggag.AddTarget(_ad.RelationsPathFor(_fedbd), _ddag.X(), _dcag, 0)
		_cgag._fdbe = append(_cgag._fdbe, _ddag)
		_cgag._cbge = append(_cgag._cbge, nil)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, len(_cgag._fbed))
	case _d.StylesType:
		_cgag.StyleSheet = NewStyleSheet(_cgag)
		_aggag.AddTarget(_fedbd, _cgag.StyleSheet.X(), _dcag, 0)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, 0)
	case _d.ThemeType:
		_eadbg := _fe.NewTheme()
		_cgag._bgea = append(_cgag._bgea, _eadbg)
		_aggag.AddTarget(_fedbd, _eadbg, _dcag, 0)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, len(_cgag._bgea))
	case _d.SharedStringsType:
		_cgag.SharedStrings = NewSharedStrings()
		_aggag.AddTarget(_fedbd, _cgag.SharedStrings.X(), _dcag, 0)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, 0)
	case _d.ThumbnailType:
		for _dgaf, _bdff := range _geea {
			if _bdff == nil {
				continue
			}
			if _bdff.Name == _fedbd {
				_fdcda, _dbaa := _bdff.Open()
				if _dbaa != nil {
					return _c.Errorf("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073", _dbaa)
				}
				_cgag.Thumbnail, _, _dbaa = _db.Decode(_fdcda)
				_fdcda.Close()
				if _dbaa != nil {
					return _c.Errorf("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073", _dbaa)
				}
				_geea[_dgaf] = nil
			}
		}
	case _d.ImageType:
		for _cfce, _dfge := range _geea {
			if _dfge == nil {
				continue
			}
			if _dfge.Name == _fedbd {
				_aced, _bagc := _ad.ExtractToDiskTmp(_dfge, _cgag.TmpPath)
				if _bagc != nil {
					return _bagc
				}
				_cgaf, _bagc := _cb.ImageFromStorage(_aced)
				if _bagc != nil {
					return _bagc
				}
				_cefdb := _cb.MakeImageRef(_cgaf, &_cgag.DocBase, _cgag._adebd)
				_cgag.Images = append(_cgag.Images, _cefdb)
				_geea[_cfce] = nil
			}
		}
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, len(_cgag.Images))
	case _d.DrawingType:
		_gegf := _ce.NewWsDr()
		_afeef := uint32(len(_cgag._cefe))
		_aggag.AddTarget(_fedbd, _gegf, _dcag, _afeef)
		_cgag._cefe = append(_cgag._cefe, _gegf)
		_cbcab := _cb.NewRelationships()
		_aggag.AddTarget(_ad.RelationsPathFor(_fedbd), _cbcab.X(), _dcag, _afeef)
		_cgag._fcbeb = append(_cgag._fcbeb, _cbcab)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, len(_cgag._cefe))
	case _d.VMLDrawingType:
		_feggf := _cc.NewContainer()
		_eggf := uint32(len(_cgag._cbbfe))
		_aggag.AddTarget(_fedbd, _feggf, _dcag, _eggf)
		_cgag._cbbfe = append(_cgag._cbbfe, _feggf)
	case _d.CommentsType:
		_cgag._cbge[_aaga.Index] = _ggd.NewComments()
		_aggag.AddTarget(_fedbd, _cgag._cbge[_aaga.Index], _dcag, _aaga.Index)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, len(_cgag._cbge))
	case _d.ChartType:
		_ecaf := _ba.NewChartSpace()
		_deaab := uint32(len(_cgag._fgcda))
		_aggag.AddTarget(_fedbd, _ecaf, _dcag, _deaab)
		_cgag._fgcda = append(_cgag._fgcda, _ecaf)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, len(_cgag._fgcda))
	case _d.TableType:
		_faba := _ggd.NewTable()
		_aegd := uint32(len(_cgag._caaa))
		_aggag.AddTarget(_fedbd, _faba, _dcag, _aegd)
		_cgag._caaa = append(_cgag._caaa, _faba)
		_gcdf.TargetAttr = _d.RelativeFilename(_ccdee, _aaga.Typ, _dcag, len(_cgag._caaa))
	default:
		_d.Log("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073", _fedbd, _dcag)
	}
	return nil
}

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_ccab Row) Cell(col string) Cell {
	_feb := _c.Sprintf("\u0025\u0073\u0025\u0064", col, _ccab.RowNumber())
	for _, _fdac := range _ccab._dggg.C {
		if _fdac.RAttr != nil && *_fdac.RAttr == _feb {
			return Cell{_ccab._fcba, _ccab._dafa, _ccab._dggg, _fdac}
		}
	}
	return _ccab.AddNamedCell(col)
}

// SetText sets the text to be displayed.
func (_eac RichTextRun) SetText(s string) { _eac._aggb.T = s }

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_eeae DataValidationList) SetRange(cellRange string) {
	_eeae._eea.Formula1 = _d.String(cellRange)
	_eeae._eea.Formula2 = _d.String("\u0030")
}

// SetHyperlink sets a hyperlink on a cell.
func (_ccbf Cell) SetHyperlink(hl _cb.Hyperlink) {
	_def := _ccbf._dbag._bcgb
	if _def.Hyperlinks == nil {
		_def.Hyperlinks = _ggd.NewCT_Hyperlinks()
	}
	_ddbc := _cb.Relationship(hl)
	_bgg := _ggd.NewCT_Hyperlink()
	_bgg.RefAttr = _ccbf.Reference()
	_bgg.IdAttr = _d.String(_ddbc.ID())
	_def.Hyperlinks.Hyperlink = append(_def.Hyperlinks.Hyperlink, _bgg)
}

// SetDateWithStyle sets a date with the default date style applied.
func (_ccgf Cell) SetDateWithStyle(d _dga.Time) {
	_ccgf.SetDate(d)
	for _, _dfca := range _ccgf._ebb.StyleSheet.CellStyles() {
		if _dfca.HasNumberFormat() && _dfca.NumberFormat() == uint32(StandardFormatDate) {
			_ccgf.SetStyle(_dfca)
			return
		}
	}
	_gaag := _ccgf._ebb.StyleSheet.AddCellStyle()
	_gaag.SetNumberFormatStandard(StandardFormatDate)
	_ccgf.SetStyle(_gaag)
}

// GetString retrieves a string from the shared strings table by index.
func (_ecdfa SharedStrings) GetString(id int) (string, error) {
	if id < 0 {
		return "", _c.Errorf("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030", id)
	}
	if id > len(_ecdfa._gce.Si) {
		return "", _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073", id, len(_ecdfa._gce.Si))
	}
	_cfb := _ecdfa._gce.Si[id]
	if _cfb.T != nil {
		return *_cfb.T, nil
	}
	return "", nil
}

const (
	SortOrderAscending SortOrder = iota
	SortOrderDescending
)

// New constructs a new workbook.
func New() *Workbook {
	_afef := &Workbook{}
	_afef._bbae = _ggd.NewWorkbook()
	_afef.AppProperties = _cb.NewAppProperties()
	_afef.CoreProperties = _cb.NewCoreProperties()
	_afef.StyleSheet = NewStyleSheet(_afef)
	_afef.Rels = _cb.NewRelationships()
	_afef._adebd = _cb.NewRelationships()
	_afef.Rels.AddRelationship(_d.RelativeFilename(_d.DocTypeSpreadsheet, "", _d.ExtendedPropertiesType, 0), _d.ExtendedPropertiesType)
	_afef.Rels.AddRelationship(_d.RelativeFilename(_d.DocTypeSpreadsheet, "", _d.CorePropertiesType, 0), _d.CorePropertiesType)
	_afef.Rels.AddRelationship(_d.RelativeFilename(_d.DocTypeSpreadsheet, "", _d.OfficeDocumentType, 0), _d.OfficeDocumentType)
	_afef._adebd.AddRelationship(_d.RelativeFilename(_d.DocTypeSpreadsheet, _d.OfficeDocumentType, _d.StylesType, 0), _d.StylesType)
	_afef.ContentTypes = _cb.NewContentTypes()
	_afef.ContentTypes.AddDefault("\u0076\u006d\u006c", _d.VMLDrawingContentType)
	_afef.ContentTypes.AddOverride(_d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.OfficeDocumentType, 0), "\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c")
	_afef.ContentTypes.AddOverride(_d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.StylesType, 0), _d.SMLStyleSheetContentType)
	_afef.SharedStrings = NewSharedStrings()
	_afef.ContentTypes.AddOverride(_d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.SharedStringsType, 0), _d.SharedStringsContentType)
	_afef._adebd.AddRelationship(_d.RelativeFilename(_d.DocTypeSpreadsheet, _d.OfficeDocumentType, _d.SharedStringsType, 0), _d.SharedStringsType)
	return _afef
}

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_cedd Cell) SetTime(d _dga.Time) {
	_cedd.clearValue()
	d = _cde(d)
	_cda := _cedd._ebb.Epoch()
	if d.Before(_cda) {
		_d.Log("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064")
		return
	}
	_ffd := d.Sub(_cda)
	_bgaa := new(_dd.Float)
	_dfdf := new(_dd.Float)
	_dfdf.SetPrec(128)
	_dfdf.SetUint64(uint64(_ffd))
	_ccc := new(_dd.Float)
	_ccc.SetUint64(24 * 60 * 60 * 1e9)
	_bgaa.Quo(_dfdf, _ccc)
	_cedd._dbd.V = _d.String(_bgaa.Text('g', 20))
}

func (_fcg Font) SetColor(c _cg.Color) {
	_dcd := _ggd.NewCT_Color()
	_cbe := "\u0066\u0066" + *c.AsRGBString()
	_dcd.RgbAttr = &_cbe
	_fcg._beba.Color = []*_ggd.CT_Color{_dcd}
}

// SetYSplit sets the row split point
func (_bdba SheetView) SetYSplit(v float64) {
	_bdba.ensurePane()
	_bdba._baef.Pane.YSplitAttr = _d.Float64(v)
}

func (_gaec *Workbook) createCustomProperties() {
	_gaec.CustomProperties = _cb.NewCustomProperties()
	_gaec.addCustomRelationships()
}

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_ced AbsoluteAnchor) SetColOffset(m _ae.Distance) {
	_ced._cd.Pos.XAttr.ST_CoordinateUnqualified = _d.Int64(int64(m / _ae.EMU))
}

// X returns the inner wrapped XML type.
func (_eafe SheetProtection) X() *_ggd.CT_SheetProtection { return _eafe._bcef }

func (_fga Sheet) ExtentsIndex() (string, uint32, string, uint32) {
	var _bdfb, _gcef, _gfeg, _dgcg uint32 = 1, 1, 0, 0
	for _, _gfegc := range _fga.Rows() {
		if _gfegc.RowNumber() < _bdfb {
			_bdfb = _gfegc.RowNumber()
		} else if _gfegc.RowNumber() > _gcef {
			_gcef = _gfegc.RowNumber()
		}
		for _, _dafaa := range _gfegc.Cells() {
			_cee, _cbgd := _eg.ParseCellReference(_dafaa.Reference())
			if _cbgd == nil {
				if _cee.ColumnIdx < _gfeg {
					_gfeg = _cee.ColumnIdx
				} else if _cee.ColumnIdx > _dgcg {
					_dgcg = _cee.ColumnIdx
				}
			}
		}
	}
	return _eg.IndexToColumn(_gfeg), _bdfb, _eg.IndexToColumn(_dgcg), _gcef
}

var _bgab = false

func (_egg StyleSheet) GetNumberFormat(id uint32) NumberFormat {
	if id >= 0 && id < 50 {
		return CreateDefaultNumberFormat(StandardFormat(id))
	}
	for _, _gcgd := range _egg._gcac.NumFmts.NumFmt {
		if _gcgd.NumFmtIdAttr == id {
			return NumberFormat{_egg._cecga, _gcgd}
		}
	}
	return NumberFormat{}
}

// SetWidthCells is a no-op.
func (_gd AbsoluteAnchor) SetWidthCells(int32) {}

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_aagf *Workbook) RemoveSheetByName(name string) error {
	_ebfe := -1
	for _cdeg, _effg := range _aagf.Sheets() {
		if name == _effg.Name() {
			_ebfe = _cdeg
			break
		}
	}
	if _ebfe == -1 {
		return ErrorNotFound
	}
	return _aagf.RemoveSheet(_ebfe)
}

// Sheet is a single sheet within a workbook.
type Sheet struct {
	_bdb  *Workbook
	_adae *_ggd.CT_Sheet
	_bcgb *_ggd.Worksheet
}

// X returns the inner wrapped XML type.
func (_ccbd ConditionalFormattingRule) X() *_ggd.CT_CfRule { return _ccbd._dbed }

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_ecc Cell) SetRichTextString() RichText {
	_ecc.clearValue()
	_ecc._dbd.Is = _ggd.NewCT_Rst()
	_ecc._dbd.TAttr = _ggd.ST_CellTypeInlineStr
	return RichText{_ecc._dbd.Is}
}

// LockWindow controls the locking of the workbook windows.
func (_gaffe WorkbookProtection) LockWindow(b bool) {
	if !b {
		_gaffe._decb.LockWindowsAttr = nil
	} else {
		_gaffe._decb.LockWindowsAttr = _d.Bool(true)
	}
}

const (
	AnchorTypeAbsolute AnchorType = iota
	AnchorTypeOneCell
	AnchorTypeTwoCell
)

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_gbdg Comparer) LessCells(lhs, rhs Cell) bool {
	if _gbdg.Order == SortOrderDescending {
		lhs, rhs = rhs, lhs
	}
	if lhs.X() == nil {
		if rhs.X() == nil {
			return false
		}
		return true
	}
	if rhs.X() == nil {
		return false
	}
	_fdf, _ebdd := lhs.getRawSortValue()
	_geb, _efb := rhs.getRawSortValue()
	switch {
	case _ebdd && _efb:
		_adeg, _ := _de.ParseFloat(_fdf, 64)
		_edff, _ := _de.ParseFloat(_geb, 64)
		return _adeg < _edff
	case _ebdd:
		return true
	case _efb:
		return false
	}
	_fdf = lhs.GetFormattedValue()
	_geb = rhs.GetFormattedValue()
	return _fdf < _geb
}

// RemoveDefinedName removes an existing defined name.
func (_cbcabg *Workbook) RemoveDefinedName(dn DefinedName) error {
	if dn.X() == nil {
		return _gb.New("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065")
	}
	for _eada, _cbfac := range _cbcabg._bbae.DefinedNames.DefinedName {
		if _cbfac == dn.X() {
			copy(_cbcabg._bbae.DefinedNames.DefinedName[_eada:], _cbcabg._bbae.DefinedNames.DefinedName[_eada+1:])
			_cbcabg._bbae.DefinedNames.DefinedName[len(_cbcabg._bbae.DefinedNames.DefinedName)-1] = nil
			_cbcabg._bbae.DefinedNames.DefinedName = _cbcabg._bbae.DefinedNames.DefinedName[:len(_cbcabg._bbae.DefinedNames.DefinedName)-1]
			return nil
		}
	}
	return _gb.New("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064")
}

// Reference returns the table reference (the cells within the table)
func (_aabe Table) Reference() string { return _aabe._cbab.RefAttr }

func (_ebcec StandardFormat) String() string {
	switch {
	case 0 <= _ebcec && _ebcec <= 4:
		return _gbfc[_ebgca[_ebcec]:_ebgca[_ebcec+1]]
	case 9 <= _ebcec && _ebcec <= 22:
		_ebcec -= 9
		return _fgdf[_afbc[_ebcec]:_afbc[_ebcec+1]]
	case 37 <= _ebcec && _ebcec <= 40:
		_ebcec -= 37
		return _dbeg[_ffage[_ebcec]:_ffage[_ebcec+1]]
	case 45 <= _ebcec && _ebcec <= 49:
		_ebcec -= 45
		return _fecb[_dcgb[_ebcec]:_dcgb[_ebcec+1]]
	default:
		return _c.Sprintf("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029", _ebcec)
	}
}

func _bbfd(_gfa bool) int {
	if _gfa {
		return 1
	}
	return 0
}

// SetFont sets the font name for a rich text run.
func (_bgadd RichTextRun) SetFont(s string) {
	_bgadd.ensureRpr()
	_bgadd._aggb.RPr.RFont = _ggd.NewCT_FontName()
	_bgadd._aggb.RPr.RFont.ValAttr = s
}

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_fdfd *evalContext) LastColumn(rowFrom, rowTo int) string {
	_aage := _fdfd._afdd
	_fec := 1
	for _bcd := rowFrom; _bcd <= rowTo; _bcd++ {
		_bdca := len(_aage.Row(uint32(_bcd)).Cells())
		if _bdca > _fec {
			_fec = _bdca
		}
	}
	return _eg.IndexToColumn(uint32(_fec - 1))
}

// InitializeDefaults initializes a border to its defaulte empty values.
func (_da Border) InitializeDefaults() {
	_da._aac.Left = _ggd.NewCT_BorderPr()
	_da._aac.Bottom = _ggd.NewCT_BorderPr()
	_da._aac.Right = _ggd.NewCT_BorderPr()
	_da._aac.Top = _ggd.NewCT_BorderPr()
	_da._aac.Diagonal = _ggd.NewCT_BorderPr()
}

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_ecb DataValidation) SetRange(cellRange string) {
	_ecb._fcc.SqrefAttr = _ggd.ST_Sqref{cellRange}
}

func (_dab Fills) X() *_ggd.CT_Fills { return _dab._bbee }

// ClearProtection clears all workbook protections.
func (_fgaa *Workbook) ClearProtection() { _fgaa._bbae.WorkbookProtection = nil }

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_dafg *Sheet) SetDrawing(d Drawing) {
	var _cgddf _cb.Relationships
	for _ggbd, _eafa := range _dafg._bdb._fbed {
		if _eafa == _dafg._bcgb {
			_cgddf = _dafg._bdb._fdbe[_ggbd]
			break
		}
	}
	var _fdcd string
	for _acag, _bddfa := range d._debc._cefe {
		if _bddfa == d._fefc {
			_fgbd := _cgddf.AddAutoRelationship(_d.DocTypeSpreadsheet, _d.WorksheetType, _acag+1, _d.DrawingType)
			_fdcd = _fgbd.ID()
			break
		}
	}
	_dafg._bcgb.Drawing = _ggd.NewCT_Drawing()
	_dafg._bcgb.Drawing.IdAttr = _fdcd
}

// MoveTo repositions the anchor without changing the objects size.
func (_aceeg TwoCellAnchor) MoveTo(col, row int32) {
	_ecdd := _aceeg.TopLeft()
	_begd := _aceeg.BottomRight()
	_dfab := _begd.Col() - _ecdd.Col()
	_bfebb := _begd.Row() - _ecdd.Row()
	_ecdd.SetCol(col)
	_ecdd.SetRow(row)
	_begd.SetCol(col + _dfab)
	_begd.SetRow(row + _bfebb)
}

func (_acdf Fill) SetPatternFill() PatternFill {
	_acdf._bcbc.GradientFill = nil
	_acdf._bcbc.PatternFill = _ggd.NewCT_PatternFill()
	_acdf._bcbc.PatternFill.PatternTypeAttr = _ggd.ST_PatternTypeSolid
	return PatternFill{_acdf._bcbc.PatternFill, _acdf._bcbc}
}

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_dgf Comments) AddComment(cellRef string, author string) RichText {
	_gfcb := _ggd.NewCT_Comment()
	_dgf._fcd.CommentList.Comment = append(_dgf._fcd.CommentList.Comment, _gfcb)
	_gfcb.RefAttr = cellRef
	_gfcb.AuthorIdAttr = _dgf.getOrCreateAuthor(author)
	_gfcb.Text = _ggd.NewCT_Rst()
	return RichText{_gfcb.Text}
}

// Protection controls the protection on an individual sheet.
func (_gdbd *Sheet) Protection() SheetProtection {
	if _gdbd._bcgb.SheetProtection == nil {
		_gdbd._bcgb.SheetProtection = _ggd.NewCT_SheetProtection()
	}
	return SheetProtection{_gdbd._bcgb.SheetProtection}
}

func NewFills() Fills { return Fills{_ggd.NewCT_Fills()} }

// Type returns the type of anchor
func (_bfef OneCellAnchor) Type() AnchorType { return AnchorTypeOneCell }

type ConditionalFormattingRule struct{ _dbed *_ggd.CT_CfRule }

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_acff StyleSheet) AddDifferentialStyle() DifferentialStyle {
	if _acff._gcac.Dxfs == nil {
		_acff._gcac.Dxfs = _ggd.NewCT_Dxfs()
	}
	_dbfe := _ggd.NewCT_Dxf()
	_acff._gcac.Dxfs.Dxf = append(_acff._gcac.Dxfs.Dxf, _dbfe)
	_acff._gcac.Dxfs.CountAttr = _d.Uint32(uint32(len(_acff._gcac.Dxfs.Dxf)))
	return DifferentialStyle{_dbfe, _acff._cecga, _acff._gcac.Dxfs}
}

// IsDBCS returns if a workbook's default language is among DBCS.
func (_ggdc *evalContext) IsDBCS() bool {
	_cef := _ggdc._afdd._bdb.CoreProperties.X().Language
	if _cef == nil {
		return false
	}
	_abd := string(_cef.Data)
	for _, _ccfd := range _gccf {
		if _abd == _ccfd {
			return true
		}
	}
	return false
}

func (_dadb *Sheet) getAllCellsInFormulaArraysForColumn() (map[string]bool, error) {
	return _dadb.getAllCellsInFormulaArrays(false)
}

// Row returns the row of the cell marker.
func (_daf CellMarker) Row() int32 { return _daf._bcb.Row }

// Author returns the author of the comment
func (_cad Comment) Author() string {
	if _cad._gbfb.AuthorIdAttr < uint32(len(_cad._adb.Authors.Author)) {
		return _cad._adb.Authors.Author[_cad._gbfb.AuthorIdAttr]
	}
	return ""
}

// Type returns the type of anchor
func (_ab AbsoluteAnchor) Type() AnchorType { return AnchorTypeAbsolute }

type evalContext struct {
	_afdd      *Sheet
	_cga, _fba uint32
	_acde      map[string]struct{}
}

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_gddd IconScale) AddFormatValue(t _ggd.ST_CfvoType, val string) {
	_bbcb := _ggd.NewCT_Cfvo()
	_bbcb.TypeAttr = t
	_bbcb.ValAttr = _d.String(val)
	_gddd._adcf.Cfvo = append(_gddd._adcf.Cfvo, _bbcb)
}

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32

// GetFormula returns the formula for a cell.
func (_ebf Cell) GetFormula() string {
	if _ebf._dbd.F != nil {
		return _ebf._dbd.F.Content
	}
	return ""
}

// Comments is the container for comments for a single sheet.
type Comments struct {
	_aeff *Workbook
	_fcd  *_ggd.Comments
}

func (_dcc Sheet) validateSheetNames() error {
	if len(_dcc.Name()) > 31 {
		return _c.Errorf("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331", _dcc.Name(), len(_dcc.Name()))
	}
	return nil
}

// ClearProtection removes any protections applied to teh sheet.
func (_dccd *Sheet) ClearProtection() { _dccd._bcgb.SheetProtection = nil }

func _agfe(_aggf string) bool {
	_aggf = _dgd.Replace(_aggf, "\u0024", "", -1)
	if _fdfg := _ecdc.FindStringSubmatch(_dgd.ToLower(_aggf)); len(_fdfg) > 2 {
		_aagde := _fdfg[1]
		_ebfc, _cggg := _de.Atoi(_fdfg[2])
		if _cggg != nil {
			return false
		}
		return _ebfc <= 1048576 && _aagde <= "\u007a\u007a"
	}
	return false
}

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{ _fefg *_ggd.CT_DataValidation }

// Border is a cell border configuraton.
type Border struct {
	_aac *_ggd.CT_Border
	_cdg *_ggd.CT_Borders
}

// AddFormatValue adds a format value to be used to determine the cell background.
func (_abb ColorScale) AddFormatValue(t _ggd.ST_CfvoType, val string) {
	_gaff := _ggd.NewCT_Cfvo()
	_gaff.TypeAttr = t
	_gaff.ValAttr = _d.String(val)
	_abb._aaed.Cfvo = append(_abb._aaed.Cfvo, _gaff)
}

// X returns the inner wrapped XML type.
func (_aefa DifferentialStyle) X() *_ggd.CT_Dxf { return _aefa._dggf }

// SetShowRuler controls the visibility of the ruler
func (_gfbd SheetView) SetShowRuler(b bool) {
	if !b {
		_gfbd._baef.ShowRulerAttr = _d.Bool(false)
	} else {
		_gfbd._baef.ShowRulerAttr = nil
	}
}

// SetHidden marks the defined name as hidden.
func (_aege DefinedName) SetLocalSheetID(id uint32) {
	_aege._cecc.LocalSheetIdAttr = _d.Uint32(id)
}

// X returns the inner wrapped XML type.
func (_cbbf SheetView) X() *_ggd.CT_SheetView { return _cbbf._baef }

// ClearFont clears any font configuration from the cell style.
func (_ebc CellStyle) ClearFont() { _ebc._cae.FontIdAttr = nil; _ebc._cae.ApplyFontAttr = nil }

// DefinedName is a named range, formula, etc.
type DefinedName struct{ _cecc *_ggd.CT_DefinedName }

func _gbga() *_ce.CT_OneCellAnchor { _efcf := _ce.NewCT_OneCellAnchor(); return _efcf }

// SetHidden controls the visibility of a column.
func (_aef Column) SetHidden(b bool) {
	if !b {
		_aef._eccb.HiddenAttr = nil
	} else {
		_aef._eccb.HiddenAttr = _d.Bool(true)
	}
}

// AddCell adds a cell to a spreadsheet.
func (_ffgg Row) AddCell() Cell {
	_cdaa := uint32(len(_ffgg._dggg.C))
	var _agge *string
	if _cdaa > 0 {
		_cabgg := _d.Stringf("\u0025\u0073\u0025\u0064", _eg.IndexToColumn(_cdaa-1), _ffgg.RowNumber())
		if _ffgg._dggg.C[_cdaa-1].RAttr != nil && *_ffgg._dggg.C[_cdaa-1].RAttr == *_cabgg {
			_agge = _d.Stringf("\u0025\u0073\u0025\u0064", _eg.IndexToColumn(_cdaa), _ffgg.RowNumber())
		}
	}
	_fedd := _ggd.NewCT_Cell()
	_ffgg._dggg.C = append(_ffgg._dggg.C, _fedd)
	if _agge == nil {
		_dfbf := uint32(0)
		for _, _eacd := range _ffgg._dggg.C {
			if _eacd.RAttr != nil {
				_bce, _ := _eg.ParseCellReference(*_eacd.RAttr)
				if _bce.ColumnIdx >= _dfbf {
					_dfbf = _bce.ColumnIdx + 1
				}
			}
		}
		_agge = _d.Stringf("\u0025\u0073\u0025\u0064", _eg.IndexToColumn(_dfbf), _ffgg.RowNumber())
	}
	_fedd.RAttr = _agge
	return Cell{_ffgg._fcba, _ffgg._dafa, _ffgg._dggg, _fedd}
}

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_aafbe *Sheet) AddRow() Row {
	_befb := uint32(0)
	_daeg := uint32(len(_aafbe._bcgb.SheetData.Row))
	if _daeg > 0 && _aafbe._bcgb.SheetData.Row[_daeg-1].RAttr != nil && *_aafbe._bcgb.SheetData.Row[_daeg-1].RAttr == _daeg {
		return _aafbe.addNumberedRowFast(_daeg + 1)
	}
	for _, _ggcb := range _aafbe._bcgb.SheetData.Row {
		if _ggcb.RAttr != nil && *_ggcb.RAttr > _befb {
			_befb = *_ggcb.RAttr
		}
	}
	return _aafbe.AddNumberedRow(_befb + 1)
}

// SetHeightAuto sets the row height to be automatically determined.
func (_fgff Row) SetHeightAuto() { _fgff._dggg.HtAttr = nil; _fgff._dggg.CustomHeightAttr = nil }

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_daab Row) AddNamedCell(col string) Cell {
	_ccag := _ggd.NewCT_Cell()
	_ccag.RAttr = _d.Stringf("\u0025\u0073\u0025\u0064", col, _daab.RowNumber())
	_egda := -1
	_facea := _eg.ColumnToIndex(col)
	for _fdfac, _debac := range _daab._dggg.C {
		_beed, _ecdf := _eg.ParseCellReference(*_debac.RAttr)
		if _ecdf != nil {
			return Cell{}
		}
		if _facea < _beed.ColumnIdx {
			_egda = _fdfac
			break
		}
	}
	if _egda == -1 {
		_daab._dggg.C = append(_daab._dggg.C, _ccag)
	} else {
		_daab._dggg.C = append(_daab._dggg.C[:_egda], append([]*_ggd.CT_Cell{_ccag}, _daab._dggg.C[_egda:]...)...)
	}
	return Cell{_daab._fcba, _daab._dafa, _daab._dggg, _ccag}
}

// AddRule adds and returns a new rule that can be configured.
func (_cgg ConditionalFormatting) AddRule() ConditionalFormattingRule {
	_eab := _ggd.NewCT_CfRule()
	_cgg._acdg.CfRule = append(_cgg._acdg.CfRule, _eab)
	_fff := ConditionalFormattingRule{_eab}
	_fff.InitializeDefaults()
	_fff.SetPriority(int32(len(_cgg._acdg.CfRule) + 1))
	return _fff
}

// IsEmpty checks if the cell style contains nothing.
func (_caeg CellStyle) IsEmpty() bool {
	return _caeg._aaeg == nil || _caeg._cae == nil || _caeg._ggf == nil || _caeg._ggf.Xf == nil
}

// SetInlineString adds a string inline instead of in the shared strings table.
func (_aae Cell) SetInlineString(s string) {
	_aae.clearValue()
	_aae._dbd.Is = _ggd.NewCT_Rst()
	_aae._dbd.Is.T = _d.String(s)
	_aae._dbd.TAttr = _ggd.ST_CellTypeInlineStr
}

// SetColOffset sets the column offset of the two cell anchor.
func (_gggg TwoCellAnchor) SetColOffset(m _ae.Distance) {
	_fdfge := m - _gggg.TopLeft().ColOffset()
	_gggg.TopLeft().SetColOffset(m)
	_gggg.BottomRight().SetColOffset(_gggg.BottomRight().ColOffset() + _fdfge)
}

// SetType sets the type of the rule.
func (_aebbc ConditionalFormattingRule) SetType(t _ggd.ST_CfType) { _aebbc._dbed.TypeAttr = t }

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_gfbg SheetView) SetZoom(pct uint32) { _gfbg._baef.ZoomScaleAttr = &pct }

// SetCol set the column of the cell marker.
func (_ccba CellMarker) SetCol(col int32) { _ccba._bcb.Col = col }

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_fbe CellStyle) SetNumberFormatStandard(s StandardFormat) {
	_fbe._cae.NumFmtIdAttr = _d.Uint32(uint32(s))
	_fbe._cae.ApplyNumberFormatAttr = _d.Bool(true)
}

const (
	DVOpGreater = _ggd.ST_DataValidationOperatorGreaterThanOrEqual
)

// MergedCells returns the merged cell regions within the sheet.
func (_dccb *Sheet) MergedCells() []MergedCell {
	if _dccb._bcgb.MergeCells == nil {
		return nil
	}
	_egb := []MergedCell{}
	for _, _gcg := range _dccb._bcgb.MergeCells.MergeCell {
		_egb = append(_egb, MergedCell{_dccb._bdb, _dccb, _gcg})
	}
	return _egb
}

func (_fgef Row) renumberAs(_ebeb uint32) {
	_fgef._dggg.RAttr = _d.Uint32(_ebeb)
	for _, _dff := range _fgef.Cells() {
		_efed, _bffd := _eg.ParseCellReference(_dff.Reference())
		if _bffd == nil {
			_gbb := _c.Sprintf("\u0025\u0073\u0025\u0064", _efed.Column, _ebeb)
			_dff._dbd.RAttr = _d.String(_gbb)
		}
	}
}

// X returns the inner wrapped XML type.
func (_cfgg Drawing) X() *_ce.WsDr { return _cfgg._fefc }

// Column returns the cell column
func (_ed Cell) Column() (string, error) {
	_ge, _bdf := _eg.ParseCellReference(_ed.Reference())
	if _bdf != nil {
		return "", _bdf
	}
	return _ge.Column, nil
}

// Sheets returns the sheets from the workbook.
func (_eecd *Workbook) Sheets() []Sheet {
	_eabgd := []Sheet{}
	for _ccagg, _gada := range _eecd._fbed {
		_beaa := _eecd._bbae.Sheets.Sheet[_ccagg]
		_efca := Sheet{_eecd, _beaa, _gada}
		_eabgd = append(_eabgd, _efca)
	}
	return _eabgd
}

// Protection allows control over the workbook protections.
func (_gddbg *Workbook) Protection() WorkbookProtection {
	if _gddbg._bbae.WorkbookProtection == nil {
		_gddbg._bbae.WorkbookProtection = _ggd.NewCT_WorkbookProtection()
	}
	return WorkbookProtection{_gddbg._bbae.WorkbookProtection}
}

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_dcb Cell) SetCachedFormulaResult(s string) { _dcb._dbd.V = &s }

// SetColOffset sets the column offset of the top-left anchor.
func (_fffg OneCellAnchor) SetColOffset(m _ae.Distance) { _fffg.TopLeft().SetColOffset(m) }

// SetBold causes the text to be displayed in bold.
func (_aefg RichTextRun) SetBold(b bool) {
	_aefg.ensureRpr()
	_aefg._aggb.RPr.B = _ggd.NewCT_BooleanProperty()
	_aefg._aggb.RPr.B.ValAttr = _d.Bool(b)
}

func (_dcbc Font) Index() uint32 {
	for _aebf, _dbf := range _dcbc._fccf.Fonts.Font {
		if _dcbc._beba == _dbf {
			return uint32(_aebf)
		}
	}
	return 0
}

// X returns the inner wrapped XML type.
func (_fbc MergedCell) X() *_ggd.CT_MergeCell { return _fbc._ddge }

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_ddbb Cell) SetStyleIndex(idx uint32) { _ddbb._dbd.SAttr = _d.Uint32(idx) }

// IsBool returns true if the cell boolean value.
func (_gdb *evalContext) IsBool(cellRef string) bool { return _gdb._afdd.Cell(cellRef).IsBool() }

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_dcbd *Workbook) AddDrawing() Drawing {
	_cdcfc := _ce.NewWsDr()
	_dcbd._cefe = append(_dcbd._cefe, _cdcfc)
	_egaf := _d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.DrawingType, len(_dcbd._cefe))
	_dcbd.ContentTypes.AddOverride(_egaf, _d.DrawingContentType)
	_dcbd._fcbeb = append(_dcbd._fcbeb, _cb.NewRelationships())
	return Drawing{_dcbd, _cdcfc}
}

// SetHeight sets the height of the anchored object.
func (_be AbsoluteAnchor) SetHeight(h _ae.Distance) { _be._cd.Ext.CyAttr = int64(h / _ae.EMU) }

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_cfbe Sheet) Extents() string {
	_geab, _acef, _gagd, _aabg := _cfbe.ExtentsIndex()
	return _c.Sprintf("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d", _geab, _acef, _gagd, _aabg)
}

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{ _edfg *_ggd.CT_DataBar }

// SetFill applies a fill to a cell style.  The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_degc CellStyle) SetFill(f Fill) {
	_degc._cae.FillIdAttr = _d.Uint32(f.Index())
	_degc._cae.ApplyFillAttr = _d.Bool(true)
}

// SetBorder applies a border to a cell style.  The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_ade CellStyle) SetBorder(b Border) {
	_ade._cae.BorderIdAttr = _d.Uint32(b.Index())
	_ade._cae.ApplyBorderAttr = _d.Bool(true)
}

// SetWidth sets the width of the anchored object.
func (_fege OneCellAnchor) SetWidth(w _ae.Distance) {
	_fege._bbaac.Ext.CxAttr = int64(w / _ae.EMU)
}

var ErrorNotFound = _gb.New("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed")

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_baa ConditionalFormattingRule) SetColorScale() ColorScale {
	_baa.clear()
	_baa.SetType(_ggd.ST_CfTypeColorScale)
	_baa._dbed.ColorScale = _ggd.NewCT_ColorScale()
	return ColorScale{_baa._dbed.ColorScale}
}

func (_fabe Fills) AddFill() Fill {
	_beaf := _ggd.NewCT_Fill()
	_fabe._bbee.Fill = append(_fabe._bbee.Fill, _beaf)
	_fabe._bbee.CountAttr = _d.Uint32(uint32(len(_fabe._bbee.Fill)))
	return Fill{_beaf, _fabe._bbee}
}

const _cdgd = "\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067"

// X returns the inner wrapped XML type.
func (_ccad Table) X() *_ggd.Table { return _ccad._cbab }

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_gca PatternFill) SetFgColor(c _cg.Color) {
	_gca._aaac.FgColor = _ggd.NewCT_Color()
	_gca._aaac.FgColor.RgbAttr = c.AsRGBAString()
}

type Fill struct {
	_bcbc *_ggd.CT_Fill
	_cabg *_ggd.CT_Fills
}

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_gage *Workbook) ClearCachedFormulaResults() {
	for _, _bdbfe := range _gage.Sheets() {
		_bdbfe.ClearCachedFormulaResults()
	}
}

// SetShowValue controls if the cell value is displayed.
func (_ebac DataBarScale) SetShowValue(b bool) { _ebac._edfg.ShowValueAttr = _d.Bool(b) }

// CellStyles returns the list of defined cell styles
func (_cfbf StyleSheet) CellStyles() []CellStyle {
	_ebece := []CellStyle{}
	for _, _bdbf := range _cfbf._gcac.CellXfs.Xf {
		_ebece = append(_ebece, CellStyle{_cfbf._cecga, _bdbf, _cfbf._gcac.CellXfs})
	}
	return _ebece
}

// X returns the inner wrapped XML type.
func (_bfbc Sheet) X() *_ggd.Worksheet { return _bfbc._bcgb }

// SetName sets the sheet name.
func (_fgc *Sheet) SetName(name string) { _fgc._adae.NameAttr = name }

// X returns the inner wrapped XML type.
func (_bcea SharedStrings) X() *_ggd.Sst { return _bcea._gce }

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_bdaa *Workbook) CopySheet(ind int, copiedSheetName string) (Sheet, error) {
	if _bdaa.SheetCount() <= ind {
		return Sheet{}, ErrorNotFound
	}
	var _fbga _cb.Relationship
	for _, _agbb := range _bdaa._adebd.Relationships() {
		if _agbb.ID() == _bdaa._bbae.Sheets.Sheet[ind].IdAttr {
			var _ffeb bool
			if _fbga, _ffeb = _bdaa._adebd.CopyRelationship(_agbb.ID()); !_ffeb {
				return Sheet{}, ErrorNotFound
			}
			break
		}
	}
	_bdaa.ContentTypes.CopyOverride(_d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.WorksheetContentType, ind+1), _d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.WorksheetContentType, len(_bdaa.ContentTypes.X().Override)))
	_bbge := *_bdaa._fbed[ind]
	_bdaa._fbed = append(_bdaa._fbed, &_bbge)
	var _dcaf uint32 = 0
	for _, _gecg := range _bdaa._bbae.Sheets.Sheet {
		if _gecg.SheetIdAttr > _dcaf {
			_dcaf = _gecg.SheetIdAttr
		}
	}
	_dcaf++
	_aefefb := *_bdaa._bbae.Sheets.Sheet[ind]
	_aefefb.IdAttr = _fbga.ID()
	_aefefb.NameAttr = copiedSheetName
	_aefefb.SheetIdAttr = _dcaf
	_bdaa._bbae.Sheets.Sheet = append(_bdaa._bbae.Sheets.Sheet, &_aefefb)
	_bbcd := _cb.NewRelationshipsCopy(_bdaa._fdbe[ind])
	_bdaa._fdbe = append(_bdaa._fdbe, _bbcd)
	_gbdee := _bdaa._cbge[ind]
	if _gbdee == nil {
		_bdaa._cbge = append(_bdaa._cbge, nil)
	} else {
		_fdaae := *_gbdee
		_bdaa._cbge = append(_bdaa._cbge, &_fdaae)
	}
	_gddf := Sheet{_bdaa, &_aefefb, &_bbge}
	return _gddf, nil
}

// GetOrCreateCustomProperties returns the custom properties of the document (and if they not exist yet, creating them first)
func (_bfggf *Workbook) GetOrCreateCustomProperties() _cb.CustomProperties {
	if _bfggf.CustomProperties.X() == nil {
		_bfggf.createCustomProperties()
	}
	return _bfggf.CustomProperties
}

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_fegg *Sheet) InitialView() SheetView {
	if _fegg._bcgb.SheetViews == nil || len(_fegg._bcgb.SheetViews.SheetView) == 0 {
		return _fegg.AddView()
	}
	return SheetView{_fegg._bcgb.SheetViews.SheetView[0]}
}

// GetLocked returns true if the cell is locked.
func (_ffbc *evalContext) GetLocked(cellRef string) bool {
	return _ffbc._afdd.Cell(cellRef).getLocked()
}

// Index returns the index of the border for use with a cell style.
func (_gf Border) Index() uint32 {
	for _eb, _aeb := range _gf._cdg.Border {
		if _aeb == _gf._aac {
			return uint32(_eb)
		}
	}
	return 0
}

// SetHeight sets the height of the anchored object.
func (_fecg OneCellAnchor) SetHeight(h _ae.Distance) {
	_fecg._bbaac.Ext.CyAttr = int64(h / _ae.EMU)
}

// SetPattern sets the pattern of the fill.
func (_aca PatternFill) SetPattern(p _ggd.ST_PatternType) { _aca._aaac.PatternTypeAttr = p }

// LockObject controls the locking of the sheet objects.
func (_edae SheetProtection) LockObject(b bool) {
	if !b {
		_edae._bcef.ObjectsAttr = nil
	} else {
		_edae._bcef.ObjectsAttr = _d.Bool(true)
	}
}

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_agea *Workbook) Uses1904Dates() bool {
	if _agea._bbae.WorkbookPr == nil || _agea._bbae.WorkbookPr.Date1904Attr == nil {
		return false
	}
	return *_agea._bbae.WorkbookPr.Date1904Attr
}

// SetIcons sets the icon set to use for display.
func (_dce IconScale) SetIcons(t _ggd.ST_IconSetType) { _dce._adcf.IconSetAttr = t }

// X returns the inner wrapped XML type.
func (_facf DataValidation) X() *_ggd.CT_DataValidation { return _facf._fcc }

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_deec *Workbook) SetActiveSheet(s Sheet) {
	for _edafb, _egbd := range _deec._fbed {
		if s._bcgb == _egbd {
			_deec.SetActiveSheetIndex(uint32(_edafb))
		}
	}
}

// Name returns the name of the table
func (_ecag Table) Name() string {
	if _ecag._cbab.NameAttr != nil {
		return *_ecag._cbab.NameAttr
	}
	return ""
}

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct {
	_fedf *Workbook
	_geef *_ggd.CT_NumFmt
}

func (_cfc CellStyle) Index() uint32 {
	for _fdc, _bge := range _cfc._ggf.Xf {
		if _cfc._cae == _bge {
			return uint32(_fdc)
		}
	}
	return 0
}

func (_ggdbb *Sheet) updateAfterRemove(_beeg uint32, _daca _gaf.UpdateAction) error {
	_gddb := _ggdbb.Name()
	_dbfa := &_gaf.UpdateQuery{UpdateType: _daca, ColumnIdx: _beeg, SheetToUpdate: _gddb}
	for _, _acaa := range _ggdbb._bdb.Sheets() {
		_dbfa.UpdateCurrentSheet = _gddb == _acaa.Name()
		for _, _adee := range _acaa.Rows() {
			for _, _cbed := range _adee.Cells() {
				if _cbed.X().F != nil {
					_bdgc := _cbed.X().F.Content
					_agda := _aec.ParseString(_bdgc)
					if _agda == nil {
						_cbed.SetError("\u0023\u0052\u0045F\u0021")
					} else {
						_abcf := _agda.Update(_dbfa)
						_cbed.X().F.Content = _c.Sprintf("\u003d\u0025\u0073", _abcf.String())
					}
				}
			}
		}
	}
	return nil
}

func (_ffe Cell) GetRawValue() (string, error) {
	switch _ffe._dbd.TAttr {
	case _ggd.ST_CellTypeInlineStr:
		if _ffe._dbd.Is == nil || _ffe._dbd.Is.T == nil {
			return "", nil
		}
		return *_ffe._dbd.Is.T, nil
	case _ggd.ST_CellTypeS:
		if _ffe._dbd.V == nil {
			return "", nil
		}
		_ag, _gbf := _de.Atoi(*_ffe._dbd.V)
		if _gbf != nil {
			return "", _gbf
		}
		return _ffe._ebb.SharedStrings.GetString(_ag)
	case _ggd.ST_CellTypeStr:
		if _ffe._dbd.F != nil {
			return _ffe._dbd.F.Content, nil
		}
	}
	if _ffe._dbd.V == nil {
		return "", nil
	}
	return *_ffe._dbd.V, nil
}

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_bdc CellStyle) SetHorizontalAlignment(a _ggd.ST_HorizontalAlignment) {
	if _bdc._cae.Alignment == nil {
		_bdc._cae.Alignment = _ggd.NewCT_CellAlignment()
	}
	_bdc._cae.Alignment.HorizontalAttr = a
	_bdc._cae.ApplyAlignmentAttr = _d.Bool(true)
}

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_ebde CellStyle) SetVerticalAlignment(a _ggd.ST_VerticalAlignment) {
	if _ebde._cae.Alignment == nil {
		_ebde._cae.Alignment = _ggd.NewCT_CellAlignment()
	}
	_ebde._cae.ApplyAlignmentAttr = _d.Bool(true)
	_ebde._cae.Alignment.VerticalAttr = a
}

// SetRow set the row of the cell marker.
func (_gccc CellMarker) SetRow(row int32) { _gccc._bcb.Row = row }

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_ecff TwoCellAnchor) TopLeft() CellMarker { return CellMarker{_ecff._babb.From} }

// SetPasswordHash sets the password hash to the input.
func (_cedfg SheetProtection) SetPasswordHash(pwHash string) {
	_cedfg._bcef.PasswordAttr = _d.String(pwHash)
}

// ClearFill clears any fill configuration from the cell style.
func (_fbee CellStyle) ClearFill() { _fbee._cae.FillIdAttr = nil; _fbee._cae.ApplyFillAttr = nil }

var _ecdc *_fb.Regexp = _fb.MustCompile("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024")

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_egaa Sheet) ValidateWithPath(path string) error { return _egaa._bcgb.ValidateWithPath(path) }

func (_ac Border) SetLeft(style _ggd.ST_BorderStyle, c _cg.Color) {
	if _ac._aac.Left == nil {
		_ac._aac.Left = _ggd.NewCT_BorderPr()
	}
	_ac._aac.Left.Color = _ggd.NewCT_Color()
	_ac._aac.Left.Color.RgbAttr = c.AsRGBAString()
	_ac._aac.Left.StyleAttr = style
}

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_gaa Cell) SetString(s string) int {
	_gaa._ebb.ensureSharedStringsRelationships()
	_gaa.clearValue()
	_dca := _gaa._ebb.SharedStrings.AddString(s)
	_gaa._dbd.V = _d.String(_de.Itoa(_dca))
	_gaa._dbd.TAttr = _ggd.ST_CellTypeS
	return _dca
}

// SetPassword sets the password hash to a hash of the input password.
func (_ebbgd SheetProtection) SetPassword(pw string) { _ebbgd.SetPasswordHash(PasswordHash(pw)) }

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_dec AbsoluteAnchor) SetRowOffset(m _ae.Distance) {
	_dec._cd.Pos.YAttr.ST_CoordinateUnqualified = _d.Int64(int64(m / _ae.EMU))
}

func (_cgb *evalContext) Cell(ref string, ev _aec.Evaluator) _aec.Result {
	if !_agfe(ref) {
		return _aec.MakeErrorResultType(_aec.ErrorTypeName, "")
	}
	_dcf := _cgb._afdd.Name() + "\u0021" + ref
	if _fddab, _bbgd := ev.GetFromCache(_dcf); _bbgd {
		return _fddab
	}
	_ccbe, _ddg := _eg.ParseCellReference(ref)
	if _ddg != nil {
		return _aec.MakeErrorResult(_c.Sprintf("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", ref, _ddg))
	}
	if _cgb._cga != 0 && !_ccbe.AbsoluteColumn {
		_ccbe.ColumnIdx += _cgb._cga
		_ccbe.Column = _eg.IndexToColumn(_ccbe.ColumnIdx)
	}
	if _cgb._fba != 0 && !_ccbe.AbsoluteRow {
		_ccbe.RowIdx += _cgb._fba
	}
	_fffb := _cgb._afdd.Cell(_ccbe.String())
	if _fffb.HasFormula() {
		if _, _gbgf := _cgb._acde[ref]; _gbgf {
			return _aec.MakeErrorResult("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020" + ref)
		}
		_cgb._acde[ref] = struct{}{}
		_dac := ev.Eval(_cgb, _fffb.GetFormula())
		delete(_cgb._acde, ref)
		ev.SetCache(_dcf, _dac)
		return _dac
	}
	if _fffb.IsEmpty() {
		_eefe := _aec.MakeEmptyResult()
		ev.SetCache(_dcf, _eefe)
		return _eefe
	} else if _fffb.IsNumber() {
		_ccda, _ := _fffb.GetValueAsNumber()
		_ffg := _aec.MakeNumberResult(_ccda)
		ev.SetCache(_dcf, _ffg)
		return _ffg
	} else if _fffb.IsBool() {
		_dgaa, _ := _fffb.GetValueAsBool()
		_gea := _aec.MakeBoolResult(_dgaa)
		ev.SetCache(_dcf, _gea)
		return _gea
	}
	_bbd, _ := _fffb.GetRawValue()
	if _fffb.IsError() {
		_bbde := _aec.MakeErrorResult("")
		_bbde.ValueString = _bbd
		ev.SetCache(_dcf, _bbde)
		return _bbde
	}
	_dddd := _aec.MakeStringResult(_bbd)
	ev.SetCache(_dcf, _dddd)
	return _dddd
}

func (_cgd Cell) getLocked() bool {
	if _cgd._dbd.SAttr == nil {
		return false
	}
	_gfc := *_cgd._dbd.SAttr
	_ecaa := _cgd._ebb.StyleSheet.GetCellStyle(_gfc)
	return *_ecaa._cae.Protection.LockedAttr
}

// X returns the inner wrapped XML type.
func (_edecg IconScale) X() *_ggd.CT_IconSet { return _edecg._adcf }

// SetWidthCells is a no-op.
func (_bddf OneCellAnchor) SetWidthCells(int32) {}

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_feed *Workbook) RecalculateFormulas() {
	for _, _gcfg := range _feed.Sheets() {
		_gcfg.RecalculateFormulas()
	}
}

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_eda Cell) GetString() string {
	switch _eda._dbd.TAttr {
	case _ggd.ST_CellTypeInlineStr:
		if _eda._dbd.Is != nil && _eda._dbd.Is.T != nil {
			return *_eda._dbd.Is.T
		}
		if _eda._dbd.V != nil {
			return *_eda._dbd.V
		}
	case _ggd.ST_CellTypeS:
		if _eda._dbd.V == nil {
			return ""
		}
		_ffdc, _af := _de.Atoi(*_eda._dbd.V)
		if _af != nil {
			return ""
		}
		_ccd, _af := _eda._ebb.SharedStrings.GetString(_ffdc)
		if _af != nil {
			return ""
		}
		return _ccd
	}
	if _eda._dbd.V == nil {
		return ""
	}
	return *_eda._dbd.V
}

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_abcb *Sheet) SheetViews() []SheetView {
	if _abcb._bcgb.SheetViews == nil {
		return nil
	}
	_feae := []SheetView{}
	for _, _ddfec := range _abcb._bcgb.SheetViews.SheetView {
		_feae = append(_feae, SheetView{_ddfec})
	}
	return _feae
}

var _edeb = _d.RelativeFilename(_d.DocTypeSpreadsheet, _d.OfficeDocumentType, _d.SharedStringsType, 0)

func (_ecf DifferentialStyle) Fill() Fill {
	if _ecf._dggf.Fill == nil {
		_ecf._dggf.Fill = _ggd.NewCT_Fill()
	}
	return Fill{_ecf._dggf.Fill, nil}
}

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_bef Comparer) LessRows(column string, lhs, rhs Row) bool {
	var _cccd, _aeg Cell
	for _, _cdb := range lhs.Cells() {
		_decc, _ := _eg.ParseCellReference(_cdb.Reference())
		if _decc.Column == column {
			_cccd = _cdb
			break
		}
	}
	for _, _adaf := range rhs.Cells() {
		_bafb, _ := _eg.ParseCellReference(_adaf.Reference())
		if _bafb.Column == column {
			_aeg = _adaf
			break
		}
	}
	return _bef.LessCells(_cccd, _aeg)
}

// X returns the inner wrapped XML type.
func (_gcba ConditionalFormatting) X() *_ggd.CT_ConditionalFormatting { return _gcba._acdg }

type SheetProtection struct{ _bcef *_ggd.CT_SheetProtection }

// SetColor sets teh color of the databar.
func (_bcbe DataBarScale) SetColor(c _cg.Color) {
	_bcbe._edfg.Color = _ggd.NewCT_Color()
	_bcbe._edfg.Color.RgbAttr = c.AsRGBAString()
}

func (_afd Cell) setLocked(_eba bool) {
	_ddda := _afd._dbd.SAttr
	if _ddda != nil {
		_efg := _afd._ebb.StyleSheet.GetCellStyle(*_ddda)
		if _efg._cae.Protection == nil {
			_efg._cae.Protection = _ggd.NewCT_CellProtection()
		}
		_efg._cae.Protection.LockedAttr = &_eba
	}
}

// Content returns the content of the defined range (the range in most cases)/
func (_dbdf DefinedName) Content() string { return _dbdf._cecc.Content }

// SetRowOffset sets the row offset of the two cell anchor
func (_fcab TwoCellAnchor) SetRowOffset(m _ae.Distance) {
	_dfac := m - _fcab.TopLeft().RowOffset()
	_fcab.TopLeft().SetRowOffset(m)
	_fcab.BottomRight().SetRowOffset(_fcab.BottomRight().RowOffset() + _dfac)
}

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_bag Row) CellsWithEmpty(lastColIdx uint32) []Cell {
	_bega := []Cell{}
	for _bfb := uint32(0); _bfb <= lastColIdx; _bfb++ {
		_bda := _bag.Cell(_eg.IndexToColumn(_bfb))
		_bega = append(_bega, _bda)
	}
	return _bega
}

// SetUnderline controls if the run is underlined.
func (_bed RichTextRun) SetUnderline(u _ggd.ST_UnderlineValues) {
	_bed.ensureRpr()
	_bed._aggb.RPr.U = _ggd.NewCT_UnderlineProperty()
	_bed._aggb.RPr.U.ValAttr = u
}

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_bdee StyleSheet) AddCellStyle() CellStyle {
	_gfde := _ggd.NewCT_Xf()
	_bdee._gcac.CellXfs.Xf = append(_bdee._gcac.CellXfs.Xf, _gfde)
	_bdee._gcac.CellXfs.CountAttr = _d.Uint32(uint32(len(_bdee._gcac.CellXfs.Xf)))
	return CellStyle{_bdee._cecga, _gfde, _bdee._gcac.CellXfs}
}

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_cffc Sheet) RangeReference(n string) string {
	_fbae := _dgd.Split(n, "\u003a")
	_agad, _ := _eg.ParseCellReference(_fbae[0])
	_ebefc := _c.Sprintf("\u0024\u0025\u0073\u0024\u0025\u0064", _agad.Column, _agad.RowIdx)
	if len(_fbae) == 1 {
		return _c.Sprintf("\u0027%\u0073\u0027\u0021\u0025\u0073", _cffc.Name(), _ebefc)
	}
	_eaa, _ := _eg.ParseCellReference(_fbae[1])
	_ffag := _c.Sprintf("\u0024\u0025\u0073\u0024\u0025\u0064", _eaa.Column, _eaa.RowIdx)
	return _c.Sprintf("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073", _cffc.Name(), _ebefc, _ffag)
}

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_eff Cell) GetCachedFormulaResult() string {
	if _eff._dbd.V != nil {
		return *_eff._dbd.V
	}
	return ""
}

func (_ddc CellStyle) SetNumberFormat(s string) {
	_gdf := _ddc._aaeg.StyleSheet.AddNumberFormat()
	_gdf.SetFormat(s)
	_ddc._cae.ApplyNumberFormatAttr = _d.Bool(true)
	_ddc._cae.NumFmtIdAttr = _d.Uint32(_gdf.ID())
}

var _gccf []string = []string{"\u007a\u0068\u002dH\u004b", "\u007a\u0068\u002dM\u004f", "\u007a\u0068\u002dC\u004e", "\u007a\u0068\u002dS\u0047", "\u007a\u0068\u002dT\u0057", "\u006a\u0061\u002dJ\u0050", "\u006b\u006f\u002dK\u0052"}

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet(wb *Workbook) StyleSheet {
	_ccee := _ggd.NewStyleSheet()
	_ccee.CellStyleXfs = _ggd.NewCT_CellStyleXfs()
	_ccee.CellXfs = _ggd.NewCT_CellXfs()
	_ccee.CellStyles = _ggd.NewCT_CellStyles()
	_dcff := _ggd.NewCT_CellStyle()
	_dcff.NameAttr = _d.String("\u004e\u006f\u0072\u006d\u0061\u006c")
	_dcff.XfIdAttr = 0
	_dcff.BuiltinIdAttr = _d.Uint32(0)
	_ccee.CellStyles.CellStyle = append(_ccee.CellStyles.CellStyle, _dcff)
	_ccee.CellStyles.CountAttr = _d.Uint32(uint32(len(_ccee.CellStyles.CellStyle)))
	_gdg := _ggd.NewCT_Xf()
	_gdg.NumFmtIdAttr = _d.Uint32(0)
	_gdg.FontIdAttr = _d.Uint32(0)
	_gdg.FillIdAttr = _d.Uint32(0)
	_gdg.BorderIdAttr = _d.Uint32(0)
	_ccee.CellStyleXfs.Xf = append(_ccee.CellStyleXfs.Xf, _gdg)
	_ccee.CellStyleXfs.CountAttr = _d.Uint32(uint32(len(_ccee.CellStyleXfs.Xf)))
	_bfbbc := NewFills()
	_ccee.Fills = _bfbbc.X()
	_cdfa := _bfbbc.AddFill().SetPatternFill()
	_cdfa.SetPattern(_ggd.ST_PatternTypeNone)
	_cdfa = _bfbbc.AddFill().SetPatternFill()
	_cdfa.SetPattern(_ggd.ST_PatternTypeGray125)
	_ccee.Fonts = _ggd.NewCT_Fonts()
	_ccee.Borders = _ggd.NewCT_Borders()
	_fegb := StyleSheet{wb, _ccee}
	_fegb.AddBorder().InitializeDefaults()
	_cdcf := _fegb.AddFont()
	_cdcf.SetName("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_cdcf.SetSize(11)
	_edgf := _ggd.NewCT_Xf()
	*_edgf = *_gdg
	_edgf.XfIdAttr = _d.Uint32(0)
	_ccee.CellXfs.Xf = append(_ccee.CellXfs.Xf, _edgf)
	_ccee.CellXfs.CountAttr = _d.Uint32(uint32(len(_ccee.CellXfs.Xf)))
	return _fegb
}

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_fc Cell) GetValueAsTime() (_dga.Time, error) {
	if _fc._dbd.TAttr != _ggd.ST_CellTypeUnset {
		return _dga.Time{}, _gb.New("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t")
	}
	if _fc._dbd.V == nil {
		return _dga.Time{}, _gb.New("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065")
	}
	_bbf, _, _ebd := _dd.ParseFloat(*_fc._dbd.V, 10, 128, _dd.ToNearestEven)
	if _ebd != nil {
		return _dga.Time{}, _ebd
	}
	_ggg := new(_dd.Float)
	_ggg.SetUint64(uint64(24 * _dga.Hour))
	_bbf.Mul(_bbf, _ggg)
	_bbaa, _ := _bbf.Uint64()
	_fca := _fc._ebb.Epoch().Add(_dga.Duration(_bbaa))
	return _gcd(_fca), nil
}

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{ _babb *_ce.CT_TwoCellAnchor }

// SetOperator sets the operator for the rule.
func (_fdcb ConditionalFormattingRule) SetOperator(t _ggd.ST_ConditionalFormattingOperator) {
	_fdcb._dbed.OperatorAttr = t
}

func (_fdbb *Sheet) getAllCellsInFormulaArrays(_dgegc bool) (map[string]bool, error) {
	_ebec := _aec.NewEvaluator()
	_fcaf := _fdbb.FormulaContext()
	_fabfa := map[string]bool{}
	for _, _eabg := range _fdbb.Rows() {
		for _, _cfea := range _eabg.Cells() {
			if _cfea.X().F != nil {
				_dcee := _cfea.X().F.Content
				if _cfea.X().F.TAttr == _ggd.ST_CellFormulaTypeArray {
					_bab := _ebec.Eval(_fcaf, _dcee).AsString()
					if _bab.Type == _aec.ResultTypeError {
						_d.Log("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073", _dcee, _bab.ErrorMessage)
						_cfea.X().V = nil
					}
					if _bab.Type == _aec.ResultTypeArray {
						_gede, _bfcd := _eg.ParseCellReference(_cfea.Reference())
						if _bfcd != nil {
							return map[string]bool{}, _bfcd
						}
						if (_dgegc && len(_bab.ValueArray) == 1) || (!_dgegc && len(_bab.ValueArray[0]) == 1) {
							continue
						}
						for _fdaa, _cebf := range _bab.ValueArray {
							_cgfaf := _gede.RowIdx + uint32(_fdaa)
							for _aabgg := range _cebf {
								_gbffa := _eg.IndexToColumn(_gede.ColumnIdx + uint32(_aabgg))
								_fabfa[_c.Sprintf("\u0025\u0073\u0025\u0064", _gbffa, _cgfaf)] = true
							}
						}
					} else if _bab.Type == _aec.ResultTypeList {
						_ebfaa, _cfgb := _eg.ParseCellReference(_cfea.Reference())
						if _cfgb != nil {
							return map[string]bool{}, _cfgb
						}
						if _dgegc || len(_bab.ValueList) == 1 {
							continue
						}
						_aggfg := _ebfaa.RowIdx
						for _cdge := range _bab.ValueList {
							_cefa := _eg.IndexToColumn(_ebfaa.ColumnIdx + uint32(_cdge))
							_fabfa[_c.Sprintf("\u0025\u0073\u0025\u0064", _cefa, _aggfg)] = true
						}
					}
				}
			}
		}
	}
	return _fabfa, nil
}

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_beede *Sheet) Cell(cellRef string) Cell {
	_dgc, _fddd := _eg.ParseCellReference(cellRef)
	if _fddd != nil {
		_d.Log("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073", _fddd)
		return _beede.AddRow().AddCell()
	}
	return _beede.Row(_dgc.RowIdx).Cell(_dgc.Column)
}

// SetRowOffset sets a column offset in absolute distance.
func (_ace CellMarker) SetRowOffset(m _ae.Distance) {
	_ace._bcb.RowOff.ST_CoordinateUnqualified = _d.Int64(int64(m / _ae.EMU))
}

// SetPasswordHash sets the password hash to the input.
func (_dfcaf WorkbookProtection) SetPasswordHash(pwHash string) {
	_dfcaf._decb.WorkbookPasswordAttr = _d.String(pwHash)
}

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface {

	// BottomRight returns the CellMaker for the bottom right corner of the
	// anchor.
	BottomRight() CellMarker

	// TopLeft returns the CellMaker for the top left corner of the anchor.
	TopLeft() CellMarker

	// MoveTo repositions the anchor without changing the objects size.
	MoveTo(_dc, _bf int32)

	// SetWidth sets the width of the anchored object. It is not compatible with
	// SetWidthCells.
	SetWidth(_bga _ae.Distance)

	// SetWidthCells sets the height the anchored object by moving the right
	// hand side. It is not compatible with SetWidth.
	SetWidthCells(_bd int32)

	// SetHeight sets the height of the anchored object. It is not compatible
	// with SetHeightCells.
	SetHeight(_ff _ae.Distance)

	// SetHeightCells sets the height the anchored object by moving the bottom.
	// It is not compatible with SetHeight.
	SetHeightCells(_df int32)

	// SetColOffset sets the column offset of the top-left anchor.
	SetColOffset(_dba _ae.Distance)

	// SetRowOffset sets the row offset of the top-left anchor.
	SetRowOffset(_bde _ae.Distance)

	// Type returns the type of anchor
	Type() AnchorType
}

// AddString adds a string to the shared string cache.
func (_eeaa SharedStrings) AddString(v string) int {
	if _cefd, _eebba := _eeaa._daff[v]; _eebba {
		return _cefd
	}
	_fcf := _ggd.NewCT_Rst()
	_fcf.T = _d.String(v)
	_eeaa._gce.Si = append(_eeaa._gce.Si, _fcf)
	_gcca := len(_eeaa._gce.Si) - 1
	_eeaa._daff[v] = _gcca
	_eeaa._gce.CountAttr = _d.Uint32(uint32(len(_eeaa._gce.Si)))
	_eeaa._gce.UniqueCountAttr = _eeaa._gce.CountAttr
	return _gcca
}

// Operator returns the operator for the rule
func (_degf ConditionalFormattingRule) Operator() _ggd.ST_ConditionalFormattingOperator {
	return _degf._dbed.OperatorAttr
}

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_gc Cell) SetStringByID(id int) {
	_gc._ebb.ensureSharedStringsRelationships()
	_gc.clearValue()
	_gc._dbd.V = _d.String(_de.Itoa(id))
	_gc._dbd.TAttr = _ggd.ST_CellTypeS
}

func (_bgbc *Workbook) addCustomRelationships() {
	_bgbc.ContentTypes.AddOverride("/\u0064o\u0063\u0050\u0072\u006f\u0070\u0073\u002f\u0063u\u0073\u0074\u006f\u006d.x\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069\u0063a\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065n\u0078\u006d\u006c\u0066\u006fr\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0063\u0075\u0073\u0074\u006f\u006d\u002d\u0070r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073+\u0078\u006d\u006c")
	_bgbc.Rels.AddRelationship("\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c", _d.CustomPropertiesType)
}

func _gba(_bcgd *Sheet) *evalContext {
	return &evalContext{_afdd: _bcgd, _acde: make(map[string]struct{})}
}

// Reference returns the region of cells that are merged.
func (_gef MergedCell) Reference() string { return _gef._ddge.RefAttr }

// SetColor sets the text color.
func (_gedg RichTextRun) SetColor(c _cg.Color) {
	_gedg.ensureRpr()
	_gedg._aggb.RPr.Color = _ggd.NewCT_Color()
	_fcae := "\u0066\u0066" + *c.AsRGBString()
	_gedg._aggb.RPr.Color.RgbAttr = &_fcae
}

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_cbc Cell) SetStyle(cs CellStyle) { _cbc.SetStyleIndex(cs.Index()) }

// Comments returns the comments for a sheet.
func (_cddb *Sheet) Comments() Comments {
	for _cce, _fded := range _cddb._bdb._fbed {
		if _fded == _cddb._bcgb {
			if _cddb._bdb._cbge[_cce] == nil {
				_cddb._bdb._cbge[_cce] = _ggd.NewComments()
				_cddb._bdb._fdbe[_cce].AddAutoRelationship(_d.DocTypeSpreadsheet, _d.WorksheetType, _cce+1, _d.CommentsType)
				_cddb._bdb.ContentTypes.AddOverride(_d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.CommentsType, _cce+1), _d.CommentsContentType)
			}
			if len(_cddb._bdb._cbbfe) == 0 {
				_cddb._bdb._cbbfe = append(_cddb._bdb._cbbfe, _cc.NewCommentDrawing())
				_affd := _cddb._bdb._fdbe[_cce].AddAutoRelationship(_d.DocTypeSpreadsheet, _d.WorksheetType, 1, _d.VMLDrawingType)
				if _cddb._bcgb.LegacyDrawing == nil {
					_cddb._bcgb.LegacyDrawing = _ggd.NewCT_LegacyDrawing()
				}
				_cddb._bcgb.LegacyDrawing.IdAttr = _affd.ID()
			}
			return Comments{_cddb._bdb, _cddb._bdb._cbge[_cce]}
		}
	}
	_d.Log("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t")
	return Comments{}
}

// SetReference sets the regin of cells that the merged cell applies to.
func (_aedc MergedCell) SetReference(ref string) { _aedc._ddge.RefAttr = ref }

// SetXSplit sets the column split point
func (_eccdd SheetView) SetXSplit(v float64) {
	_eccdd.ensurePane()
	_eccdd._baef.Pane.XSplitAttr = _d.Float64(v)
}

// RemoveSheet removes the sheet with the given index from the workbook.
func (_begde *Workbook) RemoveSheet(ind int) error {
	if _begde.SheetCount() <= ind {
		return ErrorNotFound
	}
	for _, _dfba := range _begde._adebd.Relationships() {
		if _dfba.ID() == _begde._bbae.Sheets.Sheet[ind].IdAttr {
			_begde._adebd.Remove(_dfba)
			break
		}
	}
	_begde.ContentTypes.RemoveOverride(_d.AbsoluteFilename(_d.DocTypeSpreadsheet, _d.WorksheetContentType, ind+1))
	copy(_begde._fbed[ind:], _begde._fbed[ind+1:])
	_begde._fbed = _begde._fbed[:len(_begde._fbed)-1]
	_acdb := _begde._bbae.Sheets.Sheet[ind]
	copy(_begde._bbae.Sheets.Sheet[ind:], _begde._bbae.Sheets.Sheet[ind+1:])
	_begde._bbae.Sheets.Sheet = _begde._bbae.Sheets.Sheet[:len(_begde._bbae.Sheets.Sheet)-1]
	for _dgcf := range _begde._bbae.Sheets.Sheet {
		if _begde._bbae.Sheets.Sheet[_dgcf].SheetIdAttr > _acdb.SheetIdAttr {
			_begde._bbae.Sheets.Sheet[_dgcf].SheetIdAttr--
		}
	}
	copy(_begde._fdbe[ind:], _begde._fdbe[ind+1:])
	_begde._fdbe = _begde._fdbe[:len(_begde._fdbe)-1]
	copy(_begde._cbge[ind:], _begde._cbge[ind+1:])
	_begde._cbge = _begde._cbge[:len(_begde._cbge)-1]
	return nil
}

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{ _aaed *_ggd.CT_ColorScale }

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{ _baef *_ggd.CT_SheetView }

// HasNumberFormat returns true if the cell style has a number format applied.
func (_bfe CellStyle) HasNumberFormat() bool {
	return _bfe._cae.NumFmtIdAttr != nil && _bfe._cae.ApplyNumberFormatAttr != nil && *_bfe._cae.ApplyNumberFormatAttr
}

func (_eeb Font) SetItalic(b bool) {
	if b {
		_eeb._beba.I = []*_ggd.CT_BooleanProperty{{}}
	} else {
		_eeb._beba.I = nil
	}
}

// X returns the inner wrapped XML type.
func (_aed Border) X() *_ggd.CT_Border { return _aed._aac }

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_edce *Sheet) ClearCachedFormulaResults() {
	for _, _ggeg := range _edce.Rows() {
		for _, _aabc := range _ggeg.Cells() {
			if _aabc.X().F != nil {
				_aabc.X().V = nil
			}
		}
	}
}

// IconScale maps values to icons.
type IconScale struct{ _adcf *_ggd.CT_IconSet }

// ClearNumberFormat removes any number formatting from the style.
func (_fed CellStyle) ClearNumberFormat() {
	_fed._cae.NumFmtIdAttr = nil
	_fed._cae.ApplyNumberFormatAttr = nil
}

func (_aebd SheetView) ensurePane() {
	if _aebd._baef.Pane == nil {
		_aebd._baef.Pane = _ggd.NewCT_Pane()
		_aebd._baef.Pane.ActivePaneAttr = _ggd.ST_PaneBottomLeft
	}
}

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{ _bbaac *_ce.CT_OneCellAnchor }

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_ggde Cell) Reference() string {
	if _ggde._dbd.RAttr != nil {
		return *_ggde._dbd.RAttr
	}
	return ""
}

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_bdeg ConditionalFormattingRule) SetDataBar() DataBarScale {
	_bdeg.clear()
	_bdeg.SetType(_ggd.ST_CfTypeDataBar)
	_bdeg._dbed.DataBar = _ggd.NewCT_DataBar()
	_dae := DataBarScale{_bdeg._dbed.DataBar}
	_dae.SetShowValue(true)
	_dae.SetMinLength(10)
	_dae.SetMaxLength(90)
	return _dae
}

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_dfbe *Sheet) AddNumberedRow(rowNum uint32) Row {
	_acgb := _ggd.NewCT_Row()
	_acgb.RAttr = _d.Uint32(rowNum)
	_dfbe._bcgb.SheetData.Row = append(_dfbe._bcgb.SheetData.Row, _acgb)
	_a.Slice(_dfbe._bcgb.SheetData.Row, func(_bfgb, _bbec int) bool {
		_adea := _dfbe._bcgb.SheetData.Row[_bfgb].RAttr
		_aacg := _dfbe._bcgb.SheetData.Row[_bbec].RAttr
		if _adea == nil {
			return true
		}
		if _aacg == nil {
			return true
		}
		return *_adea < *_aacg
	})
	return Row{_dfbe._bdb, _dfbe, _acgb}
}

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_agf Comment) SetAuthor(author string) {
	_agf._gbfb.AuthorIdAttr = Comments{_agf._aab, _agf._adb}.getOrCreateAuthor(author)
}

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_ffggc TwoCellAnchor) SetHeightCells(h int32) {
	_ffggc.SetHeight(0)
	_ddfc := _ffggc.TopLeft()
	_aadce := _ffggc.BottomRight()
	_aadce.SetRow(_ddfc.Row() + h)
}

// SetNumber sets the cell type to number, and the value to the given number
func (_ebbg Cell) SetNumber(v float64) {
	_ebbg.clearValue()
	if _bg.IsNaN(v) || _bg.IsInf(v, 0) {
		_ebbg._dbd.TAttr = _ggd.ST_CellTypeE
		_ebbg._dbd.V = _d.String("\u0023\u004e\u0055M\u0021")
		return
	}
	_ebbg._dbd.TAttr = _ggd.ST_CellTypeN
	_ebbg._dbd.V = _d.String(_de.FormatFloat(v, 'f', -1, 64))
}

func (_bcgf StyleSheet) GetCellStyle(id uint32) CellStyle {
	for _daaa, _dgcaa := range _bcgf._gcac.CellXfs.Xf {
		if uint32(_daaa) == id {
			return CellStyle{_bcgf._cecga, _dgcaa, _bcgf._gcac.CellXfs}
		}
	}
	return CellStyle{}
}

// SetRowOffset sets the row offset of the top-left anchor.
func (_caf OneCellAnchor) SetRowOffset(m _ae.Distance) { _caf.TopLeft().SetRowOffset(m) }

// ColOffset returns the offset from the row cell.
func (_edad CellMarker) ColOffset() _ae.Distance {
	if _edad._bcb.RowOff.ST_CoordinateUnqualified == nil {
		return 0
	}
	return _ae.Distance(float64(*_edad._bcb.ColOff.ST_CoordinateUnqualified) * _ae.EMU)
}

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct {
	_debc *Workbook
	_fefc *_ce.WsDr
}

// IsEmpty returns true if the cell is empty.
func (_caa Cell) IsEmpty() bool {
	return _caa._dbd.TAttr == _ggd.ST_CellTypeUnset && _caa._dbd.V == nil && _caa._dbd.F == nil
}

// SheetCount returns the number of sheets in the workbook.
func (_bffc Workbook) SheetCount() int { return len(_bffc._fbed) }

// GetFilename returns the filename of the context's workbook.
func (_acfd *evalContext) GetFilename() string { return _acfd._afdd._bdb.GetFilename() }

// SetHeight sets the row height in points.
func (_faa Row) SetHeight(d _ae.Distance) {
	_faa._dggg.HtAttr = _d.Float64(float64(d))
	_faa._dggg.CustomHeightAttr = _d.Bool(true)
}

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_cebc *Sheet) RemoveMergedCell(mc MergedCell) {
	for _dadg, _ffae := range _cebc._bcgb.MergeCells.MergeCell {
		if _ffae == mc.X() {
			copy(_cebc._bcgb.MergeCells.MergeCell[_dadg:], _cebc._bcgb.MergeCells.MergeCell[_dadg+1:])
			_cebc._bcgb.MergeCells.MergeCell[len(_cebc._bcgb.MergeCells.MergeCell)-1] = nil
			_cebc._bcgb.MergeCells.MergeCell = _cebc._bcgb.MergeCells.MergeCell[:len(_cebc._bcgb.MergeCells.MergeCell)-1]
		}
	}
}
