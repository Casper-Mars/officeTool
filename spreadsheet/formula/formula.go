//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package formula provides formula parsing and evaluation. The lexer is
// implemented with a ragel grammar while the the parser is implemented with
// goyacc. The entire formula grammar is not implemented and not all functions
// are supported yet. For compatibility sake, upon failure to parse or execute a
// formula, unioffice leaves cached formula results blank allowing Excel to compute
// formulas upon load. This is similar to what most other Excel libraries do
// which leave all cached results blank instead of attempting to execute
// formulas.
//
// The unit tests for this package are unique in that we can take advantage of
// "cached" formula results that Excel/LibreOffice write to the sheet.  These
// are the computed results of a formula in string form.  By comparing these
// values to the value computed by the unioffice evaluation of the formula, adding
// a new test means just adding a new formula to one of the reference sheets
// with Excel. During the unit test, we evaluate the formula and compare it to
// the value that Excel computed.  If they're the same, the test passes.
package formula

import (
	_d "bytes"
	_c "fmt"
	_ge "github.com/Casper-Mars/officeTool"
	_ea "github.com/Casper-Mars/officeTool/internal/mergesort"
	_ag "github.com/Casper-Mars/officeTool/internal/wildcard"
	_ca "github.com/Casper-Mars/officeTool/spreadsheet/format"
	_cb "github.com/Casper-Mars/officeTool/spreadsheet/reference"
	_cc "github.com/Casper-Mars/officeTool/spreadsheet/update"
	_e "io"
	_dc "math"
	_b "math/big"
	_gb "math/rand"
	_gf "regexp"
	_a "sort"
	_ff "strconv"
	_ee "strings"
	_f "sync"
	_ce "time"
	_gc "unicode"
)

// Eval evaluates the binary expression using the context given.
func (_ec BinaryExpr) Eval(ctx Context, ev Evaluator) Result {
	_eg := _ec._age.Eval(ctx, ev)
	if _eg.Type == ResultTypeError {
		return _eg
	}
	_de := _ec._bd.Eval(ctx, ev)
	if _de.Type == ResultTypeError {
		return _de
	}
	if _eg.Type == _de.Type {
		if _eg.Type == ResultTypeArray {
			if !_dea(_eg.ValueArray, _de.ValueArray) {
				return MakeErrorResult("l\u0068\u0073\u002f\u0072\u0068\u0073 \u0073\u0068\u006f\u0075\u006c\u0064 \u0068\u0061\u0076\u0065\u0020\u0073\u0061m\u0065\u0020\u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006fn\u0073")
			}
			return _ffd(_ec._dd, _eg.ValueArray, _de.ValueArray)
		} else if _eg.Type == ResultTypeList {
			if len(_eg.ValueList) != len(_de.ValueList) {
				return MakeErrorResult("l\u0068\u0073\u002f\u0072\u0068\u0073 \u0073\u0068\u006f\u0075\u006c\u0064 \u0068\u0061\u0076\u0065\u0020\u0073\u0061m\u0065\u0020\u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006fn\u0073")
			}
			return _fe(_ec._dd, _eg.ValueList, _de.ValueList)
		}
	} else if _eg.Type == ResultTypeArray && (_de.Type == ResultTypeNumber || _de.Type == ResultTypeString) {
		return _eca(_ec._dd, _eg.ValueArray, _de)
	} else if _eg.Type == ResultTypeList && (_de.Type == ResultTypeNumber || _de.Type == ResultTypeString) {
		return _ecaf(_ec._dd, _eg.ValueList, _de)
	}
	switch _ec._dd {
	case BinOpTypePlus:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeNumberResult(_eg.ValueNumber + _de.ValueNumber)
			}
		}
	case BinOpTypeMinus:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeNumberResult(_eg.ValueNumber - _de.ValueNumber)
			}
		}
	case BinOpTypeMult:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeNumberResult(_eg.ValueNumber * _de.ValueNumber)
			}
		}
	case BinOpTypeDiv:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				if _de.ValueNumber == 0 {
					return MakeErrorResultType(ErrorTypeDivideByZero, "\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079 \u007a\u0065\u0072\u006f")
				}
				return MakeNumberResult(_eg.ValueNumber / _de.ValueNumber)
			}
		}
	case BinOpTypeExp:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeNumberResult(_dc.Pow(_eg.ValueNumber, _de.ValueNumber))
			}
		}
	case BinOpTypeLT:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeBoolResult(_eg.ValueNumber < _de.ValueNumber)
			}
			if _eg.Type == ResultTypeString {
				return MakeBoolResult(_eg.ValueString < _de.ValueString)
			}
			if _eg.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if _eg.Type == ResultTypeString && _de.Type == ResultTypeNumber {
			return MakeBoolResult(false)
		} else if _eg.Type == ResultTypeNumber && _de.Type == ResultTypeString {
			return MakeBoolResult(true)
		} else if _eg.Type == ResultTypeEmpty && (_de.Type == ResultTypeNumber || _de.Type == ResultTypeString) {
			return MakeBoolResult(true)
		} else if (_eg.Type == ResultTypeNumber || _eg.Type == ResultTypeString) && _de.Type == ResultTypeEmpty {
			return MakeBoolResult(false)
		}
	case BinOpTypeGT:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeBoolResult(_eg.ValueNumber > _de.ValueNumber)
			}
			if _eg.Type == ResultTypeString {
				return MakeBoolResult(_eg.ValueString > _de.ValueString)
			}
			if _eg.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if _eg.Type == ResultTypeString && _de.Type == ResultTypeNumber {
			return MakeBoolResult(true)
		} else if _eg.Type == ResultTypeNumber && _de.Type == ResultTypeString {
			return MakeBoolResult(false)
		} else if _eg.Type == ResultTypeEmpty && (_de.Type == ResultTypeNumber || _de.Type == ResultTypeString) {
			return MakeBoolResult(false)
		} else if (_eg.Type == ResultTypeNumber || _eg.Type == ResultTypeString) && _de.Type == ResultTypeEmpty {
			return MakeBoolResult(true)
		}
	case BinOpTypeEQ:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeBoolResult(_eg.ValueNumber == _de.ValueNumber)
			}
			if _eg.Type == ResultTypeString {
				return MakeBoolResult(_eg.ValueString == _de.ValueString)
			}
			if _eg.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if (_eg.Type == ResultTypeString && _de.Type == ResultTypeNumber) || (_eg.Type == ResultTypeNumber && _de.Type == ResultTypeString) {
			return MakeBoolResult(false)
		} else if _eg.Type == ResultTypeEmpty && (_de.Type == ResultTypeNumber || _de.Type == ResultTypeString) {
			return MakeBoolResult(_ba(_de))
		} else if (_eg.Type == ResultTypeNumber || _eg.Type == ResultTypeString) && _de.Type == ResultTypeEmpty {
			return MakeBoolResult(_ba(_eg))
		}
	case BinOpTypeNE:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeBoolResult(_eg.ValueNumber != _de.ValueNumber)
			}
			if _eg.Type == ResultTypeString {
				return MakeBoolResult(_eg.ValueString != _de.ValueString)
			}
			if _eg.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if (_eg.Type == ResultTypeString && _de.Type == ResultTypeNumber) || (_eg.Type == ResultTypeNumber && _de.Type == ResultTypeString) {
			return MakeBoolResult(true)
		} else if _eg.Type == ResultTypeEmpty && (_de.Type == ResultTypeNumber || _de.Type == ResultTypeString) {
			return MakeBoolResult(!_ba(_de))
		} else if (_eg.Type == ResultTypeNumber || _eg.Type == ResultTypeString) && _de.Type == ResultTypeEmpty {
			return MakeBoolResult(!_ba(_eg))
		}
	case BinOpTypeLEQ:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeBoolResult(_eg.ValueNumber <= _de.ValueNumber)
			}
			if _eg.Type == ResultTypeString {
				return MakeBoolResult(_eg.ValueString <= _de.ValueString)
			}
			if _eg.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if _eg.Type == ResultTypeString && _de.Type == ResultTypeNumber {
			return MakeBoolResult(false)
		} else if _eg.Type == ResultTypeNumber && _de.Type == ResultTypeString {
			return MakeBoolResult(true)
		} else if _eg.Type == ResultTypeEmpty && (_de.Type == ResultTypeNumber || _de.Type == ResultTypeString) {
			return MakeBoolResult(_ba(_de))
		} else if (_eg.Type == ResultTypeNumber || _eg.Type == ResultTypeString) && _de.Type == ResultTypeEmpty {
			return MakeBoolResult(_ba(_eg))
		}
	case BinOpTypeGEQ:
		if _eg.Type == _de.Type {
			if _eg.Type == ResultTypeNumber {
				return MakeBoolResult(_eg.ValueNumber >= _de.ValueNumber)
			}
			if _eg.Type == ResultTypeString {
				return MakeBoolResult(_eg.ValueString >= _de.ValueString)
			}
			if _eg.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if _eg.Type == ResultTypeString && _de.Type == ResultTypeNumber {
			return MakeBoolResult(true)
		} else if _eg.Type == ResultTypeNumber && _de.Type == ResultTypeString {
			return MakeBoolResult(false)
		} else if _eg.Type == ResultTypeEmpty && (_de.Type == ResultTypeNumber || _de.Type == ResultTypeString) {
			return MakeBoolResult(_ba(_de))
		} else if (_eg.Type == ResultTypeNumber || _eg.Type == ResultTypeString) && _de.Type == ResultTypeEmpty {
			return MakeBoolResult(_ba(_eg))
		}
	case BinOpTypeConcat:
		return MakeStringResult(_eg.Value() + _de.Value())
	}
	return MakeErrorResult("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006f\u0070")
}

func _cgce(_egd, _cddg _ce.Time) bool {
	_cedf := _egd.Unix()
	_cbbd := _cddg.Unix()
	_bfd := _egd.Year()
	_cede := _gcad(_bfd, _ce.March, 1)
	if _dfa(_bfd) && _cedf < _cede && _cbbd >= _cede {
		return true
	}
	var _gfce = _cddg.Year()
	var _faa = _gcad(_gfce, _ce.March, 1)
	return (_dfa(_gfce) && _cbbd >= _faa && _cedf < _faa)
}

// Row implements the Excel ROW function.
func Row(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0052O\u0057\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_ffde := args[0].Ref
	if _ffde.Type != ReferenceTypeCell {
		return MakeErrorResult("\u0052\u004f\u0057\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 a\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065n\u0063\u0065")
	}
	_gfcbc, _eabf := _cb.ParseCellReference(_ffde.Value)
	if _eabf != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _ffde.Value)
	}
	return MakeNumberResult(float64(_gfcbc.RowIdx))
}

const _ebg = "\u0028\u0020\u0028" + _gca + "\u007c" + _efa + "\u007c" + _gec + "\u007c" + _cfe + "\u0029\u0029\u003f\u0024"

func _dfcg(_dgbf, _feac, _dfea, _gdfb, _adfa, _ggag float64, _cceb int) (float64, Result) {
	_eeec := int(_ggag)
	_agebd := _fcge(_dgbf, _feac, _eeec, _cceb)
	_cgfe := _agg(_dgbf, _feac, _eeec, _cceb) / _agebd
	_geafc, _ggbc := _ggca(_dgbf, _feac, _eeec, _cceb)
	if _ggbc.Type == ResultTypeError {
		return 0, _ggbc
	}
	_ggdca := _fgeb(_dgbf, _feac, _eeec, _cceb)
	_adeb := _adfa / _dc.Pow(1+_gdfb/_ggag, _geafc-1+_cgfe)
	_adeb -= 100 * _dfea / _ggag * _ggdca / _agebd
	_agf := 100 * _dfea / _ggag
	_ccbg := 1 + _gdfb/_ggag
	for _cafff := 0.0; _cafff < _geafc; _cafff++ {
		_adeb += _agf / _dc.Pow(_ccbg, _cafff+_cgfe)
	}
	return _adeb, MakeEmptyResult()
}

// Cumipmt implements the Excel CUMIPMT function.
func Cumipmt(args []Result) Result {
	_bcbd, _cbdbe := _acef(args, "\u0043U\u004d\u0049\u0050\u004d\u0054")
	if _cbdbe.Type == ResultTypeError {
		return _cbdbe
	}
	_addc := _bcbd._agec
	_ddde := _bcbd._ggec
	_cbce := _bcbd._cab
	_gaaca := _bcbd._efdb
	_ceg := _bcbd._gdga
	_cdgc := _bcbd._bacb
	_fcgg := _faf(_addc, _ddde, _cbce, 0, _cdgc)
	_cfg := 0.0
	if _gaaca == 1 {
		if _cdgc == 0 {
			_cfg = -_cbce
			_gaaca++
		}
	}
	for _gegg := _gaaca; _gegg <= _ceg; _gegg++ {
		if _cdgc == 1 {
			_cfg += _cfgg(_addc, _gegg-2, _fcgg, _cbce, 1) - _fcgg
		} else {
			_cfg += _cfgg(_addc, _gegg-1, _fcgg, _cbce, 0)
		}
	}
	_cfg *= _addc
	return MakeNumberResult(_cfg)
}

// Log implements the Excel LOG function which returns the log of a number. By
// default the result is base 10, however the second argument to the function
// can specify a different base.
func Log(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 o\u006e\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("L\u004f\u0047\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u006d\u0061\u0078i\u006d\u0075\u006d\u0020\u006f\u0066\u0020\u0074\u0077\u006f a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_dccae := args[0].AsNumber()
	if _dccae.Type != ResultTypeNumber {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 o\u006e\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_dgce := 10.0
	if len(args) > 1 {
		_dbebb := args[1].AsNumber()
		if _dbebb.Type != ResultTypeNumber {
			return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061rg\u0075\u006d\u0065n\u0074\u0020t\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0065r\u0069\u0063")
		}
		_dgce = args[1].ValueNumber
	}
	if _dccae.ValueNumber == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072gu\u006d\u0065\u006et\u0020\u0074o\u0020\u0062\u0065\u0020\u006e\u006fn\u002d\u007ae\u0072\u006f")
	}
	if _dgce == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073e\u0063\u006f\u006e\u0064\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u002d\u007a\u0065\u0072\u006f")
	}
	return MakeNumberResult(_dc.Log(_dccae.ValueNumber) / _dc.Log(_dgce))
}

func _ffge(_gecb string) (int, int, float64, bool, bool, Result) {
	_fadf := ""
	_bdab := []string{}
	for _ffdce, _bef := range _cfbd {
		_bdab = _bef.FindStringSubmatch(_gecb)
		if len(_bdab) > 1 {
			_fadf = _ffdce
			break
		}
	}
	if _fadf == "" {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
	}
	_fdbc := _bdab[1] == ""
	_bdab = _bdab[49:]
	_bae := len(_bdab)
	_dcgf := _bdab[_bae-1]
	_gae := _dcgf == "\u0061\u006d"
	_ddg := _dcgf == "\u0070\u006d"
	var _gff, _aeea int
	var _caaa float64
	var _gfef error
	switch _fadf {
	case "\u0068\u0068":
		_gff, _gfef = _ff.Atoi(_bdab[0])
		if _gfef != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		}
		_aeea = 0
		_caaa = 0
	case "\u0068\u0068\u003am\u006d":
		_gff, _gfef = _ff.Atoi(_bdab[0])
		if _gfef != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		}
		_aeea, _gfef = _ff.Atoi(_bdab[2])
		if _gfef != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		}
		_caaa = 0
	case "\u006d\u006d\u003as\u0073":
		_gff = 0
		_aeea, _gfef = _ff.Atoi(_bdab[0])
		if _gfef != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		}
		_caaa, _gfef = _ff.ParseFloat(_bdab[2], 64)
		if _gfef != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		}
	case "\u0068\u0068\u003a\u006d\u006d\u003a\u0073\u0073":
		_gff, _gfef = _ff.Atoi(_bdab[0])
		if _gfef != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		}
		_aeea, _gfef = _ff.Atoi(_bdab[2])
		if _gfef != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		}
		_caaa, _gfef = _ff.ParseFloat(_bdab[4], 64)
		if _gfef != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		}
	}
	if _aeea >= 60 {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
	}
	if _gae || _ddg {
		if _gff > 12 || _caaa >= 60 {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
		} else if _gff == 12 {
			_gff = 0
		}
	} else if _gff >= 24 || _caaa >= 10000 {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abaf)
	}
	return _gff, _aeea, _caaa, _ddg, _fdbc, _ffe
}

const _bbf = 86400000000000

// ISERR is an implementation of the Excel ISERR() function.
func IsErr(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u0045\u0052\u0052\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError && args[0].ValueString != "\u0023\u004e\u002f\u0041")
}

// Coupdaybs implements the Excel COUPDAYBS function.
func Coupdaybs(args []Result) Result {
	_dbfe, _gbag := _dccda(args, "\u0043O\u0055\u0050\u0044\u0041\u0059\u0042S")
	if _gbag.Type == ResultTypeError {
		return _gbag
	}
	return MakeNumberResult(_fgeb(_dbfe._ggbd, _dbfe._eedd, _dbfe._ecf, _dbfe._deagf))
}

// NewPrefixHorizontalRange constructs a new full rows range with prefix.
func NewPrefixHorizontalRange(pfx Expression, v string) Expression {
	_gfdfb := _ee.Split(v, "\u003a")
	if len(_gfdfb) != 2 {
		return nil
	}
	_fbbb, _ := _ff.Atoi(_gfdfb[0])
	_aeag, _ := _ff.Atoi(_gfdfb[1])
	return PrefixHorizontalRange{pfx, _fbbb, _aeag}
}

// Pricemat implements the Excel PRICEMAT function.
func Pricemat(args []Result) Result {
	_efff := len(args)
	if _efff != 5 && _efff != 6 {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0069v\u0065\u0020\u006f\u0072\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_bdcg, _gdc, _bbga := _dfd(args[0], args[1], "\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054")
	if _bbga.Type == ResultTypeError {
		return _bbga
	}
	_ccgbg, _bbga := _faeb(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054")
	if _bbga.Type == ResultTypeError {
		return _bbga
	}
	if _ccgbg >= _bdcg {
		return MakeErrorResult("\u0050\u0052\u0049\u0043E\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0062\u0065\u0066\u006fr\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052I\u0043\u0045\u004d\u0041T\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_aecf := args[3].ValueNumber
	if _aecf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045M\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_fbaga := args[4].ValueNumber
	if _fbaga < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049C\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_ddac := 0
	if _efff == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050R\u0049\u0043E\u004d\u0041\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_ddac = int(args[5].ValueNumber)
		if !_cfee(_ddac) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0050\u0052\u0049C\u0045\u004d\u0041\u0054")
		}
	}
	_ggdf, _bbga := _fea(_bdcg, _gdc, _ddac)
	if _bbga.Type == ResultTypeError {
		return _bbga
	}
	_bbc, _bbga := _fea(_ccgbg, _gdc, _ddac)
	if _bbga.Type == ResultTypeError {
		return _bbga
	}
	_gcag, _bbga := _fea(_ccgbg, _bdcg, _ddac)
	if _bbga.Type == ResultTypeError {
		return _bbga
	}
	_dbbf := 1 + _bbc*_aecf
	_ggeb := 1 + _ggdf*_fbaga
	return MakeNumberResult((_dbbf/_ggeb - _gcag*_aecf) * 100)
}

// String returns an empty string for EmptyExpr.
func (_ccc EmptyExpr) String() string { return "" }

// Not is an implementation of the Excel NOT() function and takes a single
// argument.
func Not(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004eO\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	switch args[0].Type {
	case ResultTypeError:
		return args[0]
	case ResultTypeString, ResultTypeList:
		return MakeErrorResult("\u004e\u004f\u0054\u0020\u0065\u0078\u0070\u0065\u0063\u0074s\u0020\u0061\u0020\u006e\u0075\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	case ResultTypeNumber:
		return MakeBoolResult(!(args[0].ValueNumber != 0))
	default:
		return MakeErrorResult("u\u006e\u0068\u0061\u006e\u0064\u006ce\u0064\u0020\u004e\u004f\u0054\u0020\u0061\u0072\u0067u\u006d\u0065\u006et\u0020t\u0079\u0070\u0065")
	}
}

// PrefixHorizontalRange is a range expression that when evaluated returns a list of Results from references like Sheet1!1:4 (all cells from rows 1 to 4 of sheet 'Sheet1').
type PrefixHorizontalRange struct {
	_eegae       Expression
	_gfad, _cfaf int
}

const _cfcb = 57378

// NewEvaluator constructs a new defEval object which is the default formula evaluator.
func NewEvaluator() Evaluator { _ae := &defEval{}; _ae.evCache = _eb(); return _ae }

// Reference returns an invalid reference for String.
func (_agaaa String) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

var ReferenceInvalid = Reference{Type: ReferenceTypeInvalid}

func _bce() {
	_fcd["\u006d\u006d\u002f\u0064\u0064\u002f\u0079\u0079"] = _gf.MustCompile("\u005e" + _ded + _ebg)
	_fcd["\u006dm\u0020\u0064\u0064\u002c\u0020\u0079y"] = _gf.MustCompile("\u005e" + _eggd + _ebg)
	_fcd["\u0079\u0079\u002d\u006d\u006d\u002d\u0064\u0064"] = _gf.MustCompile("\u005e" + _fcg + _ebg)
	_fcd["y\u0079\u002d\u006d\u006d\u0053\u0074\u0072\u002d\u0064\u0064"] = _gf.MustCompile("\u005e" + _ddff + _ebg)
	_cfbd["\u0068\u0068"] = _gf.MustCompile(_dadg + _gca + "\u0024")
	_cfbd["\u0068\u0068\u003am\u006d"] = _gf.MustCompile(_dadg + _efa + "\u0024")
	_cfbd["\u006d\u006d\u003as\u0073"] = _gf.MustCompile(_dadg + _gec + "\u0024")
	_cfbd["\u0068\u0068\u003a\u006d\u006d\u003a\u0073\u0073"] = _gf.MustCompile(_dadg + _cfe + "\u0024")
	_afd = []*_gf.Regexp{_gf.MustCompile("\u005e" + _ded + "\u0024"), _gf.MustCompile("\u005e" + _eggd + "\u0024"), _gf.MustCompile("\u005e" + _fcg + "\u0024"), _gf.MustCompile("\u005e" + _ddff + "\u0024")}
	_cdd = []*_gf.Regexp{_gf.MustCompile("\u005e" + _gca + "\u0024"), _gf.MustCompile("\u005e" + _efa + "\u0024"), _gf.MustCompile("\u005e" + _gec + "\u0024"), _gf.MustCompile("\u005e" + _cfe + "\u0024")}
}

var _adbea = [...]int{-1000, -7, -3, -1, 27, 18, 22, 23, -2, -8, -4, -9, 20, -14, 10, 11, 12, 13, -5, -13, -6, -12, 17, 16, 15, 9, 4, 5, 22, 23, 24, 25, 26, 28, 29, 30, 31, 27, 32, 35, -1, 18, 27, -15, -17, -1, -1, -1, -1, 33, -5, 4, 5, 21, -16, -11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 36, 34, 21, -5, 33, 21, 34, 19, -17, -1, -5, -10, -1}

// Min is an implementation of the Excel MIN() function.
func Min(args []Result) Result { return _dgedb(args, false) }

// Update updates references in the PrefixHorizontalRange after removing a row/column.
func (_fcafc PrefixHorizontalRange) Update(q *_cc.UpdateQuery) Expression { return _fcafc }

// Update updates references in the PrefixRangeExpr after removing a row/column.
func (_ffddd PrefixRangeExpr) Update(q *_cc.UpdateQuery) Expression {
	_egeeg := _ffddd
	_dgffc := _ffddd._cgegf.String()
	if _dgffc == q.SheetToUpdate {
		_daeef := *q
		_daeef.UpdateCurrentSheet = true
		_egeeg._gaga = _ffddd._gaga.Update(&_daeef)
		_egeeg._dbaf = _ffddd._dbaf.Update(&_daeef)
	}
	return _egeeg
}

type yyParser interface {
	Parse(yyLexer) int
	Lookahead() int
}

// Update returns the same object as updating sheet references does not affect Error.
func (_bga Error) Update(q *_cc.UpdateQuery) Expression { return _bga }

// Yield implements the Excel YIELD function.
func Yield(args []Result) Result {
	_cffg := len(args)
	if _cffg != 6 && _cffg != 7 {
		return MakeErrorResult("\u0059\u0049E\u004c\u0044\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020o\u0072\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_egbb, _abgc, _feacf := _dfd(args[0], args[1], "\u0059\u0049\u0045L\u0044")
	if _feacf.Type == ResultTypeError {
		return _feacf
	}
	_aeeag := args[2]
	if _aeeag.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045LD\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072a\u0074e\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_eebef := _aeeag.ValueNumber
	if _eebef < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	_ecgd := args[3]
	if _ecgd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020p\u0072 \u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_cead := _ecgd.ValueNumber
	if _cead <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "p\u0072\u0020\u0073\u0068ou\u006cd\u0020\u0062\u0065\u0020\u0070o\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	_dcaf := args[4]
	if _dcaf.Type != ResultTypeNumber {
		return MakeErrorResult("Y\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065m\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0066\u0020\u0074yp\u0065\u0020\u006eu\u006db\u0065\u0072")
	}
	_gdce := _dcaf.ValueNumber
	if _gdce < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_edgf := args[5]
	if _edgf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0066\u0072\u0065\u0071\u0075e\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_bgee := float64(int(_edgf.ValueNumber))
	if !_bccga(_bgee) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_fcab := 0
	if _cffg == 7 && args[6].Type != ResultTypeEmpty {
		_abfg := args[6]
		if _abfg.Type != ResultTypeNumber {
			return MakeErrorResult("Y\u0049\u0045\u004c\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0062\u0061\u0073\u0069\u0073\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
		}
		_fcab = int(_abfg.ValueNumber)
		if !_cfee(_fcab) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063o\u0072\u0072\u0065\u0063t\u0020\u0062\u0061\u0073\u0069\u0073\u0020v\u0061\u006c\u0075\u0065\u0020\u0066\u006f\u0072\u0020\u0059\u0049\u0045\u004c\u0044")
		}
	}
	_dffcd := 0.0
	_ccba := 0.0
	_cgcb := 1.0
	_gcfdd, _feacf := _dfcg(_egbb, _abgc, _eebef, _ccba, _gdce, _bgee, _fcab)
	if _feacf.Type == ResultTypeError {
		return _feacf
	}
	_bdda, _feacf := _dfcg(_egbb, _abgc, _eebef, _cgcb, _gdce, _bgee, _fcab)
	if _feacf.Type == ResultTypeError {
		return _feacf
	}
	_cbcf := (_cgcb - _ccba) * 0.5
	for _efaa := 0; _efaa < 100 && _dffcd != _cead; _efaa++ {
		_dffcd, _feacf = _dfcg(_egbb, _abgc, _eebef, _cbcf, _gdce, _bgee, _fcab)
		if _feacf.Type == ResultTypeError {
			return _feacf
		}
		if _cead == _gcfdd {
			return MakeNumberResult(_ccba)
		} else if _cead == _bdda {
			return MakeNumberResult(_cgcb)
		} else if _cead == _dffcd {
			return MakeNumberResult(_cbcf)
		} else if _cead < _bdda {
			_cgcb *= 2.0
			_bdda, _feacf = _dfcg(_egbb, _abgc, _eebef, _cgcb, _gdce, _bgee, _fcab)
			if _feacf.Type == ResultTypeError {
				return _feacf
			}
			_cbcf = (_cgcb - _ccba) * 0.5
		} else {
			if _cead < _dffcd {
				_ccba = _cbcf
				_gcfdd = _dffcd
			} else {
				_cgcb = _cbcf
				_bdda = _dffcd
			}
			_cbcf = _cgcb - (_cgcb-_ccba)*((_cead-_bdda)/(_gcfdd-_bdda))
		}
	}
	return MakeNumberResult(_cbcf)
}

func _fcfa(_bgg, _gedc float64) float64 {
	_bgg = _dc.Trunc(_bgg)
	_gedc = _dc.Trunc(_gedc)
	if _bgg == 0 {
		return _gedc
	}
	if _gedc == 0 {
		return _bgg
	}
	for _bgg != _gedc {
		if _bgg > _gedc {
			_bgg = _bgg - _gedc
		} else {
			_gedc = _gedc - _bgg
		}
	}
	return _bgg
}

const _gefcf = 57354

const _dfga = -1000

// Reference returns a string reference value to a horizontal range.
func (_cebcb HorizontalRange) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeHorizontalRange, Value: _cebcb.horizontalRangeReference()}
}

var _fcd = map[string]*_gf.Regexp{}

const _deaca = 57346

// Quotient is an implementation of the Excel QUOTIENT function that returns the
// integer portion of division.
func Quotient(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0051\u0055\u004f\u0054\u0049E\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_bfb := args[0].AsNumber()
	_ccefg := args[1].AsNumber()
	if _bfb.Type != ResultTypeNumber || _ccefg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0051\u0055\u004f\u0054\u0049E\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _ccefg.ValueNumber == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0051U\u004f\u0054\u0049\u0045N\u0054\u0028\u0029\u0020\u0064i\u0076i\u0064e\u0020\u0062\u0079\u0020\u007a\u0065\u0072o")
	}
	return MakeNumberResult(_dc.Trunc(_bfb.ValueNumber / _ccefg.ValueNumber))
}

func _gfag(_fbbga []Result) []float64 {
	_gfdea := make([]float64, 0)
	for _, _gecd := range _fbbga {
		if _gecd.Type == ResultTypeEmpty {
			continue
		}
		_gecd = _gecd.AsNumber()
		switch _gecd.Type {
		case ResultTypeNumber:
			if !_gecd.IsBoolean {
				_gfdea = append(_gfdea, _gecd.ValueNumber)
			}
		case ResultTypeList, ResultTypeArray:
			_gfdea = append(_gfdea, _gfag(_gecd.ListValues())...)
		case ResultTypeString:
		default:
			_ge.Log("\u0075\u006e\u0068\u0061\u006ed\u006c\u0065\u0064\u0020\u0065\u0078\u0074\u0072\u0061\u0063\u0074\u004e\u0075m\u0062\u0065\u0072\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _gecd.Type)
		}
	}
	return _gfdea
}

// String returns an empty string for Error.
func (_gdd Error) String() string { return "" }

// Averagea implements the AVERAGEA function, AVERAGEA counts cells that contain
// text as a zero where AVERAGE ignores them entirely.
func Averagea(args []Result) Result {
	_adda, _fdbg := _cbag(args, true)
	if _fdbg == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0041\u0056\u0045\u0052AG\u0045\u0020\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065r\u006f")
	}
	return MakeNumberResult(_adda / _fdbg)
}

// Oddlyield implements the Excel ODDLYIELD function.
func Oddlyield(args []Result) Result {
	if len(args) != 7 && len(args) != 8 {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u006f\u0072\u0020\u0065\u0069\u0067\u0068\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_cdde, _eee, _ceeg := _dfd(args[0], args[1], "\u004fD\u0044\u004c\u0059\u0049\u0045\u004cD")
	if _ceeg.Type == ResultTypeError {
		return _ceeg
	}
	_ageg, _ceeg := _faeb(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _ceeg.Type == ResultTypeError {
		return _ceeg
	}
	if _ageg >= _cdde {
		return MakeErrorResultType(ErrorTypeNum, "\u004c\u0061\u0073\u0074\u0020i\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0064\u0061\u0074\u0065\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074e")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_fggb := args[3].ValueNumber
	if _fggb < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("O\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006ff \u0074\u0079p\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_afcb := args[4].ValueNumber
	if _afcb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0073h\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[5].Type != ResultTypeNumber {
		return MakeErrorResult("\u004fD\u0044\u004cY\u0049\u0045\u004c\u0044 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_fgfe := args[5].ValueNumber
	if _fgfe < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	if args[6].Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_agdgf := float64(int(args[6].ValueNumber))
	if !_bccga(_agdgf) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_egdg := 0
	if len(args) == 8 && args[7].Type != ResultTypeEmpty {
		if args[7].Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0062a\u0073\u0069\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
		}
		_egdg = int(args[7].ValueNumber)
		if !_cfee(_egdg) {
			return MakeErrorResultType(ErrorTypeNum, "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0062\u0061\u0073\u0069s\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044")
		}
	}
	_ceff, _ceeg := _fea(_ageg, _eee, _egdg)
	if _ceeg.Type == ResultTypeError {
		return _ceeg
	}
	_ceff *= _agdgf
	_ffgc, _ceeg := _fea(_cdde, _eee, _egdg)
	if _ceeg.Type == ResultTypeError {
		return _ceeg
	}
	_ffgc *= _agdgf
	_bdba, _ceeg := _fea(_ageg, _cdde, _egdg)
	if _ceeg.Type == ResultTypeError {
		return _ceeg
	}
	_bdba *= _agdgf
	_cdab := _fgfe + _ceff*100*_fggb/_agdgf
	_cdab /= _afcb + _bdba*100*_fggb/_agdgf
	_cdab--
	_cdab *= _agdgf / _ffgc
	return MakeNumberResult(_cdab)
}

func _dea(_ef, _ffg [][]Result) bool {
	if len(_ef) != len(_ffg) {
		return false
	}
	for _gg := range _ef {
		if len(_ef[_gg]) != len(_ffg[_gg]) {
			return false
		}
	}
	return true
}

var _gcfg = map[string]int{"\u006aa\u006e\u0075\u0061\u0072\u0079": 1, "\u0066\u0065\u0062\u0072\u0075\u0061\u0072\u0079": 2, "\u006d\u0061\u0072c\u0068": 3, "\u0061\u0070\u0072i\u006c": 4, "\u006d\u0061\u0079": 5, "\u006a\u0075\u006e\u0065": 6, "\u006a\u0075\u006c\u0079": 7, "\u0061\u0075\u0067\u0075\u0073\u0074": 8, "\u0073e\u0070\u0074\u0065\u006d\u0070\u0065r": 9, "\u006fc\u0074\u006f\u0062\u0065\u0072": 10, "\u006e\u006f\u0076\u0065\u006d\u0062\u0065\u0072": 11, "\u0064\u0065\u0063\u0065\u006d\u0062\u0065\u0072": 12, "\u006a\u0061\u006e": 1, "\u0066\u0065\u0062": 2, "\u006d\u0061\u0072": 3, "\u0061\u0070\u0072": 4, "\u006a\u0075\u006e": 6, "\u006a\u0075\u006c": 7, "\u0061\u0075\u0067": 8, "\u0073\u0065\u0070": 9, "\u006f\u0063\u0074": 10, "\u006e\u006f\u0076": 11, "\u0064\u0065\u0063": 12}

// Irr implements the Excel IRR function.
func Irr(args []Result) Result {
	_aefe := len(args)
	if _aefe > 2 {
		return MakeErrorResult("\u0049\u0052\u0052\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u006f\u0072\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeList && args[0].Type != ResultTypeArray {
		return MakeErrorResult("\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020v\u0061\u006c\u0075\u0065\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0061\u0072\u0072\u0061\u0079 \u0074\u0079\u0070\u0065")
	}
	_fbd := _cdafd(args[0])
	_edcad := []float64{}
	for _, _accg := range _fbd {
		for _, _eceba := range _accg {
			if _eceba.Type == ResultTypeNumber && !_eceba.IsBoolean {
				_edcad = append(_edcad, _eceba.ValueNumber)
			}
		}
	}
	_cebg := len(_edcad)
	if len(_edcad) < 2 {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	_edde := 0.1
	if _aefe == 2 && args[1].Type != ResultTypeEmpty {
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("I\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_edde = args[1].ValueNumber
		if _edde <= -1 {
			return MakeErrorResult("\u0049\u0052R\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068a\u006e\u0020\u002d\u0031")
		}
	}
	_egdeg := []float64{}
	for _dgdc := 0; _dgdc < _cebg; _dgdc++ {
		if _dgdc == 0 {
			_egdeg = append(_egdeg, 0)
		} else {
			_egdeg = append(_egdeg, _egdeg[_dgdc-1]+365)
		}
	}
	return _dacd(_edcad, _egdeg, _edde)
}

// Update updates references in the BinaryExpr after removing a row/column.
func (_cag BinaryExpr) Update(q *_cc.UpdateQuery) Expression {
	_adf := _cag
	_adf._age = _cag._age.Update(q)
	_adf._bd = _cag._bd.Update(q)
	return _adf
}

func _dfd(_dccd, _geb Result, _geef string) (float64, float64, Result) {
	_bdg, _bfae := _faeb(_dccd, "\u0073e\u0074t\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065", _geef)
	if _bfae.Type == ResultTypeError {
		return 0, 0, _bfae
	}
	_ecafd, _bfae := _faeb(_geb, "\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065", _geef)
	if _bfae.Type == ResultTypeError {
		return 0, 0, _bfae
	}
	if _bdg >= _ecafd {
		return 0, 0, MakeErrorResultType(ErrorTypeNum, _geef+"\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u006cat\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	return _bdg, _ecafd, _ffe
}

// Rri implements the Excel RRI function.
func Rri(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0052\u0052\u0049\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0052I\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_feca := args[0].ValueNumber
	if _feca <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052R\u0049\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0052\u0049\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065\u006e\u0074 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_edcd := args[1].ValueNumber
	if _edcd <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0052\u0049\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006et\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("R\u0052\u0049\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0075\u0074\u0075\u0072e \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bdbe := args[2].ValueNumber
	if _bdbe < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052R\u0049\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020f\u0075\u0074\u0075\u0072\u0065\u0020\u0076\u0061\u006cue\u0020\u0074\u006f \u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065g\u0061\u0074i\u0076\u0065")
	}
	return MakeNumberResult(_dc.Pow(_bdbe/_edcd, 1/_feca) - 1)
}

const (
	ResultTypeUnknown ResultType = iota
	ResultTypeNumber
	ResultTypeString
	ResultTypeList
	ResultTypeArray
	ResultTypeError
	ResultTypeEmpty
)

var _bedfa = map[string]FunctionComplex{}

// Reference returns a string reference value to a sheet.
func (_cfgbf SheetPrefixExpr) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeSheet, Value: _cfgbf._edaee}
}

func _cacg(_ggff Result) *criteriaParsed {
	_agddg := _ggff.Type == ResultTypeNumber
	_edfb := _ggff.ValueNumber
	_bdgg := _ee.ToLower(_ggff.ValueString)
	_dfed := _abgaf(_bdgg)
	return &criteriaParsed{_agddg, _edfb, _bdgg, _dfed}
}

const _bcgd = 57360

type amorArgs struct {
	_gdbg  float64
	_ccggc float64
	_aeeb  float64
	_geca  float64
	_bdc   int
	_fffc  float64
	_ccdb  int
}

// Mid is an implementation of the Excel MID function that returns a copy
// of the string with each word capitalized.
func Mid(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u004d\u0049\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	_addb := args[0]
	if _addb.Type == ResultTypeError {
		return _addb
	}
	if _addb.Type != ResultTypeString && _addb.Type != ResultTypeNumber && _addb.Type != ResultTypeEmpty {
		return MakeErrorResult("\u004d\u0049\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0065x\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_cfbc := args[0].Value()
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049D\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u005fn\u0075\u006d\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_eggcd := int(args[1].ValueNumber)
	if _eggcd < 1 {
		return MakeErrorResult("M\u0049\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u005fn\u0075\u006d\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006dor\u0065\u0020\u0074h\u0061n\u0020\u0030")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049D\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u005f\u0063\u0068a\u0072\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_faae := int(args[2].ValueNumber)
	if _faae < 0 {
		return MakeErrorResult("\u004d\u0049\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u005f\u0063\u0068a\u0072\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_ecddc := len(_cfbc)
	if _eggcd > _ecddc {
		return MakeStringResult("")
	}
	_eggcd--
	_bdcd := _eggcd + _faae
	if _bdcd > _ecddc+1 {
		return MakeStringResult(_cfbc[_eggcd:])
	} else {
		return MakeStringResult(_cfbc[_eggcd:_bdcd])
	}
}

// Mirr implements the Excel MIRR function.
func Mirr(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u004d\u0049R\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeList && args[0].Type != ResultTypeArray {
		return MakeErrorResult("M\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0076\u0061\u006c\u0075\u0065s\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020ar\u0072\u0061\u0079 \u0074y\u0070\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049\u0052\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0069\u006e\u0061\u006e\u0063e\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_dead := args[1].ValueNumber + 1
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049\u0052\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0069\u006e\u0076\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_gbeg := args[2].ValueNumber + 1
	if _gbeg == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_aegg := _cdafd(args[0])
	_ffeg := float64(len(_aegg))
	_ebad, _dccab := 0.0, 0.0
	_dccbg, _ccfc := 1.0, 1.0
	_gfcb, _bcbg := false, false
	for _, _ecfb := range _aegg {
		for _, _cggg := range _ecfb {
			if _cggg.Type == ResultTypeNumber && !_cggg.IsBoolean {
				_bgdad := _cggg.ValueNumber
				if _bgdad == 0 {
					continue
				} else {
					if _bgdad > 0 {
						_gfcb = true
						_dccab += _cggg.ValueNumber * _ccfc
					} else {
						_bcbg = true
						_ebad += _cggg.ValueNumber * _dccbg
					}
					_dccbg /= _dead
					_ccfc /= _gbeg
				}
			}
		}
	}
	if !_gfcb || !_bcbg {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_deg := -_dccab / _ebad
	_deg *= _dc.Pow(_gbeg, _ffeg-1)
	_deg = _dc.Pow(_deg, 1/(_ffeg-1))
	return MakeNumberResult(_deg - 1)
}

// Eval evaluates and returns a string.
func (_cgbdg String) Eval(ctx Context, ev Evaluator) Result {
	return MakeStringResult(_cgbdg._abace)
}

func _aefcg(_baacc string, _fcfecc _ce.Time) (_ce.Time, error) {
	_defe, _, _dabe := _b.ParseFloat(_baacc, 10, 128, _b.ToNearestEven)
	if _dabe != nil {
		return _ce.Time{}, _dabe
	}
	_bbcf := new(_b.Float)
	_bbcf.SetUint64(uint64(24 * _ce.Hour))
	_defe.Mul(_defe, _bbcf)
	_dgbfe, _ := _defe.Uint64()
	_fdff := _fcfecc.Add(_ce.Duration(_dgbfe))
	return _cccab(_fdff), nil
}

const (
	ReferenceTypeInvalid ReferenceType = iota
	ReferenceTypeCell
	ReferenceTypeHorizontalRange
	ReferenceTypeVerticalRange
	ReferenceTypeNamedRange
	ReferenceTypeRange
	ReferenceTypeSheet
)

// Even is an implementation of the Excel EVEN() that rounds a number to the
// nearest even integer.
func Even(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0045\u0056\u0045\u004e(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_cbgb := args[0].AsNumber()
	if _cbgb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0056\u0045N\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_agbf := _dc.Signbit(_cbgb.ValueNumber)
	_cafga, _daea := _dc.Modf(_cbgb.ValueNumber / 2)
	_cacfe := _cafga * 2
	if _daea != 0 {
		if !_agbf {
			_cacfe += 2
		} else {
			_cacfe -= 2
		}
	}
	return MakeNumberResult(_cacfe)
}

var _caffb = [...]uint8{0, 17, 33, 49, 63, 78, 93, 108}

// TextJoin is an implementation of the Excel TEXTJOIN function.
func TextJoin(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u004aO\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074h\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0054\u0045\u0058T\u004a\u004f\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0065\u006c\u0069\u006d\u0069\u0074\u0065\u0072\u0020\u0074\u006f\u0020\u0062\u0065 \u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_fadfb := args[0].ValueString
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u004a\u004f\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065c\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0072 \u0062\u006f\u006f\u006c\u0065a\u006e")
	}
	_cedab := args[1].ValueNumber != 0
	_beed := _fada(args[2:], []string{}, _cedab)
	return MakeStringResult(_ee.Join(_beed, _fadfb))
}

const _dae = "\u0028\u0028\u006a\u0061\u006e|\u006a\u0061\u006e\u0075\u0061\u0072\u0079\u0029\u007c\u0028\u0066\u0065\u0062\u007c\u0066\u0065\u0062\u0072\u0075a\u0072\u0079\u0029\u007c\u0028\u006da\u0072\u007c\u006da\u0072\u0063\u0068\u0029\u007c\u0028\u0061\u0070\u0072\u007c\u0061\u0070\u0072\u0069\u006c\u0029\u007c\u0028\u006d\u0061\u0079\u0029\u007c\u0028j\u0075\u006e\u007cj\u0075\u006e\u0065\u0029\u007c\u0028\u006a\u0075\u006c\u007c\u006a\u0075\u006c\u0079\u0029\u007c\u0028a\u0075\u0067\u007c\u0061\u0075\u0067\u0075\u0073t\u0029\u007c\u0028\u0073\u0065\u0070\u007c\u0073\u0065\u0070\u0074\u0065\u006d\u0062\u0065\u0072\u0029\u007c\u0028o\u0063\u0074\u007c\u006f\u0063\u0074\u006f\u0062\u0065\u0072\u0029\u007c\u0028\u006e\u006f\u0076\u007c\u006e\u006f\u0076\u0065\u006d\u0062e\u0072\u0029\u007c\u0028\u0064\u0065\u0063\u007c\u0064\u0065\u0063\u0065\u006d\u0062\u0065\u0072\u0029\u0029"

// ListValues converts an array to a list or returns a lists values. This is used
// for functions that can accept an array, but don't care about ordering to
// reuse the list function logic.
func (_cfcf Result) ListValues() []Result {
	if _cfcf.Type == ResultTypeArray {
		_gefdf := []Result{}
		for _, _fdcbd := range _cfcf.ValueArray {
			for _, _bcdaa := range _fdcbd {
				_gefdf = append(_gefdf, _bcdaa)
			}
		}
		return _gefdf
	}
	if _cfcf.Type == ResultTypeList {
		return _cfcf.ValueList
	}
	return nil
}

func init() {
	_bce()
	RegisterFunction("\u0044\u0041\u0054\u0045", Date)
	RegisterFunction("\u0044A\u0054\u0045\u0044\u0049\u0046", DateDif)
	RegisterFunction("\u0044A\u0054\u0045\u0056\u0041\u004c\u0055E", DateValue)
	RegisterFunction("\u0044\u0041\u0059", Day)
	RegisterFunction("\u0044\u0041\u0059\u0053", Days)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0044\u0041\u0059\u0053", Days)
	RegisterFunction("\u0045\u0044\u0041T\u0045", Edate)
	RegisterFunction("\u0045O\u004d\u004f\u004e\u0054\u0048", Eomonth)
	RegisterFunction("\u004d\u0049\u004e\u0055\u0054\u0045", Minute)
	RegisterFunction("\u004d\u004f\u004eT\u0048", Month)
	RegisterFunction("\u004e\u004f\u0057", Now)
	RegisterFunction("\u0054\u0049\u004d\u0045", Time)
	RegisterFunction("\u0054I\u004d\u0045\u0056\u0041\u004c\u0055E", TimeValue)
	RegisterFunction("\u0054\u004f\u0044A\u0059", Today)
	RegisterFunctionComplex("\u0059\u0045\u0041\u0052", Year)
	RegisterFunction("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043", YearFrac)
}

// NewBool constructs a new boolean expression.
func NewBool(v string) Expression {
	_da, _bgb := _ff.ParseBool(v)
	if _bgb != nil {
		_ge.Log("\u0065\u0072\u0072\u006f\u0072\u0020p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u006d\u0075\u006ca\u0020\u0062\u006f\u006f\u006c\u0020\u0025s\u003a\u0020\u0025\u0073", v, _bgb)
	}
	return Bool{_da}
}

// ISNONTEXT is an implementation of the Excel ISNONTEXT() function.
func IsNonText(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053N\u004f\u004e\u0054\u0045X\u0054\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073 \u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type != ResultTypeString)
}

func _faeb(_cdg Result, _gcb, _abba string) (float64, Result) {
	var _baeg float64
	switch _cdg.Type {
	case ResultTypeNumber:
		_baeg = float64(int(_cdg.ValueNumber))
	case ResultTypeString:
		_aed := DateValue([]Result{_cdg})
		if _aed.Type == ResultTypeError {
			return 0, MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020" + _gcb + "\u0020\u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u0020" + _abba)
		}
		_baeg = _aed.ValueNumber
	default:
		return 0, MakeErrorResult("\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020" + _abba)
	}
	if _baeg < 0 {
		return 0, MakeErrorResultType(ErrorTypeNum, _gcb+"\u0020\u0073\u0068ou\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	return _baeg, _ffe
}

// RegisterFunction registers a standard function.
func RegisterFunction(name string, fn Function) {
	_fafbc.Lock()
	defer _fafbc.Unlock()
	if _, _egfc := _baad[name]; _egfc {
		_ge.Log("\u0064\u0075p\u006c\u0069\u0063\u0061t\u0065\u0020r\u0065\u0067\u0069\u0073\u0074\u0072\u0061\u0074i\u006f\u006e\u0020\u006f\u0066\u0020\u0066\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0025\u0073", name)
	}
	_baad[name] = fn
}

// ISERROR is an implementation of the Excel ISERROR() function.
func IsError(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("I\u0053\u0045\u0052\u0052\u004f\u0052(\u0029\u0020\u0061\u0063\u0063\u0065p\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError)
}

// Context is a formula execution context.  Formula evaluation uses the context
// to retreive information from sheets.
type Context interface {

	// Cell returns the result of evaluating a cell.
	Cell(_afb string, _eaed Evaluator) Result

	// Sheet returns an evaluation context for a given sheet name.  This is used
	// when evaluating cells that pull data from other sheets (e.g. ='Sheet 2'!A1).
	Sheet(_bdd string) Context

	// GetEpoch returns the time epoch of the context's Workbook.
	GetEpoch() _ce.Time

	// GetFilename returns the full filename of the context's Workbook.
	GetFilename() string

	// GetWidth returns a worksheet's column width.
	GetWidth(_ccd int) float64

	// GetFormat returns a cell's format.
	GetFormat(_efg string) string

	// GetLabelPrefix returns cell's label prefix dependent on cell horizontal alignment.
	GetLabelPrefix(_dac string) string

	// GetFormat returns if cell is protected.
	GetLocked(_gdfe string) bool

	// HasFormula returns if cell contains formula.
	HasFormula(_gce string) bool

	// IsBool returns if cell contains boolean value.
	IsBool(_ddf string) bool

	// IsDBCS returns if workbook default language is among DBCS.
	IsDBCS() bool

	// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
	LastColumn(_ead, _bfg int) string

	// LastRow returns the name of last row which contains data in range of context sheet's given columns.
	LastRow(_gcf string) int

	// SetLocked returns sets cell's protected attribute.
	SetLocked(_bdec string, _eeg bool)

	// NamedRange returns a named range.
	NamedRange(_dag string) Reference

	// SetOffset is used so that the Context can evaluate cell references
	// differently when they are not absolute (e.g. not like '$A$5').  See the
	// shared formula support in Cell for usage.
	SetOffset(_cce, _aacc uint32)
}

var _ccee = [...]int{0, -2, 1, 2, 0, 0, 0, 0, 11, 12, 13, 14, 0, 16, 5, 6, 7, 8, 22, 0, 24, 46, 0, 26, 25, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 18, 20, 9, 10, 0, 0, 23, 32, 33, 47, 0, 49, 51, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 0, 17, 0, 0, 15, 27, 0, 48, 53, 4, 19, 21, 28, 50, 52}

var _cfgeg = []ri{{1000, "\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

// T is an implementation of the Excel T function that returns whether the
// argument is text.
func T(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("T\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074r\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_bgca := args[0]
	if _bgca.Type == ResultTypeError || _bgca.Type == ResultTypeString {
		return _bgca
	}
	return _ffe
}

// Today is an implementation of the Excel TODAY() function.
func Today(args []Result) Result {
	if len(args) > 0 {
		return MakeErrorResult("\u0054\u004f\u0044A\u0059\u0020\u0064\u006fe\u0073\u006e\u0027\u0074\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_daeb := _ce.Now()
	_, _bddg := _daeb.Zone()
	_ddcc := _aeac(_ccf, _daeb.Unix()+int64(_bddg)) + 1
	return MakeNumberResult(_ddcc)
}

const _daabe = 187

func _ecaf(_eeb BinOpType, _ddb []Result, _gfb Result) Result {
	_dg := []Result{}
	switch _gfb.Type {
	case ResultTypeNumber:
		_fa := _gfb.ValueNumber
		for _adc := range _ddb {
			_fc := _ddb[_adc].AsNumber()
			if _fc.Type != ResultTypeNumber {
				return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
			}
			switch _eeb {
			case BinOpTypePlus:
				_dg = append(_dg, MakeNumberResult(_fc.ValueNumber+_fa))
			case BinOpTypeMinus:
				_dg = append(_dg, MakeNumberResult(_fc.ValueNumber-_fa))
			case BinOpTypeMult:
				_dg = append(_dg, MakeNumberResult(_fc.ValueNumber*_fa))
			case BinOpTypeDiv:
				if _fa == 0 {
					return MakeErrorResultType(ErrorTypeDivideByZero, "")
				}
				_dg = append(_dg, MakeNumberResult(_fc.ValueNumber/_fa))
			case BinOpTypeExp:
				_dg = append(_dg, MakeNumberResult(_dc.Pow(_fc.ValueNumber, _fa)))
			case BinOpTypeLT:
				_dg = append(_dg, MakeBoolResult(_fc.ValueNumber < _fa))
			case BinOpTypeGT:
				_dg = append(_dg, MakeBoolResult(_fc.ValueNumber > _fa))
			case BinOpTypeEQ:
				_dg = append(_dg, MakeBoolResult(_fc.ValueNumber == _fa))
			case BinOpTypeLEQ:
				_dg = append(_dg, MakeBoolResult(_fc.ValueNumber <= _fa))
			case BinOpTypeGEQ:
				_dg = append(_dg, MakeBoolResult(_fc.ValueNumber >= _fa))
			case BinOpTypeNE:
				_dg = append(_dg, MakeBoolResult(_fc.ValueNumber != _fa))
			default:
				return MakeErrorResult(_c.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _eeb))
			}
		}
	case ResultTypeString:
		_bg := _gfb.ValueString
		for _df := range _ddb {
			_agd := _ddb[_df].AsString()
			if _agd.Type != ResultTypeString {
				return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
			}
			switch _eeb {
			case BinOpTypeLT:
				_dg = append(_dg, MakeBoolResult(_agd.ValueString < _bg))
			case BinOpTypeGT:
				_dg = append(_dg, MakeBoolResult(_agd.ValueString > _bg))
			case BinOpTypeEQ:
				_dg = append(_dg, MakeBoolResult(_agd.ValueString == _bg))
			case BinOpTypeLEQ:
				_dg = append(_dg, MakeBoolResult(_agd.ValueString <= _bg))
			case BinOpTypeGEQ:
				_dg = append(_dg, MakeBoolResult(_agd.ValueString >= _bg))
			case BinOpTypeNE:
				_dg = append(_dg, MakeBoolResult(_agd.ValueString != _bg))
			default:
				return MakeErrorResult(_c.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _eeb))
			}
		}
	default:
		return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069c\u0020\u0061\u006e\u0064\u0020\u006e\u006f\u006e-\u0073t\u0072\u0069\u006e\u0067\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069\u006e\u0061r\u0079\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u0069\u006f\u006e")
	}
	return MakeListResult(_dg)
}

const _abaf = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0054\u0049\u004d\u0045\u0056\u0041\u004c\u0055\u0045"

func _cfag(_gab []Result, _dage string) (*durationArgs, Result) {
	_egeb := len(_gab)
	if _egeb != 5 && _egeb != 6 {
		return nil, MakeErrorResult(_dage + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0066\u0069\u0076\u0065\u0020\u006fr\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_acgc, _gbff, _eacc := _dfd(_gab[0], _gab[1], _dage)
	if _eacc.Type == ResultTypeError {
		return nil, _eacc
	}
	_ade := _gab[2]
	if _ade.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_dage + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0063\u006fupo\u006e r\u0061\u0074\u0065\u0020\u006f\u0066\u0020ty\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_fdgg := _ade.ValueNumber
	if _fdgg < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0043\u006f\u0075po\u006e\u0020\u0072\u0061\u0074\u0065\u0020\u0073\u0068o\u0075l\u0064 \u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_ecbc := _gab[3]
	if _ecbc.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_dage + " \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0079\u0069\u0065\u006cd\u0020\u0072\u0061\u0074\u0065\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_ebcg := _ecbc.ValueNumber
	if _ebcg < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006c\u0064\u0020r\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020\u0062\u0065\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	_cdac := _gab[4]
	if _cdac.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_dage + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u0065\u0071u\u0065n\u0063y\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_cge := float64(int(_cdac.ValueNumber))
	if !_bccga(_cge) {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_afcc := 0
	if _egeb == 6 && _gab[5].Type != ResultTypeEmpty {
		_bada := _gab[5]
		if _bada.Type != ResultTypeNumber {
			return nil, MakeErrorResult(_dage + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u006f\u0066 \u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_afcc = int(_bada.ValueNumber)
		if !_cfee(_afcc) {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062a\u0073\u0069\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020"+_dage)
		}
	}
	return &durationArgs{_acgc, _gbff, _fdgg, _ebcg, _cge, _afcc}, _ffe
}

// ISBLANK is an implementation of the Excel ISBLANK() function.
func IsBlank(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("I\u0053\u0042\u004c\u0041\u004e\u004b(\u0029\u0020\u0061\u0063\u0063\u0065p\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeEmpty)
}

// Combina is an implementation of the Excel COMBINA function whic returns the
// number of combinations with repetitions.
func Combina(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004dB\u0049\u004e\u0041\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_adfc := args[0].AsNumber()
	_ccae := args[1].AsNumber()
	if _adfc.Type != ResultTypeNumber || _ccae.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043\u004fMB\u0049\u004e\u0041(\u0029\u0020\u0072\u0065qui\u0072es\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_gbcfe := _dc.Trunc(_adfc.ValueNumber)
	_fafg := _dc.Trunc(_ccae.ValueNumber)
	if _gbcfe < _fafg {
		return MakeErrorResult("\u0043O\u004d\u0042\u0049\u004e\u0041\u0028\u0029\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u006e\u0020\u003e\u0020\u006b")
	}
	if _gbcfe == 0 {
		return MakeNumberResult(0)
	}
	args[0] = MakeNumberResult(_gbcfe + _fafg - 1)
	args[1] = MakeNumberResult(_gbcfe - 1)
	return Combin(args)
}

func (_fcffb ResultType) String() string {
	if _fcffb >= ResultType(len(_caffb)-1) {
		return _c.Sprintf("\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070e\u0028\u0025\u0064\u0029", _fcffb)
	}
	return _edbb[_caffb[_fcffb]:_caffb[_fcffb+1]]
}

// BinOpType is the binary operation operator type
//go:generate stringer -type=BinOpType
type BinOpType byte

type defEval struct {
	evCache
	_egb bool
}

// Sum is an implementation of the Excel SUM() function.
func Sum(args []Result) Result {
	_cdga := MakeNumberResult(0)
	for _, _gdbb := range args {
		_gdbb = _gdbb.AsNumber()
		switch _gdbb.Type {
		case ResultTypeNumber:
			_cdga.ValueNumber += _gdbb.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_gaagd := Sum(_gdbb.ListValues())
			if _gaagd.Type != ResultTypeNumber {
				return _gaagd
			}
			_cdga.ValueNumber += _gaagd.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _gdbb
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0053\u0055\u004d\u0028\u0029 \u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _gdbb.Type))
		}
	}
	return _cdga
}

// Xirr implements the Excel XIRR function.
func Xirr(args []Result) Result {
	_aadg := len(args)
	if _aadg != 2 && _aadg != 3 {
		return MakeErrorResult("\u0058\u0049RR\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0077o \u006f\u0072\u0020\u0074\u0068\u0072\u0065e \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_faaf, _ggdb := _gdfbf(args[0], args[1], "\u0058\u0049\u0052\u0052")
	if _ggdb.Type == ResultTypeError {
		return _ggdb
	}
	_fgbg := _faaf._debc
	_gbfa := _faaf._gefg
	_gbage := 0.1
	if _aadg == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("\u0058\u0049\u0052\u0052\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_gbage = args[2].ValueNumber
		if _gbage <= -1 {
			return MakeErrorResult("\u0058\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020\u0074\u006f\u0020\u0062e\u0020\u006d\u006f\u0072\u0065 \u0074\u0068a\u006e\u0020\u002d\u0031")
		}
	}
	return _dacd(_fgbg, _gbfa, _gbage)
}

const _gec = "\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u005c\u002e\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u0028\u0020(\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"

// Days is an implementation of the Excel DAYS() function.
func Days(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("D\u0041\u0059\u0053\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	var _fcgf, _abb float64
	switch args[0].Type {
	case ResultTypeNumber:
		_abb = args[0].ValueNumber
	case ResultTypeString:
		_cac := DateValue([]Result{args[0]})
		if _cac.Type == ResultTypeError {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0065\u006e\u0064\u0020\u0064\u0061\u0074e\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
		}
		_abb = _cac.ValueNumber
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
	}
	switch args[1].Type {
	case ResultTypeNumber:
		_fcgf = args[1].ValueNumber
		if _fcgf < 62 && _abb >= 62 {
			_fcgf--
		}
	case ResultTypeString:
		_ebb := DateValue([]Result{args[1]})
		if _ebb.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u0020DA\u0059\u0053")
		}
		_fcgf = _ebb.ValueNumber
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
	}
	_cbdf := float64(int(_abb - _fcgf))
	return MakeNumberResult(_cbdf)
}

// Find is an implementation of the Excel FIND().
func Find(args []Result) Result {
	_aegb, _ffcc := _acfc("\u0046\u0049\u004e\u0044", args)
	if _ffcc.Type != ResultTypeEmpty {
		return _ffcc
	}
	_agcbgb := _aegb._dede
	if _agcbgb == "" {
		return MakeNumberResult(1.0)
	}
	_dfcc := _aegb._affa
	_gfbe := _aegb._caacac
	_dbba := 1
	for _bcbgb := range _dfcc {
		if _dbba < _gfbe {
			_dbba++
			continue
		}
		_aagf := _ee.Index(_dfcc[_bcbgb:], _agcbgb)
		if _aagf == 0 {
			return MakeNumberResult(float64(_dbba))
		}
		_dbba++
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// Day is an implementation of the Excel DAY() function.
func Day(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0044A\u0059\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_caf := args[0]
	switch _caf.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(0)
	case ResultTypeNumber:
		_ceb := _fae(_caf.ValueNumber)
		return MakeNumberResult(float64(_ceb.Day()))
	case ResultTypeString:
		_efb := _ee.ToLower(_caf.ValueString)
		if !_aabb(_efb) {
			_, _, _, _, _dge, _afg := _ffge(_efb)
			if _afg.Type == ResultTypeError {
				_afg.ErrorMessage = "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073\u0020\u0066o\u0072 \u0044\u0041\u0059"
				return _afg
			}
			if _dge {
				return MakeNumberResult(0)
			}
		}
		_, _, _gbd, _, _bdea := _dfb(_efb)
		if _bdea.Type == ResultTypeError {
			return _bdea
		}
		return MakeNumberResult(float64(_gbd))
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072 \u0044\u0041\u0059")
	}
}

// Price implements the Excel PRICE function.
func Price(args []Result) Result {
	_fecd := len(args)
	if _fecd != 6 && _fecd != 7 {
		return MakeErrorResult("\u0050\u0052I\u0043\u0045\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020o\u0072\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_adfg, _cbca, _ged := _dfd(args[0], args[1], "\u0050\u0052\u0049C\u0045")
	if _ged.Type == ResultTypeError {
		return _ged
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049CE\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072a\u0074e\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_bcce := args[2].ValueNumber
	if _bcce < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u006eo\u0074\u0020\u0062\u0065\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0052\u0049\u0043\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0079\u0069\u0065\u006c\u0064\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_efba := args[3].ValueNumber
	if _efba < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0079\u0069\u0065\u006c\u0064 \u0074\u006f\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0065\u0064em\u0070\u0074\u0069\u006fn\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_adba := args[4].ValueNumber
	if _adba <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073 \u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e \u0074\u006f\u0020\u0062\u0065 p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ddddb := args[5]
	if _ddddb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0066\u0072\u0065\u0071\u0075e\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_aefc := _ddddb.ValueNumber
	if !_bccga(_aefc) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_defb := 0
	if _fecd == 7 && args[6].Type != ResultTypeEmpty {
		if args[6].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0052\u0049C\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_defb = int(args[6].ValueNumber)
		if !_cfee(_defb) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069s\u0020a\u0072g\u0075m\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0050\u0052\u0049\u0043\u0045")
		}
	}
	_afgc, _ged := _dfcg(_adfg, _cbca, _bcce, _efba, _adba, _aefc, _defb)
	if _ged.Type == ResultTypeError {
		return _ged
	}
	return MakeNumberResult(_afgc)
}

func _baaba(_bebg, _cdgcd []string) []string {
	for _, _gggf := range _cdgcd {
		_bebg = append(_bebg, _gggf)
	}
	return _bebg
}

// String returns a string representation of CellRef.
func (_eaf CellRef) String() string { return _eaf._bda }

func (_aaag *Lexer) emit(_ccaf tokenType, _cgffe []byte) {
	if _bfdcc {
		_c.Println("\u0065\u006d\u0069\u0074", _ccaf, _egedb(string(_cgffe)))
	}
	_aaag._daeg <- &node{_ccaf, string(_cgffe)}
}

func _cfced(_fcda string, _agdb []Result) (*parsedReplaceObject, Result) {
	if len(_agdb) != 4 {
		return nil, MakeErrorResult(_fcda + "\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _agdb[0].Type != ResultTypeString {
		return nil, MakeErrorResult(_fcda + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_adgbcd := _agdb[0].ValueString
	if _agdb[1].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_fcda + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e \u0061\u0020\u006eu\u006db\u0065\u0072")
	}
	_cgdd := int(_agdb[1].ValueNumber) - 1
	if _agdb[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_fcda + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0069r\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cbac := int(_agdb[2].ValueNumber)
	if _agdb[3].Type != ResultTypeString {
		return nil, MakeErrorResult(_fcda + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0074\u0068\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e \u0061\u0020\u0073t\u0072i\u006e\u0067")
	}
	_gbfg := _agdb[3].ValueString
	return &parsedReplaceObject{_adgbcd, _cgdd, _cbac, _gbfg}, _ffe
}

// VLookup implements the VLOOKUP function that returns a matching value from a
// column in an array.
func VLookup(args []Result) Result {
	_fcfd := len(args)
	if _fcfd < 3 {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004bU\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _fcfd > 4 {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0074\u0020m\u006f\u0073\u0074\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_edbec := args[0]
	_cfdb := args[1]
	if _cfdb.Type != ResultTypeArray {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_fdbb := args[2].AsNumber()
	if _fdbb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050 \u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0063\u006f\u006c\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gdabe := false
	if _fcfd == 4 && args[3].Type != ResultTypeEmpty {
		_deeb := args[3].AsNumber()
		if _deeb.Type != ResultTypeNumber {
			return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		if _deeb.ValueNumber == 0 {
			_gdabe = true
		}
	}
	_abbb := int(_fdbb.ValueNumber) - 1
	_acbe := -1
	_baac := false
_gfbdc:
	for _efbe, _egfb := range _cfdb.ValueArray {
		if len(_egfb) == 0 {
			continue
		}
		_abbab := _egfb[0]
		switch _gdgf(_abbab, _edbec, false, _gdabe) {
		case _bcea:
			_acbe = _efbe
		case _aafg:
			_acbe = _efbe
			_baac = true
			break _gfbdc
		}
	}
	if _acbe == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_abbd := _cfdb.ValueArray[_acbe]
	if _abbb < 0 || _abbb >= len(_abbd) {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0063\u006f\u006c\u0075\u006d\u006e\u0020\u0069\u006e\u0064\u0065\u0078")
	}
	if _baac || !_gdabe {
		return _abbd[_abbb]
	}
	return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
}

func _cfgg(_bgdg, _dfdb, _geee, _dgfg float64, _dgbb int) float64 {
	var _afga float64
	if _bgdg == 0 {
		_afga = _dgfg + _geee*_dfdb
	} else {
		_cgeg := _dc.Pow(1+_bgdg, _dfdb)
		if _dgbb == 1 {
			_afga = _dgfg*_cgeg + _geee*(1+_bgdg)*(_cgeg-1)/_bgdg
		} else {
			_afga = _dgfg*_cgeg + _geee*(_cgeg-1)/_bgdg
		}
	}
	return -_afga
}

func _aacd(_aedf, _egc _ce.Time, _adb int) _ce.Time {
	_cfdd := _ce.Date(_aedf.Year(), _egc.Month(), _egc.Day(), 0, 0, 0, 0, _ce.UTC)
	if _cfdd.After(_aedf) {
		_cfdd = _cfdd.AddDate(-1, 0, 0)
	}
	for !_cfdd.After(_aedf) {
		_cfdd = _cfdd.AddDate(0, 12/_adb, 0)
	}
	return _cfdd
}

// Coupdays implements the Excel COUPDAYS function.
func Coupdays(args []Result) Result {
	_gdg, _efc := _dccda(args, "\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053")
	if _efc.Type == ResultTypeError {
		return _efc
	}
	return MakeNumberResult(_fcge(_gdg._ggbd, _gdg._eedd, _gdg._ecf, _gdg._deagf))
}

// String returns a string representation for Bool.
func (_dec Bool) String() string {
	if _dec._gfbd {
		return "\u0054\u0052\u0055\u0045"
	} else {
		return "\u0046\u0041\u004cS\u0045"
	}
}

// NewConstArrayExpr constructs a new constant array expression with a given data.
func NewConstArrayExpr(data [][]Expression) Expression { return &ConstArrayExpr{data} }

func _cedd(_cagc, _bebf float64) float64 {
	_cagc = _dc.Trunc(_cagc)
	_bebf = _dc.Trunc(_bebf)
	if _cagc == 0 && _bebf == 0 {
		return 0
	}
	return _cagc * _bebf / _fcfa(_cagc, _bebf)
}

var _fcaa, _ceae, _eacg, _bacdb, _gfee, _ecaee *_gf.Regexp

const _effd = 2

func _cccab(_ebdc _ce.Time) _ce.Time {
	_ebdc = _ebdc.UTC()
	return _ce.Date(_ebdc.Year(), _ebdc.Month(), _ebdc.Day(), _ebdc.Hour(), _ebdc.Minute(), _ebdc.Second(), _ebdc.Nanosecond(), _ce.Local)
}

var _dadgd []byte = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

var _cdcb *_gb.Rand

// FloorPrecise is an implementation of the FlOOR.PRECISE function.
func FloorPrecise(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0046\u004cO\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0046L\u004f\u004fR\u002e\u0050\u0052\u0045C\u0049\u0053\u0045(\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020at\u0020\u006d\u006fs\u0074\u0020t\u0077\u006f\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_bcda := args[0].AsNumber()
	if _bcda.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020F\u004c\u004f\u004f\u0052\u002e\u0050\u0052E\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_eddg := float64(1)
	if _bcda.ValueNumber < 0 {
		_eddg = -1
	}
	if len(args) > 1 {
		_cacfc := args[1].AsNumber()
		if _cacfc.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006ed\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020F\u004c\u004f\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065r")
		}
		_eddg = _dc.Abs(_cacfc.ValueNumber)
	}
	if len(args) == 1 {
		return MakeNumberResult(_dc.Floor(_bcda.ValueNumber))
	}
	_cgcbc := _bcda.ValueNumber
	_cgcbc, _fcagg := _dc.Modf(_cgcbc / _eddg)
	if _fcagg != 0 {
		if _bcda.ValueNumber < 0 {
			_cgcbc--
		}
	}
	return MakeNumberResult(_cgcbc * _eddg)
}

var _adfca = []ri{{1000, "\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

const _dadg = "\u005e\u0028\u0028" + _ded + "\u007c" + _eggd + "\u007c" + _fcg + "\u007c" + _ddff + "\u0029\u0020\u0029\u003f"

type yySymType struct {
	_gbae   int
	_dfcfe  *node
	_aagaec Expression
	_efaac  []Expression
	_aead   [][]Expression
}

// Reference returns an invalid reference for EmptyExpr.
func (_bab EmptyExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Eval evaluates and returns the result of the NamedRangeRef reference.
func (_gcgff NamedRangeRef) Eval(ctx Context, ev Evaluator) Result {
	_cgbfe := ctx.NamedRange(_gcgff._bdggc)
	_cgea := _cgbfe.Value
	if _ceaa, _dafa := ev.GetFromCache(_cgea); _dafa {
		return _ceaa
	}
	_gcgag := _ee.Split(_cgea, "\u0021")
	if len(_gcgag) != 2 {
		return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006e\u0061\u006de\u0064 \u0072\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0025\u0073", _cgea))
	}
	_begb := ctx.Sheet(_gcgag[0])
	_ebddd := _ee.Split(_gcgag[1], "\u003a")
	switch len(_ebddd) {
	case 1:
		_ecabe := ev.Eval(_begb, _ebddd[0])
		ev.SetCache(_cgea, _ecabe)
		return _ecabe
	case 2:
		_bgcc := _efbfc(_begb, ev, _ebddd[0], _ebddd[1])
		ev.SetCache(_cgea, _bgcc)
		return _bgcc
	}
	return MakeErrorResult(_c.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070e \u0025\u0073", _cgbfe.Type))
}

// Eval evaluates and returns the result of a constant array expression.
func (_cfb ConstArrayExpr) Eval(ctx Context, ev Evaluator) Result {
	_gea := [][]Result{}
	for _, _gda := range _cfb._fdb {
		_fdc := []Result{}
		for _, _gba := range _gda {
			_fdc = append(_fdc, _gba.Eval(ctx, ev))
		}
		_gea = append(_gea, _fdc)
	}
	return MakeArrayResult(_gea)
}

func _edbeb(_bgbeb []Result, _ffada countMode) float64 {
	_edaf := 0.0
	for _, _bfcc := range _bgbeb {
		switch _bfcc.Type {
		case ResultTypeNumber:
			if _ffada == _ecaa || (_ffada == _fdgfd && !_bfcc.IsBoolean) {
				_edaf++
			}
		case ResultTypeList, ResultTypeArray:
			_edaf += _edbeb(_bfcc.ListValues(), _ffada)
		case ResultTypeString:
			if _ffada == _ecaa {
				_edaf++
			}
		case ResultTypeEmpty:
			if _ffada == _afe {
				_edaf++
			}
		}
	}
	return _edaf
}

// Pduration implements the Excel PDURATION function.
func Pduration(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0050\u0044\u0055RA\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u0074h\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050D\u0055\u0052A\u0054\u0049\u004fN\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_edg := args[0].ValueNumber
	if _edg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020p\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u0020\u0076\u0061l\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cegab := args[1].ValueNumber
	if _cegab <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "P\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 c\u0075\u0072\u0072\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074o \u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0044\u0055\u0052\u0041\u0054I\u004f\u004e\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0070\u0065\u0063\u0069\u0066i\u0065\u0064\u0020\u0076\u0061lu\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_egdc := args[2].ValueNumber
	if _egdc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0044\u0055\u0052\u0041\u0054I\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070o\u0073i\u0074\u0069\u0076\u0065")
	}
	return MakeNumberResult((_dc.Log10(_egdc) - _dc.Log10(_cegab)) / _dc.Log10(1+_edg))
}

const _abbdf int = 30

func _gdfdg(_dcb, _abac, _cde float64) float64 { return (_dcb*3600 + _abac*60 + _cde) / 86400 }

// Trim is an implementation of the Excel TRIM function that removes leading,
// trailing and consecutive spaces.
func Trim(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0054\u0052\u0049\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dcgefg := args[0].AsString()
	if _dcgefg.Type != ResultTypeString {
		return MakeErrorResult("\u0054\u0052\u0049\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dfebb := _d.Buffer{}
	_egbgg := false
	_dfcad := false
	_fefgb := 0
	for _, _dbed := range _dcgefg.ValueString {
		_cfce := _dbed == ' '
		if _cfce {
			if !_egbgg {
				continue
			}
			if !_dfcad {
				_fefgb++
				_dfebb.WriteRune(_dbed)
			}
		} else {
			_fefgb = 0
			_egbgg = true
			_dfebb.WriteRune(_dbed)
		}
		_dfcad = _cfce
	}
	_dfebb.Truncate(_dfebb.Len() - _fefgb)
	return MakeStringResult(_dfebb.String())
}

// RandBetween is an implementation of the Excel RANDBETWEEN() function that returns a random
// integer in the range specified.
func RandBetween(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0052A\u004e\u0044B\u0045\u0054\u0057\u0045E\u004e\u0028\u0029 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006eu\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_dbad := args[0].AsNumber()
	_aabg := args[1].AsNumber()
	if _dbad.Type != ResultTypeNumber || _aabg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052A\u004e\u0044B\u0045\u0054\u0057\u0045E\u004e\u0028\u0029 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006eu\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	if _aabg.ValueNumber < _dbad.ValueNumber {
		return MakeErrorResult("\u0052\u0041\u004e\u0044\u0042E\u0054\u0057\u0045\u0045\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065r")
	}
	_efcfa := int64(_dbad.ValueNumber)
	_fefd := int64(_aabg.ValueNumber)
	return MakeNumberResult(float64(_cdcb.Int63n(_fefd-_efcfa+1) + _efcfa))
}

type xargs struct {
	_debc []float64
	_gefg []float64
}

type noCache struct{}

// Yieldmat implements the Excel YIELDMAT function.
func Yieldmat(args []Result) Result {
	_ebgc := len(args)
	if _ebgc != 5 && _ebgc != 6 {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0069v\u0065\u0020\u006f\u0072\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_cebe, _babbc, _dgg := _dfd(args[0], args[1], "\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054")
	if _dgg.Type == ResultTypeError {
		return _dgg
	}
	_eface, _dgg := _faeb(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054")
	if _dgg.Type == ResultTypeError {
		return _dgg
	}
	if _eface >= _cebe {
		return MakeErrorResult("\u0059\u0049\u0045\u004cD\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0062\u0065\u0066\u006fr\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049E\u004c\u0044\u004d\u0041T\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_bddgbf := args[3].ValueNumber
	if _bddgbf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0049\u0045\u004c\u0044M\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_fabbf := args[4].ValueNumber
	if _fabbf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "Y\u0049\u0045\u004c\u0044\u004d\u0041T\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0072\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069v\u0065")
	}
	_ddge := 0
	if _ebgc == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0059I\u0045\u004cD\u004d\u0041\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_ddge = int(args[5].ValueNumber)
		if !_cfee(_ddge) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0059\u0049\u0045L\u0044\u004d\u0041\u0054")
		}
	}
	_ccebd, _dgg := _fea(_eface, _babbc, _ddge)
	if _dgg.Type == ResultTypeError {
		return _dgg
	}
	_cbfb, _dgg := _fea(_eface, _cebe, _ddge)
	if _dgg.Type == ResultTypeError {
		return _dgg
	}
	_facd, _dgg := _fea(_cebe, _babbc, _ddge)
	if _dgg.Type == ResultTypeError {
		return _dgg
	}
	_bcecd := 1 + _ccebd*_bddgbf
	_bcecd /= _fabbf/100 + _cbfb*_bddgbf
	_bcecd--
	_bcecd /= _facd
	return MakeNumberResult(_bcecd)
}

// Exact is an implementation of the Excel EXACT() which compares two strings.
func Exact(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041\u0054\u0045N\u0041\u0054\u0045(\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_afdc := args[0].AsString()
	_dafcc := args[1].AsString()
	if _afdc.Type != ResultTypeString || _dafcc.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041\u0054\u0045N\u0041\u0054\u0045(\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(_afdc.ValueString == _dafcc.ValueString)
}

func (_bggf PrefixHorizontalRange) horizontalRangeReference(_bdfd string) string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0064\u003a\u0025\u0064", _bdfd, _bggf._gfad, _bggf._cfaf)
}

// Reference returns an invalid reference for ConstArrayExpr.
func (_fab ConstArrayExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

func init() {
	RegisterFunction("\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d", Accrintm)
	RegisterFunction("\u0041M\u004f\u0052\u0044\u0045\u0047\u0052C", Amordegrc)
	RegisterFunction("\u0041\u004d\u004f\u0052\u004c\u0049\u004e\u0043", Amorlinc)
	RegisterFunction("\u0043O\u0055\u0050\u0044\u0041\u0059\u0042S", Coupdaybs)
	RegisterFunction("\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053", Coupdays)
	RegisterFunction("\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053\u004e\u0043", Coupdaysnc)
	RegisterFunction("\u0043O\u0055\u0050\u004e\u0055\u004d", Coupnum)
	RegisterFunction("\u0043O\u0055\u0050\u004e\u0043\u0044", Coupncd)
	RegisterFunction("\u0043O\u0055\u0050\u0050\u0043\u0044", Couppcd)
	RegisterFunction("\u0043U\u004d\u0049\u0050\u004d\u0054", Cumipmt)
	RegisterFunction("\u0043\u0055\u004d\u0050\u0052\u0049\u004e\u0043", Cumprinc)
	RegisterFunction("\u0044\u0042", Db)
	RegisterFunction("\u0044\u0044\u0042", Ddb)
	RegisterFunction("\u0044\u0049\u0053\u0043", Disc)
	RegisterFunction("\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045", Dollarde)
	RegisterFunction("\u0044\u004f\u004c\u004c\u0041\u0052\u0046\u0052", Dollarfr)
	RegisterFunction("\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e", Duration)
	RegisterFunction("\u0045\u0046\u0046\u0045\u0043\u0054", Effect)
	RegisterFunction("\u0046\u0056", Fv)
	RegisterFunction("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045", Fvschedule)
	RegisterFunction("\u0049N\u0054\u0052\u0041\u0054\u0045", Intrate)
	RegisterFunction("\u0049\u0050\u004d\u0054", Ipmt)
	RegisterFunction("\u0049\u0052\u0052", Irr)
	RegisterFunction("\u0049\u0053\u0050M\u0054", Ispmt)
	RegisterFunction("\u004dD\u0055\u0052\u0041\u0054\u0049\u004fN", Mduration)
	RegisterFunction("\u004d\u0049\u0052\u0052", Mirr)
	RegisterFunction("\u004eO\u004d\u0049\u004e\u0041\u004c", Nominal)
	RegisterFunction("\u004e\u0050\u0045\u0052", Nper)
	RegisterFunction("\u004e\u0050\u0056", Npv)
	RegisterFunction("\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E", Oddlprice)
	RegisterFunction("\u004fD\u0044\u004c\u0059\u0049\u0045\u004cD", Oddlyield)
	RegisterFunction("\u0050D\u0055\u0052\u0041\u0054\u0049\u004fN", Pduration)
	RegisterFunction("\u005fx\u006cf\u006e\u002e\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e", Pduration)
	RegisterFunction("\u0050\u004d\u0054", Pmt)
	RegisterFunction("\u0050\u0050\u004d\u0054", Ppmt)
	RegisterFunction("\u0050\u0052\u0049C\u0045", Price)
	RegisterFunction("\u0050R\u0049\u0043\u0045\u0044\u0049\u0053C", Pricedisc)
	RegisterFunction("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054", Pricemat)
	RegisterFunction("\u0050\u0056", Pv)
	RegisterFunction("\u0052\u0041\u0054\u0045", Rate)
	RegisterFunction("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044", Received)
	RegisterFunction("\u0052\u0052\u0049", Rri)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0052\u0052I", Rri)
	RegisterFunction("\u0053\u004c\u004e", Sln)
	RegisterFunction("\u0053\u0059\u0044", Syd)
	RegisterFunction("\u0054B\u0049\u004c\u004c\u0045\u0051", Tbilleq)
	RegisterFunction("\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045", Tbillprice)
	RegisterFunction("\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044", Tbillyield)
	RegisterFunction("\u0056\u0044\u0042", Vdb)
	RegisterFunction("\u0058\u0049\u0052\u0052", Xirr)
	RegisterFunction("\u0058\u004e\u0050\u0056", Xnpv)
	RegisterFunction("\u0059\u0049\u0045L\u0044", Yield)
	RegisterFunction("\u0059I\u0045\u004c\u0044\u0044\u0049\u0053C", Yielddisc)
	RegisterFunction("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054", Yieldmat)
}

// GetFilename returns an empty string for the invalid reference context.
func (_ffgef *ivr) GetFilename() string { return "" }

func _cfee(_dcab int) bool { return _dcab >= 0 && _dcab <= 4 }

// ISFORMULA is an implementation of the Excel ISFORMULA() function.
func IsFormula(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053F\u004f\u0052\u004d\u0055L\u0041\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073 \u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ddgb := args[0].Ref
	if _ddgb.Type != ReferenceTypeCell {
		return MakeErrorResult("I\u0053\u0046\u004f\u0052\u004d\u0055\u004c\u0041\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072\u0067\u0075\u006de\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
	}
	return MakeBoolResult(ctx.HasFormula(_ddgb.Value))
}

// False is an implementation of the Excel FALSE() function. It takes no
// arguments.
func False(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0046A\u004c\u0053\u0045\u0020\u0074\u0061\u006b\u0065\u0073\u0020\u006eo\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(false)
}

func _baf(_aeefc Result) []Result {
	_cadae := _aeefc.ValueList
	if _aeefc.Type == ResultTypeArray {
		_cadae = nil
		for _, _cdaf := range _aeefc.ValueArray {
			if len(_cdaf) > 0 {
				_cadae = append(_cadae, _cdaf[0])
			} else {
				_cadae = append(_cadae, _ffe)
			}
		}
	}
	return _cadae
}

var _fefab = [...]string{"\u0024\u0065\u006e\u0064", "\u0065\u0072\u0072o\u0072", "\u0024\u0075\u006e\u006b", "t\u006fk\u0065\u006e\u0048\u006f\u0072\u0069\u007a\u006fn\u0074\u0061\u006c\u0052an\u0067\u0065", "\u0074o\u006be\u006e\u0056\u0065\u0072\u0074i\u0063\u0061l\u0052\u0061\u006e\u0067\u0065", "\u0074\u006f\u006b\u0065\u006e\u0052\u0065\u0073\u0065\u0072\u0076\u0065d\u004e\u0061\u006d\u0065", "\u0074\u006f\u006be\u006e\u0044\u0044\u0045\u0043\u0061\u006c\u006c", "\u0074\u006f\u006b\u0065\u006e\u004c\u0065\u0078\u0045\u0072\u0072\u006f\u0072", "\u0074o\u006be\u006e\u004e\u0061\u006d\u0065\u0064\u0052\u0061\u006e\u0067\u0065", "\u0074o\u006b\u0065\u006e\u0042\u006f\u006fl", "t\u006f\u006b\u0065\u006e\u004e\u0075\u006d\u0062\u0065\u0072", "t\u006f\u006b\u0065\u006e\u0053\u0074\u0072\u0069\u006e\u0067", "\u0074\u006f\u006b\u0065\u006e\u0045\u0072\u0072\u006f\u0072", "\u0074\u006f\u006b\u0065\u006e\u0045\u0072\u0072\u006f\u0072\u0052\u0065\u0066", "\u0074\u006f\u006b\u0065\u006e\u0053\u0068\u0065\u0065\u0074", "\u0074o\u006b\u0065\u006e\u0043\u0065\u006cl", "t\u006fk\u0065\u006e\u0046\u0075\u006e\u0063\u0074\u0069o\u006e\u0042\u0075\u0069lt\u0069\u006e", "t\u006f\u006b\u0065\u006e\u004c\u0042\u0072\u0061\u0063\u0065", "t\u006f\u006b\u0065\u006e\u0052\u0042\u0072\u0061\u0063\u0065", "t\u006f\u006b\u0065\u006e\u004c\u0050\u0061\u0072\u0065\u006e", "t\u006f\u006b\u0065\u006e\u0052\u0050\u0061\u0072\u0065\u006e", "\u0074o\u006b\u0065\u006e\u0050\u006c\u0075s", "\u0074\u006f\u006b\u0065\u006e\u004d\u0069\u006e\u0075\u0073", "\u0074o\u006b\u0065\u006e\u004d\u0075\u006ct", "\u0074\u006f\u006b\u0065\u006e\u0044\u0069\u0076", "\u0074\u006f\u006b\u0065\u006e\u0045\u0078\u0070", "\u0074o\u006b\u0065\u006e\u0045\u0051", "\u0074o\u006b\u0065\u006e\u004c\u0054", "\u0074o\u006b\u0065\u006e\u0047\u0054", "\u0074\u006f\u006b\u0065\u006e\u004c\u0045\u0051", "\u0074\u006f\u006b\u0065\u006e\u0047\u0045\u0051", "\u0074o\u006b\u0065\u006e\u004e\u0045", "\u0074\u006f\u006b\u0065\u006e\u0043\u006f\u006c\u006f\u006e", "\u0074\u006f\u006b\u0065\u006e\u0043\u006f\u006d\u006d\u0061", "\u0074\u006f\u006b\u0065\u006e\u0041\u006d\u0070\u0065r\u0073\u0061\u006e\u0064", "\u0074o\u006b\u0065\u006e\u0053\u0065\u006di"}

// Fv implements the Excel FV function.
func Fv(args []Result) Result {
	_ffdb := len(args)
	if _ffdb < 3 || _ffdb > 5 {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u00205")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dcge := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_cgga := args[1].ValueNumber
	if _cgga != float64(int(_cgga)) {
		return MakeErrorResultType(ErrorTypeNum, "\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0061\u0079\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aaeb := args[2].ValueNumber
	_fcag := 0.0
	if _ffdb >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("F\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0070\u0072\u0065\u0073\u0065\u006et \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_fcag = args[3].ValueNumber
	}
	_accc := 0
	if _ffdb == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_accc = int(args[4].ValueNumber)
		if _accc != 0 {
			_accc = 1
		}
	}
	return MakeNumberResult(_cfgg(_dcge, _cgga, _aaeb, _fcag, _accc))
}

// Atan2 implements the Excel ATAN2 function.  It accepts two numeric arguments,
// and the arguments are (x,y), reversed from normal to match Excel's behaviour.
func Atan2(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0041\u0054\u0041\u004e2\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077o\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	_bgea := args[0].AsNumber()
	_cggfe := args[1].AsNumber()
	if _bgea.Type == ResultTypeNumber && _cggfe.Type == ResultTypeNumber {
		_bcgf := _dc.Atan2(_cggfe.ValueNumber, _bgea.ValueNumber)
		if _bcgf != _bcgf {
			return MakeErrorResult("\u0041T\u0041N\u0032\u0020\u0072\u0065\u0074u\u0072\u006ee\u0064\u0020\u004e\u0061\u004e")
		}
		return MakeNumberResult(_bcgf)
	}
	for _, _babf := range []ResultType{_bgea.Type, _cggfe.Type} {
		switch _babf {
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult("\u0041\u0054\u0041\u004e\u0032\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		case ResultTypeError:
			return _bgea
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068an\u0064\u006c\u0065\u0064\u0020\u0041\u0054\u0041\u004e2\u0028)\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _babf))
		}
	}
	return MakeErrorResult("u\u006e\u0068\u0061\u006e\u0064\u006ce\u0064\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0066o\u0072\u0020\u0041T\u0041N\u0032\u0028\u0029")
}

// MinIfs implements the MINIFS function.
func MinIfs(args []Result) Result {
	_deac := _gdgfe(args, true, "\u004d\u0049\u004e\u0049\u0046\u0053")
	if _deac.Type != ResultTypeEmpty {
		return _deac
	}
	_ceecc := _eabc(args[1:])
	_deebd := _dc.MaxFloat64
	_eaeaf := _cdafd(args[0])
	for _, _fgbag := range _ceecc {
		_fgcaa := _eaeaf[_fgbag._ffaab][_fgbag._edga].ValueNumber
		if _deebd > _fgcaa {
			_deebd = _fgcaa
		}
	}
	if _deebd == _dc.MaxFloat64 {
		_deebd = 0
	}
	return MakeNumberResult(float64(_deebd))
}

func _agg(_gbdg, _fgca float64, _cdb, _abcc int) float64 {
	_eabb := _fae(_gbdg)
	_ddab := _fae(_fgca)
	_gbfd := _aacd(_eabb, _ddab, _cdb)
	return _gfgb(_eabb, _gbfd, _abcc)
}

func _ceggf(_fagadc string, _afac func(_fdfg float64) float64) Function {
	return func(_bfcf []Result) Result {
		if len(_bfcf) != 1 {
			return MakeErrorResult(_fagadc + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_gccae := _bfcf[0].AsNumber()
		switch _gccae.Type {
		case ResultTypeNumber:
			_edfe := _afac(_gccae.ValueNumber)
			if _dc.IsNaN(_edfe) {
				return MakeErrorResult(_fagadc + "\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0065\u0064\u0020\u004e\u0061\u004e")
			}
			if _dc.IsInf(_edfe, 0) {
				return MakeErrorResult(_fagadc + "\u0020r\u0065t\u0075\u0072\u006e\u0065\u0064 \u0069\u006ef\u0069\u006e\u0069\u0074\u0079")
			}
			return MakeNumberResult(_edfe)
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult(_fagadc + "\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072i\u0063\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		case ResultTypeError:
			return _gccae
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068a\u006e\u0064\u006c\u0065d\u0020\u0025\u0073\u0028\u0029\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _fagadc, _gccae.Type))
		}
	}
}

const _gfdb = 57369

func _gfbef(_bcfg Context, _fbfc, _gcda string) (string, string) {
	_afed := _fbfc + "\u0031"
	_eagbb := _bcfg.LastRow(_fbfc)
	_dgbecc := _gcda + _ff.Itoa(_eagbb)
	return _afed, _dgbecc
}

func (_efgc Result) AsString() Result {
	switch _efgc.Type {
	case ResultTypeNumber:
		return MakeStringResult(_efgc.Value())
	default:
		return _efgc
	}
}

// Column implements the Excel COLUMN function.
func Column(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0043\u004f\u004c\u0055M\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_bfgc := args[0].Ref
	if _bfgc.Type != ReferenceTypeCell {
		return MakeErrorResult("\u0043\u004f\u004c\u0055\u004dN\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e")
	}
	_geag, _faac := _cb.ParseCellReference(_bfgc.Value)
	if _faac != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _bfgc.Value)
	}
	return MakeNumberResult(float64(_geag.ColumnIdx + 1))
}

// MDeterm is an implementation of the Excel MDETERM which finds the determinant
// of a matrix.
func MDeterm(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0044\u0045T\u0045\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0072\u0061\u0079 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dgbgg := args[0]
	if _dgbgg.Type != ResultTypeArray {
		return MakeErrorResult("\u004d\u0044\u0045T\u0045\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0072\u0061\u0079 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_efge := len(_dgbgg.ValueArray)
	for _, _acgf := range _dgbgg.ValueArray {
		if len(_acgf) != _efge {
			return MakeErrorResult("\u004d\u0044\u0045TE\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u0061 \u0073\u0071\u0075\u0061\u0072\u0065\u0020\u006d\u0061\u0074\u0072\u0069\u0078")
		}
	}
	return MakeNumberResult(_fgdfb(_dgbgg.ValueArray))
}

// CountIf implements the COUNTIF function.
func CountIf(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0043\u004f\u0055N\u0054\u0049\u0046\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0073")
	}
	_cfba := args[0]
	if _cfba.Type != ResultTypeArray && _cfba.Type != ResultTypeList {
		return MakeErrorResult("\u0043O\u0055\u004eT\u0049\u0046\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_afgd := _cacg(args[1])
	_ceed := 0
	for _, _ebag := range _cdafd(_cfba) {
		for _, _abab := range _ebag {
			if _egaa(_abab, _afgd) {
				_ceed++
			}
		}
	}
	return MakeNumberResult(float64(_ceed))
}

func (_bdbga *Lexer) Next() *node {
	_bdbga._cdba.Lock()
	defer _bdbga._cdba.Unlock()
	if len(_bdbga._ecgad) > 0 {
		_debfd := _bdbga._ecgad[0]
		_bdbga._ecgad = _bdbga._ecgad[1:]
		return _debfd
	}
	return _bdbga.nextRaw()
}

func _eddf(_fagad, _dfeaa, _fbdc, _adce, _bfdg float64) float64 {
	var _dbgc float64
	_bfec := _bfdg / _fbdc
	if _bfec >= 1 {
		_bfec = 1
		if _adce == 1 {
			_dbgc = _fagad
		} else {
			_dbgc = 0
		}
	} else {
		_dbgc = _fagad * _dc.Pow(1-_bfec, _adce-1)
	}
	_acac := _fagad * _dc.Pow(1-_bfec, _adce)
	var _ddbbf float64
	if _acac < _dfeaa {
		_ddbbf = _dbgc - _dfeaa
	} else {
		_ddbbf = _dbgc - _acac
	}
	if _ddbbf < 0 {
		_ddbbf = 0
	}
	return _ddbbf
}

type ivr struct{}

func _cffd(_gacb []Result, _ggcaa string) (float64, float64, Result) {
	if len(_gacb) != 2 {
		return 0, 0, MakeErrorResult(_ggcaa + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _gacb[0].Type != ResultTypeNumber {
		return 0, 0, MakeErrorResult(_ggcaa + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0061\u006c\u0020\u0064\u006f\u006c\u006c\u0061\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_fdagd := _gacb[0].ValueNumber
	if _gacb[1].Type != ResultTypeNumber {
		return 0, 0, MakeErrorResult(_ggcaa + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_cdfd := float64(int(_gacb[1].ValueNumber))
	if _cdfd < 0 {
		return 0, 0, MakeErrorResultType(ErrorTypeNum, _ggcaa+"\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073 \u0066\u0072\u0061c\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062e \u006e\u006f\u006e \u006e\u0065g\u0061\u0074\u0069\u0076\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	return _fdagd, _cdfd, _ffe
}

const _acaag = 57370

// Year is an implementation of the Excel YEAR() function.
func Year(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_bec := ctx.GetEpoch()
	_ccfe, _edc := _aefcg(args[0].Value(), _bec)
	if _edc != nil {
		return MakeErrorResult("\u0059\u0045AR\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s a\u0020si\u006e\u0067\u006c\u0065\u0020\u0064\u0061te\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeNumberResult(float64(_ccfe.Year()))
}

// DateValue is an implementation of the Excel DATEVALUE() function.
func DateValue(args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0044A\u0054\u0045V\u0041\u004c\u0055\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069ng\u006c\u0065\u0020s\u0074\u0072i\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_ed := _ee.ToLower(args[0].ValueString)
	if !_aabb(_ed) {
		_, _, _, _, _bfc, _gbad := _ffge(_ed)
		if _gbad.Type == ResultTypeError {
			_gbad.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020f\u006f\u0072\u0020\u0044\u0041\u0054\u0045V\u0041\u004c\u0055\u0045"
			return _gbad
		}
		if _bfc {
			return MakeNumberResult(0)
		}
	}
	_cba, _cfef, _eegg, _, _bbe := _dfb(_ed)
	if _bbe.Type == ResultTypeError {
		return _bbe
	}
	return MakeNumberResult(_acb(_cba, _cfef, _eegg))
}

// MinA is an implementation of the Excel MINA() function.
func MinA(args []Result) Result { return _dgedb(args, true) }

// Rate implements the Excel RATE function.
func Rate(args []Result) Result {
	_eaeg := len(args)
	if _eaeg < 3 || _eaeg > 6 {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0074\u0068\u0072\u0065\u0065 \u0061\u006e\u0064\u0020\u0073i\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_agb := args[0].ValueNumber
	if _agb != float64(int(_agb)) {
		return MakeErrorResultType(ErrorTypeNum, "R\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072i\u006fd\u0073\u0020\u0074\u006f \u0062\u0065 \u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0070\u0061y\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cdcf := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_dfbe := args[2].ValueNumber
	_bgeg := 0.0
	if _eaeg >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_bgeg = args[3].ValueNumber
	}
	_gagg := 0.0
	if _eaeg >= 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("R\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_gagg = args[4].ValueNumber
		if _gagg != 0 {
			_gagg = 1
		}
	}
	_gcga := 0.1
	if _eaeg >= 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_gcga = args[5].ValueNumber
	}
	_dgbg := 100
	_bfdc := 0
	_ccef := false
	_daaa := 1e-6
	_dffc := _gcga
	for _bfdc < _dgbg && !_ccef {
		_dgae := _dc.Pow(_dffc+1, _agb)
		_ggfd := _dc.Pow(_dffc+1, _agb-1)
		_gbed := _dffc*_gagg + 1
		_dbde := _cdcf * (_dgae - 1)
		_dcac := _bgeg + _dgae*_dfbe + _dbde*_gbed/_dffc
		_cffc := _agb*_ggfd*_dfbe - _dbde*_gbed/_dc.Pow(_dffc, 2)
		_ecfa := (_agb*_cdcf*_ggfd*_gbed + _dbde*_gagg) / _dffc
		_baaec := _dcac / (_cffc + _ecfa)
		if _dc.Abs(_baaec) < _daaa {
			_ccef = true
		}
		_bfdc++
		_dffc -= _baaec
	}
	return MakeNumberResult(_dffc)
}

// LastRow returns 0 for the invalid reference context.
func (_dbbc *ivr) LastRow(colFrom string) int { return 0 }

// Fact is an implementation of the excel FACT function which returns the
// factorial of a positive numeric input.
func Fact(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("F\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_baaed := args[0].AsNumber()
	if _baaed.Type != ResultTypeNumber {
		return MakeErrorResult("F\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	if _baaed.ValueNumber < 0 {
		return MakeErrorResult("\u0046\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006f\u006e\u006c\u0079\u0020\u0070\u006f\u0073\u0069t\u0069\u0076\u0065\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	return MakeNumberResult(_abgd(_baaed.ValueNumber))
}

// Searchb is an implementation of the Excel SEARCHB().
func Searchb(ctx Context, ev Evaluator, args []Result) Result {
	if !ctx.IsDBCS() {
		return Search(args)
	}
	_afba, _ceeca := _acfc("\u0046\u0049\u004e\u0044", args)
	if _ceeca.Type != ResultTypeEmpty {
		return _ceeca
	}
	_gdfefc := _ee.ToLower(_afba._dede)
	_aabgd := _ee.ToLower(_afba._affa)
	if _gdfefc == "" {
		return MakeNumberResult(1.0)
	}
	_dcgef := _afba._caacac - 1
	_abeae := 1
	_gedde := 0
	for _aafd := range _aabgd {
		if _aafd != 0 {
			_geaff := 1
			if _aafd-_gedde > 1 {
				_geaff = 2
			}
			_abeae += _geaff
		}
		if _abeae > _dcgef {
			_gdgeb := _ag.Index(_gdfefc, _aabgd[_aafd:])
			if _gdgeb == 0 {
				return MakeNumberResult(float64(_abeae))
			}
		}
		_gedde = _aafd
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// String returns a string representation of Number.
func (_bdeg Number) String() string { return _ff.FormatFloat(_bdeg._becb, 'f', -1, 64) }

func _fcge(_bad, _cgb float64, _abbe, _bacf int) float64 {
	_eec := _fae(_bad)
	_deaf := _fae(_cgb)
	if _bacf == 1 {
		_agad := _dfcf(_eec, _deaf, _abbe, 1)
		_geafg := _agad.AddDate(0, 12/_abbe, 0)
		return _gfgb(_agad, _geafg, _bacf)
	}
	return float64(_ebab(0, _bacf)) / float64(_abbe)
}

// Update makes a reference to point to one of the neighboring cells after removing a row/column with respect to the update type.
func (_baa CellRef) Update(q *_cc.UpdateQuery) Expression {
	if q.UpdateCurrentSheet {
		_baa._bda = _eef(_baa._bda, q)
	}
	return _baa
}

func _cbag(_cfeee []Result, _gcbfa bool) (float64, float64) {
	_becfa := 0.0
	_edgc := 0.0
	for _, _ebeg := range _cfeee {
		switch _ebeg.Type {
		case ResultTypeNumber:
			if _gcbfa || !_ebeg.IsBoolean {
				_edgc += _ebeg.ValueNumber
				_becfa++
			}
		case ResultTypeList, ResultTypeArray:
			_bfda, _aaec := _cbag(_ebeg.ListValues(), _gcbfa)
			_edgc += _bfda
			_becfa += _aaec
		case ResultTypeString:
			if _gcbfa {
				_becfa++
			}
		case ResultTypeEmpty:
		}
	}
	return _edgc, _becfa
}

// Reference returns an invalid reference for Bool.
func (_agdc Bool) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

func _ba(_ccg Result) bool {
	if _ccg.Type == ResultTypeString {
		return _ccg.ValueString == ""
	}
	return _ccg.ValueNumber == 0
}

const (
	ErrorTypeValue ErrorType = iota
	ErrorTypeNull
	ErrorTypeRef
	ErrorTypeName
	ErrorTypeNum
	ErrorTypeSpill
	ErrorTypeNA
	ErrorTypeDivideByZero
)

const _cecbb = 57364

// Product is an implementation of the Excel PRODUCT() function.
func Product(args []Result) Result {
	_ebac := 1.0
	for _, _cadda := range args {
		_cadda = _cadda.AsNumber()
		switch _cadda.Type {
		case ResultTypeNumber:
			_ebac *= _cadda.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_edea := Product(_cadda.ListValues())
			if _edea.Type != ResultTypeNumber {
				return _edea
			}
			_ebac *= _edea.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _cadda
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006eha\u006e\u0064\u006ce\u0064\u0020\u0050\u0052ODU\u0043T(\u0029\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0020\u0074\u0079\u0070\u0065\u0020%\u0073", _cadda.Type))
		}
	}
	return MakeNumberResult(_ebac)
}

// Small implements the Excel SMALL function.
func Small(args []Result) Result { return _bceae(args, false) }

// MakeArrayResult constructs an array result (matrix).
func MakeArrayResult(arr [][]Result) Result { return Result{Type: ResultTypeArray, ValueArray: arr} }

func (_gfc *defEval) checkLastEvalIsRef(_egf Context, _dcc Expression) {
	switch _dcc.(type) {
	case FunctionCall:
		switch _dcc.(FunctionCall)._fbae {
		case "\u0049\u0053\u0052E\u0046":
			for _, _dad := range _dcc.(FunctionCall)._agff {
				switch _dad.(type) {
				case CellRef, Range, HorizontalRange, VerticalRange, NamedRangeRef, PrefixExpr, PrefixRangeExpr, PrefixHorizontalRange, PrefixVerticalRange:
					_geae := _dad.Eval(_egf, _gfc)
					_gfc._egb = !(_geae.Type == ResultTypeError && _geae.ValueString == "\u0023\u004e\u0041\u004d\u0045\u003f")
				default:
					_gfc._egb = false
				}
			}
		}
	}
}

// Reference returns a string reference value to a vertical range with prefix.
func (_acdcf PrefixVerticalRange) Reference(ctx Context, ev Evaluator) Reference {
	_beaba := _acdcf._edebe.Reference(ctx, ev)
	return Reference{Type: ReferenceTypeVerticalRange, Value: _acdcf.verticalRangeReference(_beaba.Value)}
}

// Error is an error expression.
type Error struct{ _gag string }

func _acef(_dddd []Result, _eea string) (*cumulArgs, Result) {
	if len(_dddd) != 6 {
		return nil, MakeErrorResult(_eea + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _dddd[0].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_eea + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0072\u0061te \u0074o \u0062\u0065\u0020\u006e\u0075\u006d\u0062er\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_afbf := _dddd[0].ValueNumber
	if _afbf <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _eea+"\u0020r\u0065\u0071u\u0069\u0072\u0065s\u0020\u0072\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006fs\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _dddd[1].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_eea + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_agc := _dddd[1].ValueNumber
	if _agc <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _eea+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	if _dddd[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_eea + "\u0020r\u0065\u0071u\u0069\u0072\u0065s\u0020\u0070\u0072\u0065\u0073\u0065\u006et\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fdag := _dddd[2].ValueNumber
	if _fdag <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _eea+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _dddd[3].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_eea + "\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073 \u0073\u0074\u0061r\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_cafe := _dddd[3].ValueNumber
	if _cafe <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _eea+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073t\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069o\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _dddd[4].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_eea + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_egde := _dddd[4].ValueNumber
	if _egde <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _eea+"\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020\u0070\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	if _egde < _cafe {
		return nil, MakeErrorResultType(ErrorTypeNum, _eea+"\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020p\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0061\u0074\u0065\u0072\u0020o\u0072\u0020\u0065\u0071\u0075a\u006c\u0020\u0074\u006f\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064")
	}
	if _egde > _agc {
		return nil, MakeErrorResultType(ErrorTypeNum, _eea+" \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074o\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0070\u0065\u0072io\u0064\u0073\u0020r\u0061n\u0067\u0065")
	}
	_gaad := int(_dddd[5].ValueNumber)
	if _gaad != 0 && _gaad != 1 {
		return nil, MakeErrorResultType(ErrorTypeNum, _eea+" \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f \u0062\u0065\u00200\u0020o\u0072\u0020\u0031")
	}
	return &cumulArgs{_afbf, _agc, _fdag, _cafe, _egde, _gaad}, _ffe
}

type cmpResult int8

func _fada(_bdae []Result, _bcddc []string, _fbde bool) []string {
	for _, _gefb := range _bdae {
		switch _gefb.Type {
		case ResultTypeEmpty:
			if !_fbde {
				_bcddc = append(_bcddc, "")
			}
		case ResultTypeString:
			if _gefb.ValueString != "" || !_fbde {
				_bcddc = append(_bcddc, _gefb.ValueString)
			}
		case ResultTypeNumber:
			_bcddc = append(_bcddc, _gefb.Value())
		case ResultTypeList:
			_bcddc = _baaba(_bcddc, _fada(_gefb.ValueList, []string{}, _fbde))
		case ResultTypeArray:
			for _, _dggb := range _gefb.ValueArray {
				_bcddc = _baaba(_bcddc, _fada(_dggb, []string{}, _fbde))
			}
		}
	}
	return _bcddc
}

func _fgbb(_dbfg, _gbg, _fgcd, _dccfb int) int {
	if !_ecbad(_dccfb) {
		return _fgcd
	}
	_gcfc := _fgcd
	_dfbg := _gfgc(_dbfg, _gbg)
	if _gcfc > 30 || _fgcd >= _dfbg || _gcfc >= _dfbg {
		_gcfc = 30
	}
	return _gcfc
}

// Update returns the same object as updating sheet references does not affect Bool.
func (_gcc Bool) Update(q *_cc.UpdateQuery) Expression { return _gcc }

func _bceae(_dgee []Result, _eecb bool) Result {
	var _fgaf string
	if _eecb {
		_fgaf = "\u004c\u0041\u0052G\u0045"
	} else {
		_fgaf = "\u0053\u004d\u0041L\u004c"
	}
	if len(_dgee) != 2 {
		return MakeErrorResult(_fgaf + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_edeb := _dgee[0]
	var _facgf [][]Result
	switch _edeb.Type {
	case ResultTypeArray:
		_facgf = _edeb.ValueArray
	case ResultTypeList:
		_facgf = [][]Result{_edeb.ValueList}
	default:
		return MakeErrorResult(_fgaf + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u006f\u0066\u0020\u0074\u0079p\u0065\u0020a\u0072\u0072\u0061\u0079")
	}
	if len(_facgf) == 0 {
		return MakeErrorResult(_fgaf + "\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0074\u006f\u0020c\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0031\u0020\u0072\u006f\u0077")
	}
	if _dgee[1].Type != ResultTypeNumber {
		return MakeErrorResult(_fgaf + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074yp\u0065\u0020\u006eu\u006db\u0065\u0072")
	}
	_cdbec := _dgee[1].ValueNumber
	if _cdbec < 1 {
		return MakeErrorResultType(ErrorTypeNum, _fgaf+"\u0020\u0072e\u0071\u0075\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006fn\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030")
	}
	_fafb := int(_cdbec)
	if float64(_fafb) != _cdbec {
		return MakeErrorResultType(ErrorTypeNum, _fgaf+"\u0020\u0072e\u0071\u0075\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006fn\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030")
	}
	_dfded := []float64{}
	for _, _edcg := range _facgf {
		for _, _ebaf := range _edcg {
			if _ebaf.Type == ResultTypeNumber {
				_dfded = append(_dfded, _ebaf.ValueNumber)
			}
		}
	}
	if _fafb > len(_dfded) {
		return MakeErrorResultType(ErrorTypeNum, _fgaf+" \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u006c\u0065s\u0073\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u0068\u0061\u006e\u0020t\u0068\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072s\u0020\u0069\u006e\u0020t\u0068\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_agbb := _ea.MergeSort(_dfded)
	if _eecb {
		return MakeNumberResult(_agbb[len(_agbb)-_fafb])
	} else {
		return MakeNumberResult(_agbb[_fafb-1])
	}
}

type durationArgs struct {
	_aedc float64
	_cfa  float64
	_dcfg float64
	_deec float64
	_bfgg float64
	_cadg int
}

// Columns implements the Excel COLUMNS function.
func Columns(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0043\u004fL\u0055\u004d\u004e\u0053\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075me\u006e\u0074")
	}
	_fcabe := args[0]
	if _fcabe.Type != ResultTypeArray && _fcabe.Type != ResultTypeList {
		return MakeErrorResult("\u0043O\u004c\u0055M\u004e\u0053\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_bfeb := _fcabe.ValueArray
	if len(_bfeb) == 0 {
		return MakeErrorResult("\u0043\u004f\u004c\u0055\u004d\u004e\u0053\u0020r\u0065\u0071\u0075ir\u0065\u0073\u0020\u0061\u0072\u0072a\u0079\u0020\u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0031\u0020r\u006f\u0077")
	}
	return MakeNumberResult(float64(len(_bfeb[0])))
}

// Index implements the Excel INDEX function.
func Index(args []Result) Result {
	_adgb := len(args)
	if _adgb < 2 || _adgb > 3 {
		return MakeErrorResult("\u0049\u004e\u0044E\u0058\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u006e\u0065\u0020\u0074\u006f\u0020\u0074\u0068\u0072\u0065\u0065\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dfeb := args[0]
	if _dfeb.Type != ResultTypeArray && _dfeb.Type != ResultTypeList {
		return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0066i\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_fefa := args[1].AsNumber()
	if _fefa.Type != ResultTypeNumber {
		return MakeErrorResult("I\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u006e\u0075\u006d\u0065\u0072\u0069\u0063 \u0072\u006f\u0077\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_dcad := int(_fefa.ValueNumber) - 1
	_ceec := -1
	if _adgb == 3 && args[2].Type != ResultTypeEmpty {
		_cgbd := args[2].AsNumber()
		if _cgbd.Type != ResultTypeNumber {
			return MakeErrorResult("I\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u006e\u0075\u006d\u0065\u0072\u0069\u0063 \u0063\u006f\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_ceec = int(_cgbd.ValueNumber) - 1
	}
	if _dcad == -1 && _ceec == -1 {
		return MakeErrorResult("\u0049\u004e\u0044EX\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072o\u0077 \u006fr\u0020\u0063\u006f\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	var _agfc []Result
	if _dfeb.Type == ResultTypeArray {
		_facg := _dfeb.ValueArray
		if _dcad < -1 || _dcad >= len(_facg) {
			return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0072o\u0077\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
		}
		if _dcad == -1 {
			if _ceec >= len(_facg[0]) {
				return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
			}
			_ebgd := [][]Result{}
			for _, _ebce := range _facg {
				_dcfd := _ebce[_ceec]
				if _dcfd.Type == ResultTypeEmpty {
					_dcfd = MakeNumberResult(0)
				}
				_ebgd = append(_ebgd, []Result{_dcfd})
			}
			return MakeArrayResult(_ebgd)
		}
		_agfc = _facg[_dcad]
	} else {
		_caee := _dfeb.ValueList
		if _dcad < -1 || _dcad >= 1 {
			return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0072o\u0077\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
		}
		if _dcad == -1 {
			if _ceec >= len(_caee) {
				return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
			}
			_afcbc := _caee[_ceec]
			if _afcbc.Type == ResultTypeEmpty {
				_afcbc = MakeNumberResult(0)
			}
			return _afcbc
		}
		_agfc = _caee
	}
	if _ceec < -1 || _ceec > len(_agfc) {
		return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
	}
	if _ceec == -1 {
		_acbc := []Result{}
		for _, _gcca := range _agfc {
			if _gcca.Type == ResultTypeEmpty {
				_acbc = append(_acbc, MakeNumberResult(0))
			} else {
				_acbc = append(_acbc, _gcca)
			}
		}
		return MakeArrayResult([][]Result{_acbc})
	}
	_dbag := _agfc[_ceec]
	if _dbag.Type == ResultTypeEmpty {
		return MakeNumberResult(0)
	}
	return _dbag
}

func _eaedc(_cedb []Result) (float64, float64, Result) {
	_cbfge := 0.0
	_eceg := 1.0
	for _, _cbee := range _cedb {
		switch _cbee.Type {
		case ResultTypeNumber:
			_cbfge += _cbee.ValueNumber
			_eceg *= _abgd(_cbee.ValueNumber)
		case ResultTypeList, ResultTypeArray:
			_fgeba, _gdcb, _fcdgb := _eaedc(_cbee.ListValues())
			_cbfge += _fgeba
			_eceg *= _abgd(_gdcb)
			if _fcdgb.Type == ResultTypeError {
				return 0, 0, _fcdgb
			}
		case ResultTypeString:
			return 0, 0, MakeErrorResult("M\u0055\u004c\u0054\u0049\u004e\u004f\u004d\u0049\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
		case ResultTypeError:
			return 0, 0, _cbee
		}
	}
	return _cbfge, _eceg, _ffe
}

var _cdcea string = string([]byte{92})

// String returns a string representation of PrefixExpr.
func (_aecbb PrefixExpr) String() string {
	return _c.Sprintf("\u0025\u0073\u0021%\u0073", _aecbb._agaa.String(), _aecbb._ddfc.String())
}

func _cffgb(_afccf Result, _eadc, _degc string) (string, Result) {
	switch _afccf.Type {
	case ResultTypeString, ResultTypeNumber, ResultTypeEmpty:
		return _afccf.Value(), _ffe
	default:
		return "", MakeErrorResult(_eadc + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _degc + "\u0020t\u006f\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006db\u0065r\u0020o\u0072\u0020\u0073\u0074\u0072\u0069\u006eg")
	}
}

// ISREF is an implementation of the Excel ISREF() function.
func IsRef(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u0052\u0045\u0046\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(ev.LastEvalIsRef())
}

// CountBlank implements the COUNTBLANK function.
func CountBlank(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043\u004f\u0055N\u0054\u0042\u004c\u0041N\u004b\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(_edbeb(args, _afe))
}

// Search is an implementation of the Excel SEARCH().
func Search(args []Result) Result {
	_dfab, _agee := _acfc("\u0046\u0049\u004e\u0044", args)
	if _agee.Type != ResultTypeEmpty {
		return _agee
	}
	_cbdbd := _ee.ToLower(_dfab._dede)
	if _cbdbd == "" {
		return MakeNumberResult(1.0)
	}
	_gbadd := _ee.ToLower(_dfab._affa)
	_gdfef := _dfab._caacac
	_efca := 1
	for _abccf := range _gbadd {
		if _efca < _gdfef {
			_efca++
			continue
		}
		_deece := _ag.Index(_cbdbd, _gbadd[_abccf:])
		if _deece == 0 {
			return MakeNumberResult(float64(_efca))
		}
		_efca++
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// Pricedisc implements the Excel PRICEDISC function.
func Pricedisc(args []Result) Result {
	_eegb := len(args)
	if _eegb != 4 && _eegb != 5 {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_eced, _cdcd, _fbag := _dfd(args[0], args[1], "\u0050R\u0049\u0043\u0045\u0044\u0049\u0053C")
	if _fbag.Type == ResultTypeError {
		return _fbag
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049C\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_adga := args[2].ValueNumber
	if _adga <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049C\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_cbe := args[3].ValueNumber
	if _cbe <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006fs\u0069\u0074i\u0076\u0065")
	}
	_efda := 0
	if _eegb == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0052I\u0043\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_efda = int(args[4].ValueNumber)
		if !_cfee(_efda) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043")
		}
	}
	_cfbb, _fbag := _fea(_eced, _cdcd, _efda)
	if _fbag.Type == ResultTypeError {
		return _fbag
	}
	return MakeNumberResult(_cbe * (1 - _adga*_cfbb))
}

// Lookup implements the LOOKUP function that returns a matching value from a
// column, or from the same index in a second column.
func Lookup(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0061\u0074\u0020\u006do\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_eabd := args[0]
	_dadb := args[1]
	if _dadb.Type != ResultTypeArray && _dadb.Type != ResultTypeList {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_cdgce := _baf(_dadb)
	_gbdeb := -1
	for _cacf, _ccebdg := range _cdgce {
		if _gdgf(_eabd, _ccebdg, false, false) == _aafg {
			_gbdeb = _cacf
		}
	}
	if _gbdeb == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u004c\u004f\u004f\u004bUP\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075n\u0064")
	}
	_bgbb := _cdgce
	if len(args) == 3 {
		_bgbb = _baf(args[2])
	}
	if _gbdeb < 0 || _gbdeb >= len(_bgbb) {
		return MakeErrorResultType(ErrorTypeNA, "\u004c\u004f\u004f\u004bUP\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075n\u0064")
	}
	return _bgbb[_gbdeb]
}

// IsLogical is an implementation of the Excel ISLOGICAL() function.
func IsLogical(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u004c\u004f\u0047\u0049\u0043A\u004c\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eaddf := args[0].Ref
	if _eaddf.Type != ReferenceTypeCell {
		return MakeErrorResult("I\u0053\u004c\u004f\u0047\u0049\u0043\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072\u0067\u0075\u006de\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
	}
	return MakeBoolResult(ctx.Cell(_eaddf.Value, ev).IsBoolean)
}

const _bbdfb = "\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070\u0065\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070\u0065\u0043\u0065\u006c\u006c\u0052\u0065\u0066\u0065r\u0065\u006ec\u0065\u0054\u0079\u0070e\u004e\u0061\u006d\u0065\u0064\u0052\u0061\u006e\u0067\u0065R\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054y\u0070\u0065\u0052\u0061\u006e\u0067\u0065\u0052\u0065\u0066e\u0072\u0065\u006ec\u0065\u0054\u0079\u0070\u0065\u0053\u0068e\u0065\u0074"

// Duration implements the Excel DURATION function.
func Duration(args []Result) Result {
	_ffgf, _bgbe := _cfag(args, "\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e")
	if _bgbe.Type == ResultTypeError {
		return _bgbe
	}
	_eaeda := _ffgf._aedc
	_gfaba := _ffgf._cfa
	_cdbe := _ffgf._dcfg
	_agagc := _ffgf._deec
	_cabd := _ffgf._bfgg
	_afce := _ffgf._cadg
	return _fec(_eaeda, _gfaba, _cdbe, _agagc, _cabd, _afce)
}

var _bfdcc = false

// RoundDown is an implementation of the Excel ROUNDDOWN function that rounds a number
// down to a specified number of digits.
func RoundDown(args []Result) Result { return _ebcfc(args, _eecgb) }

// Value returns a string version of the result.
func (_ffae Result) Value() string {
	switch _ffae.Type {
	case ResultTypeNumber:
		_aegef := _ff.FormatFloat(_ffae.ValueNumber, 'f', -1, 64)
		if len(_aegef) > 12 {
			_adacg := 12
			for _acbca := _adacg; _acbca > 0 && _aegef[_acbca] == '0'; _acbca-- {
				_adacg--
			}
			_aegef = _aegef[0 : _adacg+1]
		}
		return _aegef
	case ResultTypeError:
		return _ffae.ValueString
	case ResultTypeString:
		return _ffae.ValueString
	case ResultTypeList:
		if len(_ffae.ValueList) == 0 {
			return ""
		}
		return _ffae.ValueList[0].Value()
	case ResultTypeArray:
		if len(_ffae.ValueArray) == 0 || len(_ffae.ValueArray[0]) == 0 {
			return ""
		}
		return _ffae.ValueArray[0][0].Value()
	case ResultTypeEmpty:
		return ""
	default:
		return "\u0075\u006e\u0068\u0061nd\u006c\u0065\u0064\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0076\u0061\u006cu\u0065"
	}
}

// Edate is an implementation of the Excel EDATE() function.
func Edate(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u0044\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077o\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	_dgfb := args[1].ValueNumber
	_eadb := args[0]
	var _ddd float64
	switch _eadb.Type {
	case ResultTypeEmpty:
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	case ResultTypeNumber:
		_ddd = _eadb.ValueNumber
	case ResultTypeString:
		_efgg := DateValue([]Result{args[0]})
		if _efgg.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
		}
		_ddd = _efgg.ValueNumber
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	_dccb := _fae(_ddd)
	_gcfd := _dccb.AddDate(0, int(_dgfb), 0)
	_bdfa, _cecb, _daed := _gcfd.Date()
	_gdbc := _acb(_bdfa, int(_cecb), _daed)
	if _gdbc < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	return MakeNumberResult(_gdbc)
}

// Count implements the COUNT function.
func Count(args []Result) Result { return MakeNumberResult(_edbeb(args, _fdgfd)) }

// Eval evaluates a horizontal range with prefix returning a list of results or an error.
func (_gcbdg PrefixHorizontalRange) Eval(ctx Context, ev Evaluator) Result {
	_efef := _gcbdg._eegae.Reference(ctx, ev)
	switch _efef.Type {
	case ReferenceTypeSheet:
		_fddcc := _gcbdg.horizontalRangeReference(_efef.Value)
		if _bafce, _gbceg := ev.GetFromCache(_fddcc); _gbceg {
			return _bafce
		}
		_bcdac := ctx.Sheet(_efef.Value)
		_agde, _cbfd := _bdbbb(_bcdac, _gcbdg._gfad, _gcbdg._cfaf)
		_fabde := _efbfc(_bcdac, ev, _agde, _cbfd)
		ev.SetCache(_fddcc, _fabde)
		return _fabde
	default:
		return MakeErrorResult(_c.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _efef.Type))
	}
}

// SeriesSum implements the Excel SERIESSUM function.
func SeriesSum(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("\u0053\u0045\u0052\u0049\u0045\u0053\u0053\u0055\u004d\u0028\u0029\u0020\u0072\u0065\u0071u\u0069r\u0065\u0073\u0020\u0034\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_cbbb := args[0].AsNumber()
	_gdcc := args[1].AsNumber()
	_ffc := args[2].AsNumber()
	_gced := args[3].ListValues()
	if _cbbb.Type != ResultTypeNumber || _gdcc.Type != ResultTypeNumber || _ffc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0045\u0052\u0049\u0045\u0053S\u0055\u004d\u0028)\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073t\u0020\u0074\u0068\u0072\u0065e \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063")
	}
	_fgcad := float64(0)
	for _ffbeb, _deccb := range _gced {
		_fgcad += _deccb.ValueNumber * _dc.Pow(_cbbb.ValueNumber, _gdcc.ValueNumber+float64(_ffbeb)*_ffc.ValueNumber)
	}
	return MakeNumberResult(_fgcad)
}

// NewNumber constructs a new number expression.
func NewNumber(v string) Expression {
	_ffedb, _eaeec := _ff.ParseFloat(v, 64)
	if _eaeec != nil {
		_ge.Log("e\u0072\u0072\u006f\u0072\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020f\u006f\u0072\u006d\u0075\u006c\u0061\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0025\u0073\u003a\u0020%\u0073", v, _eaeec)
	}
	return Number{_ffedb}
}

// GCD implements the Excel GCD() function which returns the greatest common
// divisor of a range of numbers.
func GCD(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0047\u0043D(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0061t \u006c\u0065\u0061\u0073\u0074\u0020\u006fne\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_edcb := []float64{}
	for _, _fcged := range args {
		switch _fcged.Type {
		case ResultTypeString:
			_eaad := _fcged.AsNumber()
			if _eaad.Type != ResultTypeNumber {
				return MakeErrorResult("\u0047\u0043D(\u0029\u0020\u006fn\u006c\u0079\u0020\u0061cce\u0070ts\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
			}
			_edcb = append(_edcb, _eaad.ValueNumber)
		case ResultTypeList, ResultTypeArray:
			_fcgb := GCD(_fcged.ListValues())
			if _fcgb.Type != ResultTypeNumber {
				return _fcgb
			}
			_edcb = append(_edcb, _fcgb.ValueNumber)
		case ResultTypeNumber:
			_edcb = append(_edcb, _fcged.ValueNumber)
		case ResultTypeError:
			return _fcged
		default:
			return MakeErrorResult(_c.Sprintf("\u0047\u0043\u0044()\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065d\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _fcged.Type))
		}
	}
	if _edcb[0] < 0 {
		return MakeErrorResult("\u0047\u0043D\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(_edcb) == 1 {
		return MakeNumberResult(_edcb[0])
	}
	_aabd := _edcb[0]
	for _eaeb := 1; _eaeb < len(_edcb); _eaeb++ {
		if _edcb[_eaeb] < 0 {
			return MakeErrorResult("\u0047\u0043D\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
		}
		_aabd = _fcfa(_aabd, _edcb[_eaeb])
	}
	return MakeNumberResult(_aabd)
}

// PrefixExpr is an expression containing reference to another sheet like Sheet1!A1 (the value of the cell A1 from sheet 'Sheet1').
type PrefixExpr struct {
	_agaa Expression
	_ddfc Expression
}

// Reference returns an invalid reference for Negate.
func (_fgegd Negate) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Xnpv implements the Excel XNPV function.
func Xnpv(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0058\u004eP\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("X\u004e\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_cdce := args[0].ValueNumber
	if _cdce <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0058\u004e\u0050\u0056\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	_adbag, _dbcd := _gdfbf(args[1], args[2], "\u0058\u004e\u0050\u0056")
	if _dbcd.Type == ResultTypeError {
		return _dbcd
	}
	_gbdf := _adbag._debc
	_ggcg := _adbag._gefg
	_cafc := 0.0
	_gfgd := _ggcg[0]
	for _ecebgf, _bgbg := range _gbdf {
		_cafc += _bgbg / _dc.Pow(1+_cdce, (_ggcg[_ecebgf]-_gfgd)/365)
	}
	return MakeNumberResult(_cafc)
}

// Eval evaluates a horizontal range returning a list of results or an error.
func (_bgaf HorizontalRange) Eval(ctx Context, ev Evaluator) Result {
	_ggfa := _bgaf.horizontalRangeReference()
	if _bcaeb, _ccgc := ev.GetFromCache(_ggfa); _ccgc {
		return _bcaeb
	}
	_dbfaa, _aegba := _bdbbb(ctx, _bgaf._ddgg, _bgaf._aabf)
	_ebfdb := _efbfc(ctx, ev, _dbfaa, _aegba)
	ev.SetCache(_ggfa, _ebfdb)
	return _ebfdb
}

func _agbd(_begg, _becbe, _efacb Reference) string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _begg.Value, _becbe.Value, _efacb.Value)
}

func _ddbfg(_ecdbg, _fafbf Reference) string {
	return _c.Sprintf("\u0025\u0073\u003a%\u0073", _ecdbg.Value, _fafbf.Value)
}

func Unicode(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004fD\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fegd := args[0].AsString()
	if _fegd.Type != ResultTypeString {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004fD\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(_fegd.ValueString) == 0 {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004f\u0044\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 \u0061\u0020\u006e\u006f\u006e\u002d\u007a\u0065\u0072\u006f\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(float64(_fegd.ValueString[0]))
}

// PrefixVerticalRange is a range expression that when evaluated returns a list of Results from references like Sheet1!AA:IJ (all cells from columns AA to IJ of sheet 'Sheet1').
type PrefixVerticalRange struct {
	_edebe         Expression
	_bgcag, _gadad string
}

// Update updates references in the VerticalRange after removing a row/column.
func (_egdef VerticalRange) Update(q *_cc.UpdateQuery) Expression {
	if q.UpdateType == _cc.UpdateActionRemoveColumn {
		_fgeaf := _egdef
		if q.UpdateCurrentSheet {
			_gebac := q.ColumnIdx
			_fgeaf._efdad = _cee(_egdef._efdad, _gebac)
			_fgeaf._ddbe = _cee(_egdef._ddbe, _gebac)
		}
		return _fgeaf
	}
	return _egdef
}

// And is an implementation of the Excel AND() function.
func And(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0041\u004e\u0044 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061t\u0020l\u0065a\u0073t\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ddffd := true
	for _, _dgebe := range args {
		_dgebe = _dgebe.AsNumber()
		switch _dgebe.Type {
		case ResultTypeList, ResultTypeArray:
			_begc := And(_dgebe.ListValues())
			if _begc.Type == ResultTypeError {
				return _begc
			}
			if _begc.ValueNumber == 0 {
				_ddffd = false
			}
		case ResultTypeNumber:
			if _dgebe.ValueNumber == 0 {
				_ddffd = false
			}
		case ResultTypeString:
			return MakeErrorResult("\u0041\u004e\u0044\u0020\u0064\u006f\u0065\u0073\u006e\u0027t\u0020\u006f\u0070\u0065\u0072\u0061\u0074e\u0020\u006f\u006e\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0073")
		case ResultTypeError:
			return _dgebe
		default:
			return MakeErrorResult("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0061\u0072\u0067u\u006de\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0041\u004e\u0044")
		}
	}
	return MakeBoolResult(_ddffd)
}

// Tbillprice implements the Excel TBILLPRICE function.
func Tbillprice(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0050\u0052I\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_gaaf, _gffec, _bcgg := _dfd(args[0], args[1], "\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045")
	if _bcgg.Type == ResultTypeError {
		return _bcgg
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0064\u0069\u0073\u0063\u006f\u0075n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dgfda := _gffec - _gaaf
	if _dgfda > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004cP\u0052\u0049\u0043\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020t\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079e\u0061\u0072\u0020\u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_faga := args[2].ValueNumber
	if _faga <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020d\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeNumberResult(100 * (1 - _faga*_dgfda/360))
}

func init() {
	RegisterFunction("\u0043\u0048\u004f\u004f\u0053\u0045", Choose)
	RegisterFunction("\u0043\u004f\u004c\u0055\u004d\u004e", Column)
	RegisterFunction("\u0043O\u004c\u0055\u004d\u004e\u0053", Columns)
	RegisterFunction("\u0049\u004e\u0044E\u0058", Index)
	RegisterFunctionComplex("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054", Indirect)
	RegisterFunctionComplex("\u004f\u0046\u0046\u0053\u0045\u0054", Offset)
	RegisterFunction("\u004d\u0041\u0054C\u0048", Match)
	RegisterFunction("\u0048L\u004f\u004f\u004b\u0055\u0050", HLookup)
	RegisterFunction("\u004c\u0041\u0052G\u0045", Large)
	RegisterFunction("\u004c\u004f\u004f\u004b\u0055\u0050", Lookup)
	RegisterFunction("\u0052\u004f\u0057", Row)
	RegisterFunction("\u0052\u004f\u0057\u0053", Rows)
	RegisterFunction("\u0053\u004d\u0041L\u004c", Small)
	RegisterFunction("\u0056L\u004f\u004f\u004b\u0055\u0050", VLookup)
	RegisterFunction("\u0054R\u0041\u004e\u0053\u0050\u004f\u0053E", Transpose)
}

const _cdded = 57351

// Amorlinc implements the Excel AMORLINC function.
func Amorlinc(args []Result) Result {
	_gddg, _dgac := _aebc(args, "\u0041\u004d\u004f\u0052\u004c\u0049\u004e\u0043")
	if _dgac.Type == ResultTypeError {
		return _dgac
	}
	_cfdc := _gddg._gdbg
	_fcdg := _gddg._ccggc
	_cebc := _gddg._aeeb
	_fgd := _gddg._geca
	_dcd := _gddg._bdc
	_dffe := _gddg._fffc
	_beb := _gddg._ccdb
	_dbc, _ebbba := _fea(_fcdg, _cebc, _beb)
	if _ebbba.Type == ResultTypeError {
		return MakeErrorResult("\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0065\u0073 \u0066o\u0072\u0020\u0041\u004d\u004f\u0052\u004cI\u004e\u0043")
	}
	_cada := _dbc * _dffe * _cfdc
	if _dcd == 0 {
		return MakeNumberResult(_cada)
	}
	_cggf := _cfdc * _dffe
	_ebcd := _cfdc - _fgd
	_ceda := int((_ebcd - _cada) / _cggf)
	if _dcd <= _ceda {
		return MakeNumberResult(_cggf)
	} else if _dcd == _ceda+1 {
		return MakeNumberResult(_ebcd - _cggf*float64(_ceda) - _cada)
	} else {
		return MakeNumberResult(0)
	}
}

// Code is an implementation of the Excel CODE function that returns the first
// character of the string as a number.
func Code(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u004f\u0044\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cfec := args[0].AsString()
	if _cfec.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u004f\u0044\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if len(_cfec.ValueString) == 0 {
		return MakeNumberResult(0)
	}
	return MakeNumberResult(float64(_cfec.ValueString[0]))
}

func _dgedb(_gfcf []Result, _edfef bool) Result {
	_cafef := "\u004d\u0049\u004e"
	if _edfef {
		_cafef = "\u004d\u0049\u004e\u0041"
	}
	if len(_gfcf) == 0 {
		return MakeErrorResult(_cafef + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061s\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gfbdb := _dc.MaxFloat64
	for _, _gcbg := range _gfcf {
		switch _gcbg.Type {
		case ResultTypeNumber:
			if (_edfef || !_gcbg.IsBoolean) && _gcbg.ValueNumber < _gfbdb {
				_gfbdb = _gcbg.ValueNumber
			}
		case ResultTypeList, ResultTypeArray:
			_cbgc := _dgedb(_gcbg.ListValues(), _edfef)
			if _cbgc.ValueNumber < _gfbdb {
				_gfbdb = _cbgc.ValueNumber
			}
		case ResultTypeEmpty:
		case ResultTypeString:
			_edbc := 0.0
			if _edfef {
				_edbc = _gcbg.AsNumber().ValueNumber
			}
			if _edbc < _gfbdb {
				_gfbdb = _edbc
			}
		default:
			_ge.Log("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020"+_cafef+"\u0028\u0029\u0020\u0061rg\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _gcbg.Type)
		}
	}
	if _gfbdb == _dc.MaxFloat64 {
		_gfbdb = 0
	}
	return MakeNumberResult(_gfbdb)
}

// Rows implements the Excel ROWS function.
func Rows(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0052\u004f\u0057\u0053\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	_cdfa := args[0]
	if _cdfa.Type != ResultTypeArray && _cdfa.Type != ResultTypeList {
		return MakeErrorResult("\u0052\u004f\u0057S\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_cdafg := _cdfa.ValueArray
	if len(_cdafg) == 0 {
		return MakeErrorResult("\u0052O\u0057\u0053 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0072r\u0061\u0079\u0020\u0074\u006f\u0020c\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074\u0020\u006ce\u0061\u0073\u0074\u0020\u0031\u0020\u0072\u006f\u0077")
	}
	return MakeNumberResult(float64(len(_cdafg)))
}

// Ifs is an implementation of the Excel IFS() function.
func Ifs(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("I\u0046\u0053\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061t\u0020\u006c\u0065\u0061\u0073\u0074\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	for _ecaca := 0; _ecaca < len(args)-1; _ecaca += 2 {
		if args[_ecaca].ValueNumber == 1 {
			return args[_ecaca+1]
		}
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}

// Minute is an implementation of the Excel MINUTE() function.
func Minute(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0049\u004e\u0055T\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_ffb := args[0]
	switch _ffb.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(0)
	case ResultTypeNumber:
		_efd := _fae(_ffb.ValueNumber)
		return MakeNumberResult(float64(_efd.Minute()))
	case ResultTypeString:
		_acd := _ee.ToLower(_ffb.ValueString)
		if !_efab(_acd) {
			_, _, _, _feg, _caa := _dfb(_acd)
			if _caa.Type == ResultTypeError {
				_caa.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s\u0020\u0066\u006f\u0072\u0020\u004d\u0049\u004e\u0055\u0054\u0045"
				return _caa
			}
			if _feg {
				return MakeNumberResult(0)
			}
		}
		_, _ffdc, _, _, _, _gge := _ffge(_acd)
		if _gge.Type == ResultTypeError {
			return _gge
		}
		return MakeNumberResult(float64(_ffdc))
	default:
		return MakeErrorResult("\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u004d\u0049NU\u0054\u0045")
	}
}

func Parse(r _e.Reader) Expression {
	_ffdg := &plex{LexReader(r), nil}
	_ffedd(_ffdg)
	return _ffdg._deddc
}

// NewRange constructs a new range.
func NewRange(from, to Expression) Expression { return Range{from, to} }

// Pv implements the Excel PV function.
func Pv(args []Result) Result {
	_decca := len(args)
	if _decca < 3 || _decca > 5 {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u00205")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gada := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_dbdfe := args[1].ValueNumber
	if _dbdfe != float64(int(_dbdfe)) {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0061\u0079\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_acaf := args[2].ValueNumber
	_bcge := 0.0
	if _decca >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0056 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0075\u0074\u0075\u0072\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_bcge = args[3].ValueNumber
	}
	_gcbf := 0.0
	if _decca == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_gcbf = args[4].ValueNumber
		if _gcbf != 0 {
			_gcbf = 1
		}
	}
	if _gada == 0 {
		return MakeNumberResult(-_acaf*_dbdfe - _bcge)
	} else {
		return MakeNumberResult((((1-_dc.Pow(1+_gada, _dbdfe))/_gada)*_acaf*(1+_gada*_gcbf) - _bcge) / _dc.Pow(1+_gada, _dbdfe))
	}
}

const _fbg = 57375

func _aeac(_gcaf, _efbg int64) float64 { return float64(int(0.5 + float64((_efbg-_gcaf)/86400))) }

// Coupnum implements the Excel COUPNUM function.
func Coupnum(args []Result) Result {
	_ccec, _bdeb := _dccda(args, "\u0043O\u0055\u0050\u004e\u0055\u004d")
	if _bdeb.Type == ResultTypeError {
		return _bdeb
	}
	_ece := _ccec._ecf
	_gaac := _ccec._deagf
	_fca, _bdeb := _ggca(_ccec._ggbd, _ccec._eedd, _ece, _gaac)
	if _bdeb.Type == ResultTypeError {
		return _bdeb
	}
	return MakeNumberResult(_fca)
}

var _feaa = [...]string{}

// Number is a nubmer expression.
type Number struct{ _becb float64 }

// ErrorType is a formula evaluation error type.
type ErrorType byte

func (_fffcd *ivr) Cell(ref string, ev Evaluator) Result {
	return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065")
}

// Intrate implements the Excel INTRATE function.
func Intrate(args []Result) Result {
	_cedee := len(args)
	if _cedee != 4 && _cedee != 5 {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0066\u006f\u0075r\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_cffda, _ceba, _gdab := _dfd(args[0], args[1], "\u0049N\u0054\u0052\u0041\u0054\u0045")
	if _gdab.Type == ResultTypeError {
		return _gdab
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006e\u0076\u0065\u0073\u0074\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_dada := args[2].ValueNumber
	if _dada <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006e\u0076e\u0073\u0074\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_afcf := args[3].ValueNumber
	if _afcf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064e\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	_fcc := 0
	if _cedee == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0049N\u0054\u0052A\u0054\u0045\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
		}
		_fcc = int(args[4].ValueNumber)
		if !_cfee(_fcc) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006eco\u0072\u0072\u0065c\u0074\u0020\u0062\u0061sis\u0020ar\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020\u0049\u004e\u0054\u0052\u0041T\u0045")
		}
	}
	_ecgg, _gdab := _fea(_cffda, _ceba, _fcc)
	if _gdab.Type == ResultTypeError {
		return _gdab
	}
	return MakeNumberResult((_afcf - _dada) / _dada / _ecgg)
}

func _dfb(_gbef string) (int, int, int, bool, Result) {
	_abe := ""
	_bccd := []string{}
	for _dgf, _decc := range _fcd {
		_bccd = _decc.FindStringSubmatch(_gbef)
		if len(_bccd) > 1 {
			_abe = _dgf
			break
		}
	}
	if _abe == "" {
		return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
	}
	_bgd := false
	var _abea, _ede, _eaa int
	var _fgf error
	switch _abe {
	case "\u006d\u006d\u002f\u0064\u0064\u002f\u0079\u0079":
		_ede, _fgf = _ff.Atoi(_bccd[1])
		if _fgf != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_eaa, _fgf = _ff.Atoi(_bccd[3])
		if _fgf != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_abea, _fgf = _ff.Atoi(_bccd[5])
		if _fgf != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		if _abea < 0 || _abea > 9999 || (_abea > 99 && _abea < 1900) {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_abea = _eebc(_abea)
		_bgd = _bccd[8] == ""
	case "\u006dm\u0020\u0064\u0064\u002c\u0020\u0079y":
		_ede = _gcfg[_bccd[1]]
		_eaa, _fgf = _ff.Atoi(_bccd[14])
		if _fgf != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_abea, _fgf = _ff.Atoi(_bccd[16])
		if _fgf != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		if _abea < 0 || _abea > 9999 || (_abea > 99 && _abea < 1900) {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_abea = _eebc(_abea)
		_bgd = _bccd[19] == ""
	case "\u0079\u0079\u002d\u006d\u006d\u002d\u0064\u0064":
		_abf, _cbc := _ff.Atoi(_bccd[1])
		if _cbc != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_dcec, _cbc := _ff.Atoi(_bccd[3])
		if _cbc != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_gfab, _cbc := _ff.Atoi(_bccd[5])
		if _cbc != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		if _abf >= 1900 && _abf < 10000 {
			_abea = _abf
			_ede = _dcec
			_eaa = _gfab
		} else if _abf > 0 && _abf < 13 {
			_ede = _abf
			_eaa = _dcec
			_abea = _gfab
		} else {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_bgd = _bccd[8] == ""
	case "y\u0079\u002d\u006d\u006d\u0053\u0074\u0072\u002d\u0064\u0064":
		_abea, _fgf = _ff.Atoi(_bccd[16])
		if _fgf != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_ede = _gcfg[_bccd[3]]
		_eaa, _fgf = _ff.Atoi(_bccd[1])
		if _fgf != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
		}
		_bgd = _bccd[19] == ""
	}
	if !_aga(_abea, _ede, _eaa) {
		return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _dda)
	}
	return _abea, _ede, _eaa, _bgd, _ffe
}

var _efbb = [...]int{1}

const _fgbdf = 57365

func init() {
	_adcg()
	RegisterFunction("\u004e\u0041", NA)
	RegisterFunction("\u0049S\u0042\u004c\u0041\u004e\u004b", IsBlank)
	RegisterFunction("\u0049\u0053\u0045R\u0052", IsErr)
	RegisterFunction("\u0049S\u0045\u0052\u0052\u004f\u0052", IsError)
	RegisterFunction("\u0049\u0053\u0045\u0056\u0045\u004e", IsEven)
	RegisterFunctionComplex("\u005fx\u006cf\u006e\u002e\u0049\u0053\u0046\u004f\u0052\u004d\u0055\u004c\u0041", IsFormula)
	RegisterFunctionComplex("\u004fR\u0047\u002e\u004f\u0050E\u004e\u004f\u0046\u0046\u0049C\u0045.\u0049S\u004c\u0045\u0041\u0050\u0059\u0045\u0041R", IsLeapYear)
	RegisterFunctionComplex("\u0049S\u004c\u004f\u0047\u0049\u0043\u0041L", IsLogical)
	RegisterFunction("\u0049\u0053\u004e\u0041", IsNA)
	RegisterFunction("\u0049S\u004e\u004f\u004e\u0054\u0045\u0058T", IsNonText)
	RegisterFunction("\u0049\u0053\u004e\u0055\u004d\u0042\u0045\u0052", IsNumber)
	RegisterFunction("\u0049\u0053\u004fD\u0044", IsOdd)
	RegisterFunctionComplex("\u0049\u0053\u0052E\u0046", IsRef)
	RegisterFunction("\u0049\u0053\u0054\u0045\u0058\u0054", IsText)
	RegisterFunctionComplex("\u0043\u0045\u004c\u004c", Cell)
}

func Sign(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0053\u0049\u0047\u004e(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_ffac := args[0].AsNumber()
	if _ffac.Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0049\u0047N(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020a\u0020n\u0075m\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _ffac.ValueNumber < 0 {
		return MakeNumberResult(-1)
	} else if _ffac.ValueNumber > 0 {
		return MakeNumberResult(1)
	}
	return MakeNumberResult(0)
}

func _ffbf(_facb []string, _aecb int) string { return _ff.Itoa(len(_facb[len(_facb)-1-_aecb])) }

// MakeEmptyResult is ued when parsing an empty argument.
func MakeEmptyResult() Result { return Result{Type: ResultTypeEmpty} }

const _gggbg = 57372

// Clean is an implementation of the Excel CLEAN function that removes
// unprintable characters.
func Clean(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u004c\u0045\u0041\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fbfdf := args[0].AsString()
	if _fbfdf.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fega := _d.Buffer{}
	for _, _ebef := range _fbfdf.ValueString {
		if _gc.IsPrint(_ebef) {
			_fega.WriteRune(_ebef)
		}
	}
	return MakeStringResult(_fega.String())
}

// Round is an implementation of the Excel ROUND function that rounds a number
// to a specified number of digits.
func Round(args []Result) Result { return _ebcfc(args, _aabe) }

var _cfbd = map[string]*_gf.Regexp{}

// Function is a standard function whose result only depends on its arguments.
type Function func(_bdbcfd []Result) Result

// Received implements the Excel RECEIVED function.
func Received(args []Result) Result {
	_cebag := len(args)
	if _cebag != 4 && _cebag != 5 {
		return MakeErrorResult("R\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066o\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_dcbc, _beg, _gbga := _dfd(args[0], args[1], "\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044")
	if _gbga.Type == ResultTypeError {
		return _gbga
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020i\u006e\u0076\u0065\u0073\u0074\u006d\u0065n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bceg := args[2].ValueNumber
	if _bceg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006ev\u0065\u0073\u0074\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044 \u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0064\u0069s\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_dgfbf := args[3].ValueNumber
	if _dgfbf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0045\u0043\u0045I\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020p\u006f\u0073\u0069\u0074\u0069v\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ecebg := 0
	if _cebag == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052E\u0043\u0045I\u0056\u0045\u0044 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_ecebg = int(args[4].ValueNumber)
		if !_cfee(_ecebg) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0052\u0045\u0043E\u0049\u0056\u0045\u0044")
		}
	}
	_bcee, _gbga := _fea(_dcbc, _beg, _ecebg)
	if _gbga.Type == ResultTypeError {
		return _gbga
	}
	return MakeNumberResult(_bceg / (1 - _dgfbf*_bcee))
}

// ISNUMBER is an implementation of the Excel ISNUMBER() function.
func IsNumber(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053NU\u004d\u0042\u0045R\u0028\u0029\u0020\u0061cce\u0070ts\u0020\u0061\u0020\u0073\u0069\u006e\u0067le\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeNumber)
}

const _egebg = 57355

// NewBinaryExpr constructs a new binary expression with a given operator.
func NewBinaryExpr(lhs Expression, op BinOpType, rhs Expression) Expression {
	return BinaryExpr{lhs, rhs, op}
}

type plex struct {
	_cecgd chan *node
	_deddc Expression
}

//go:generate ragel -G2 -Z lexer.rl
//go:generate goimports -w lexer.go
type Lexer struct {
	_daeg  chan *node
	_cdba  _f.Mutex
	_fgcg  []chan *node
	_ecgad []*node
}

func _cee(_bc string, _ege uint32) string {
	_gfe := _cb.ColumnToIndex(_bc)
	if _gfe == _ege {
		return "\u0023\u0052\u0045F\u0021"
	} else if _gfe > _ege {
		return _cb.IndexToColumn(_gfe - 1)
	} else {
		return _bc
	}
}

// Multinomial implements the excel MULTINOMIAL function.
func Multinomial(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u004d\u0055\u004c\u0054\u0049\u004eO\u004d\u0049\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006ce\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c\u0020i\u006e\u0070\u0075\u0074")
	}
	_caaca, _dbebba, _gaagb := _eaedc(args)
	if _gaagb.Type == ResultTypeError {
		return _gaagb
	}
	return MakeNumberResult(_abgd(_caaca) / _dbebba)
}

const _dgbec int = 30

func _ebab(_bge, _daee int) int {
	switch _daee {
	case 1:
		if _dfa(_bge) {
			return 366
		} else {
			return 365
		}
	case 3:
		return 365
	default:
		return 360
	}
}

// Max is an implementation of the Excel MAX() function.
func Max(args []Result) Result { return _bacc(args, false) }

// MaxA is an implementation of the Excel MAXA() function.
func MaxA(args []Result) Result { return _bacc(args, true) }

func _aebg(_gdcf Result, _ddgea *criteriaParsed) bool {
	if _gdcf.Type == ResultTypeEmpty {
		return false
	}
	if _ddgea._eaebd {
		return _gdcf.ValueNumber == _ddgea._cbga
	} else {
		_aacb := _ee.ToLower(_gdcf.ValueString)
		return _ddgea._ebaec == _aacb || _ag.Match(_ddgea._ebaec, _aacb)
	}
}

func init() {
	RegisterFunction("\u0041\u004e\u0044", And)
	RegisterFunction("\u0046\u0041\u004cS\u0045", False)
	RegisterFunction("\u0049\u0046", If)
	RegisterFunction("\u0049F\u0045\u0052\u0052\u004f\u0052", IfError)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0049\u0046\u004e\u0041", IfNA)
	RegisterFunction("\u0049\u0046\u0053", Ifs)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0049\u0046S", Ifs)
	RegisterFunction("\u004e\u004f\u0054", Not)
	RegisterFunction("\u004f\u0052", Or)
	RegisterFunction("\u0054\u0052\u0055\u0045", True)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0058\u004fR", Xor)
}

// LookupFunction looks up and returns a standard function or nil.
func LookupFunction(name string) Function {
	_fafbc.Lock()
	defer _fafbc.Unlock()
	if _cfdba, _febb := _baad[name]; _febb {
		return _cfdba
	}
	return nil
}

func _cgfc(_gfed, _gegd, _cbf, _bgdd, _egdd float64, _cbbdd int) float64 {
	_bgdgf := _faf(_gfed, _cbf, _bgdd, _egdd, _cbbdd)
	var _aaebg float64
	if _gegd == 1 {
		if _cbbdd == 1 {
			_aaebg = 0
		} else {
			_aaebg = -_bgdd
		}
	} else {
		if _cbbdd == 1 {
			_aaebg = _cfgg(_gfed, _gegd-2, _bgdgf, _bgdd, 1) - _bgdgf
		} else {
			_aaebg = _cfgg(_gfed, _gegd-1, _bgdgf, _bgdd, 0)
		}
	}
	return _aaebg * _gfed
}

type parsedSearchObject struct {
	_dede   string
	_affa   string
	_caacac int
}

var _cgfd, _bfebg, _ebe, _gefgf, _caeed, _dcfcfc, _cgec, _ffef, _decb, _ffee, _ecbd, _gfcaf, _acec, _bdbf, _aegf *_gf.Regexp

func (_baba *noCache) SetCache(key string, value Result) {}

// Lower is an implementation of the Excel LOWER function that returns a lower
// case version of a string.
func Lower(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004c\u004f\u0057\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gbfb := args[0]
	switch _gbfb.Type {
	case ResultTypeError:
		return _gbfb
	case ResultTypeNumber, ResultTypeString:
		return _cbeg(args[0])
	case ResultTypeList:
		_gcfbe := _gbfb.ValueList
		_gfac := []Result{}
		for _, _dfba := range _gcfbe {
			_daeed := _cbeg(_dfba)
			if _daeed.Type == ResultTypeError {
				return _daeed
			}
			_gfac = append(_gfac, _daeed)
		}
		return MakeListResult(_gfac)
	case ResultTypeArray:
		_ggee := _gbfb.ValueArray
		_edeee := [][]Result{}
		for _, _ccbd := range _ggee {
			_abcccc := []Result{}
			for _, _eggca := range _ccbd {
				_ddbg := _cbeg(_eggca)
				if _ddbg.Type == ResultTypeError {
					return _ddbg
				}
				_abcccc = append(_abcccc, _ddbg)
			}
			_edeee = append(_edeee, _abcccc)
		}
		return MakeArrayResult(_edeee)
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004c\u004fW\u0045\u0052")
	}
}

const _dfedd = 57374

// Cell is an implementation of the Excel CELL function that returns information
// about the formatting, location, or contents of a cell.
func Cell(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 && len(args) != 2 {
		return MakeErrorResult("\u0043\u0045\u004cL \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_ebfg := args[0].AsString()
	if _ebfg.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u0045\u004c\u004c\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065 \u0073t\u0072\u0069\u006e\u0067")
	}
	_cdbeb := args[1].Ref
	if _cdbeb.Type != ReferenceTypeCell {
		return MakeErrorResult("\u0043\u0045\u004c\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064 \u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
	}
	_degf := _cdbeb.Value
	switch _ebfg.ValueString {
	case "\u0061d\u0064\u0072\u0065\u0073\u0073":
		_bffg, _bdbfe := _cb.ParseCellReference(_degf)
		if _bdbfe != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _degf)
		}
		_dbgcf := "\u0024" + _bffg.Column + "\u0024" + _ff.Itoa(int(_bffg.RowIdx))
		if _bffg.SheetName != "" {
			_dbgcf = _bffg.SheetName + "\u0021" + _dbgcf
		}
		return MakeStringResult(_dbgcf)
	case "\u0063\u006f\u006c":
		_dccabg, _egdf := _cb.ParseCellReference(_degf)
		if _egdf != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _degf)
		}
		return MakeNumberResult(float64(_dccabg.ColumnIdx + 1))
	case "\u0063\u006f\u006co\u0072":
		_dccde := _ee.Contains(ctx.GetFormat(_degf), "\u005b\u0052\u0045D\u005d")
		return MakeBoolResult(_dccde)
	case "\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0073":
		return args[1]
	case "\u0066\u0069\u006c\u0065\u006e\u0061\u006d\u0065":
		return MakeStringResult(ctx.GetFilename())
	case "\u0066\u006f\u0072\u006d\u0061\u0074":
		_gcee := "\u0047"
		_cgff := ctx.GetFormat(_degf)
		if _cgff == "\u0047e\u006e\u0065\u0072\u0061\u006c" || _cgfd.MatchString(_cgff) {
			_gcee = "\u0046\u0030"
		} else if _cgff == "\u0030\u0025" {
			_gcee = "\u0050\u0030"
		} else if _cgff == "\u004d\u004d\u004d\u0020\u0044\u0044" {
			_gcee = "\u0044\u0032"
		} else if _cgff == "\u004d\u004d\u002fY\u0059" {
			_gcee = "\u0044\u0033"
		} else if _cgff == "\u004d\u004d\u002f\u0044D/\u0059\u0059\u005c\u0020\u0048\u0048\u003a\u004d\u004d\u005c\u0020\u0041\u004d\u002fP\u004d" || _cgff == "M\u004d/\u0044\u0044\u002f\u0059\u0059\u0059\u0059\u005c \u0048\u0048\u003a\u004dM:\u0053\u0053" {
			_gcee = "\u0044\u0034"
		} else if _cgff == "\u004d\u004d\u005c\u002d\u0044\u0044" {
			_gcee = "\u0044\u0035"
		} else if _cgff == "\u0048H\u003aM\u004d\u003a\u0053\u0053\u005c\u0020\u0041\u004d\u002f\u0050\u004d" {
			_gcee = "\u0044\u0036"
		} else if _cgff == "\u0048\u0048\u003aM\u004d\u005c\u0020\u0041\u004d\u002f\u0050\u004d" {
			_gcee = "\u0044\u0037"
		} else if _cgff == "\u0048\u0048\u003a\u004d\u004d\u003a\u0053\u0053" {
			_gcee = "\u0044\u0038"
		} else if _cgff == "\u0048\u0048\u003aM\u004d" {
			_gcee = "\u0044\u0039"
		} else if _ebe.MatchString(_cgff) {
			_gcee = "\u002e\u0030"
		} else if _gefgf.MatchString(_cgff) {
			_gcee = "\u002e\u0030\u0028\u0029"
		} else if _ffee.MatchString(_cgff) {
			_gcee = "\u0043\u0030"
		} else if _acec.MatchString(_cgff) || _bdbf.MatchString(_cgff) {
			_gcee = "\u0044\u0031"
		} else if _cfgdd := _bfebg.FindStringSubmatch(_cgff); len(_cfgdd) > 1 {
			_gcee = "\u0046" + _ff.Itoa(len(_cfgdd[1]))
		} else if _gdfbe := _dcfcfc.FindStringSubmatch(_cgff); len(_gdfbe) > 1 {
			_gcee = "\u002e" + _ff.Itoa(len(_gdfbe[2]))
		} else if _bdca := _decb.FindStringSubmatch(_cgff); len(_bdca) > 1 {
			_gcee = "\u0050" + _ff.Itoa(len(_bdca[2]))
		} else if _ggda := _ecbd.FindStringSubmatch(_cgff); len(_ggda) > 1 {
			_gcee = "\u0043" + _ffbf(_ggda, 1)
		} else if _cdec := _gfcaf.FindStringSubmatch(_cgff); len(_cdec) > 1 {
			_gcee = "\u0043" + _ffbf(_cdec, 1)
		} else if _eade := _cgec.FindStringSubmatch(_cgff); len(_eade) > 1 {
			_gcee = "\u002e" + _ffbf(_eade, 1) + "\u0028\u0029"
		} else if _dacdg := _caeed.FindStringSubmatch(_cgff); len(_dacdg) > 1 {
			_gcee = "\u002e" + _ffbf(_dacdg, 1)
		} else if _adbe := _aegf.FindStringSubmatch(_cgff); len(_adbe) > 1 {
			_gcee = "\u0053" + _ffbf(_adbe, 3)
		}
		if _gcee != "\u0047" && _ee.Contains(_cgff, "\u005b\u0052\u0045D\u005d") {
			_gcee += "\u002d"
		}
		return MakeStringResult(_gcee)
	case "p\u0061\u0072\u0065\u006e\u0074\u0068\u0065\u0073\u0065\u0073":
		_gaef := ctx.GetFormat(_degf)
		if _ffef.MatchString(_gaef) {
			return MakeNumberResult(1)
		} else {
			return MakeNumberResult(0)
		}
	case "\u0070\u0072\u0065\u0066\u0069\u0078":
		return MakeStringResult(ctx.GetLabelPrefix(_degf))
	case "\u0070r\u006f\u0074\u0065\u0063\u0074":
		_dcceg := 0.0
		if ctx.GetLocked(_degf) {
			_dcceg = 1.0
		}
		return MakeNumberResult(_dcceg)
	case "\u0072\u006f\u0077":
		_eeecd, _abgaa := _cb.ParseCellReference(_degf)
		if _abgaa != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _degf)
		}
		return MakeNumberResult(float64(_eeecd.RowIdx))
	case "\u0074\u0079\u0070\u0065":
		switch args[1].Type {
		case ResultTypeEmpty:
			return MakeStringResult("\u0062")
		case ResultTypeString:
			return MakeStringResult("\u006c")
		default:
			return MakeStringResult("\u0076")
		}
	case "\u0077\u0069\u0064t\u0068":
		_decba, _cbbdb := _cb.ParseCellReference(_degf)
		if _cbbdb != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _degf)
		}
		if _decba.SheetName == "" {
			return MakeNumberResult(ctx.GetWidth(int(_decba.ColumnIdx)))
		} else {
			return MakeNumberResult(ctx.Sheet(_decba.SheetName).GetWidth(int(_decba.ColumnIdx)))
		}
	}
	return MakeErrorResult("\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072g\u0075m\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0043\u0045\u004c\u004c\u003a\u0020" + _ebfg.ValueString)
}

// FunctionComplex is a function whose result  depends on its arguments and the
// context that it's in.  As an example, INDIRECT is a complex function so that
// INDIRECT("A1") which returns the value of the "A1" cell in a sheet can use
// the context to reach into the sheet and pull out required values.
type FunctionComplex func(_becfc Context, _edbebd Evaluator, _efae []Result) Result

// Mround is an implementation of the Excel MROUND function.  It is not a
// generic rounding function and has some oddities to match Excel's behavior.
func Mround(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004d\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0077o\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_cccb := args[0].AsNumber()
	if _cccb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006de\u006e\u0074\u0020\u0074o\u0020\u004d\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_bgege := float64(1)
	_gcaag := args[1].AsNumber()
	if _gcaag.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073e\u0063\u006fn\u0064\u0020\u0061\u0072g\u0075\u006d\u0065n\u0074\u0020\u0074\u006f\u0020\u004d\u0052\u004f\u0055ND\u0028\u0029\u0020m\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006db\u0065\u0072")
	}
	_bgege = _gcaag.ValueNumber
	if _bgege < 0 && _cccb.ValueNumber > 0 || _bgege > 0 && _cccb.ValueNumber < 0 {
		return MakeErrorResult("\u004d\u0052\u004fUN\u0044\u0028\u0029\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020s\u0069g\u006e\u0073\u0020\u006d\u0075\u0073\u0074\u0020\u006d\u0061\u0074\u0063\u0068")
	}
	_feedd := _cccb.ValueNumber
	_feedd, _ebfd := _dc.Modf(_feedd / _bgege)
	if _dc.Trunc(_ebfd+0.5) > 0 {
		_feedd++
	}
	return MakeNumberResult(_feedd * _bgege)
}

// Range is a range expression that when evaluated returns a list of Results.
type Range struct{ _eadcf, _dfbgf Expression }

func _dceg(_bddae Result) bool {
	_gecg := _bddae.Type
	return _gecg != ResultTypeArray && _gecg != ResultTypeList
}

// Ceiling is an implementation of the CEILING function which
// returns the ceiling of a number.
func Ceiling(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("C\u0045\u0049\u004c\u0049\u004e\u0047\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020a\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006ee \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u0028\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_dgegc := args[0].AsNumber()
	if _dgegc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066i\u0072\u0073t\u0020\u0061\u0072\u0067u\u006d\u0065\u006et\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049NG\u0028\u0029\u0020m\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006db\u0065\u0072")
	}
	_bafe := float64(1)
	if _dgegc.ValueNumber < 0 {
		_bafe = -1
	}
	if len(args) > 1 {
		_cfaa := args[1].AsNumber()
		if _cfaa.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073e\u0063\u006fn\u0064\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020t\u006f\u0020\u0043\u0045\u0049\u004cI\u004e\u0047\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062e\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_bafe = _cfaa.ValueNumber
	}
	if _bafe < 0 && _dgegc.ValueNumber > 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u006e\u0065\u0067\u0061\u0074\u0069v\u0065\u0020\u0073\u0069\u0067\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004cI\u004e\u0047\u0028\u0029\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if len(args) == 1 {
		return MakeNumberResult(_dc.Ceil(_dgegc.ValueNumber))
	}
	_dgffa := _dgegc.ValueNumber
	_dgffa, _edcc := _dc.Modf(_dgffa / _bafe)
	if _edcc > 0 {
		_dgffa++
	}
	return MakeNumberResult(_dgffa * _bafe)
}

// Ispmt implements the Excel ISPMT function.
func Ispmt(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("\u0049\u0053P\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eecf := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0070e\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aeae := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069o\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bbaae := args[2].ValueNumber
	if _bbaae <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049S\u0050\u004d\u0054\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072i\u006f\u0064\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062er\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065s\u0065\u006e\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dgdd := args[3].ValueNumber
	return MakeNumberResult(_dgdd * _eecf * (_aeae/_bbaae - 1))
}

// IfNA is an implementation of the Excel IFNA() function. It takes two arguments.
func IfNA(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("I\u0046\u004e\u0041\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeError && args[0].ValueString == "\u0023\u004e\u002f\u0041" {
		return args[1]
	}
	return args[0]
}

// Eval evaluates and returns a boolean.
func (_fd Bool) Eval(ctx Context, ev Evaluator) Result { return MakeBoolResult(_fd._gfbd) }

func init() {
	_cdcb = _gb.New(_gb.NewSource(_ce.Now().UnixNano()))
	RegisterFunction("\u0041\u0042\u0053", _ceggf("\u0041\u0053\u0049\u004e", _dc.Abs))
	RegisterFunction("\u0041\u0043\u004f\u0053", _ceggf("\u0041\u0053\u0049\u004e", _dc.Acos))
	RegisterFunction("\u0041\u0043\u004fS\u0048", _ceggf("\u0041\u0053\u0049\u004e", _dc.Acosh))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0041\u0043\u004f\u0054", _ceggf("\u0041\u0043\u004f\u0054", func(_dgeg float64) float64 { return _dc.Pi/2 - _dc.Atan(_dgeg) }))
	RegisterFunction("_\u0078\u006c\u0066\u006e\u002e\u0041\u0043\u004f\u0054\u0048", _ceggf("\u0041\u0043\u004fT\u0048", func(_cdffe float64) float64 { return _dc.Atanh(1 / _cdffe) }))
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u0041\u0052\u0041\u0042\u0049\u0043", Arabic)
	RegisterFunction("\u0041\u0053\u0049\u004e", _ceggf("\u0041\u0053\u0049\u004e", _dc.Asin))
	RegisterFunction("\u0041\u0053\u0049N\u0048", _ceggf("\u0041\u0053\u0049N\u0048", _dc.Asinh))
	RegisterFunction("\u0041\u0054\u0041\u004e", _ceggf("\u0041\u0054\u0041\u004e", _dc.Atan))
	RegisterFunction("\u0041\u0054\u0041N\u0048", _ceggf("\u0041\u0054\u0041N\u0048", _dc.Atanh))
	RegisterFunction("\u0041\u0054\u0041N\u0032", Atan2)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0042\u0041\u0053\u0045", Base)
	RegisterFunction("\u0043E\u0049\u004c\u0049\u004e\u0047", Ceiling)
	RegisterFunction("\u005fx\u006cf\u006e\u002e\u0043\u0045\u0049L\u0049\u004eG\u002e\u004d\u0041\u0054\u0048", CeilingMath)
	RegisterFunction("_\u0078\u006c\u0066\u006e.C\u0045I\u004c\u0049\u004e\u0047\u002eP\u0052\u0045\u0043\u0049\u0053\u0045", CeilingPrecise)
	RegisterFunction("\u0043\u004f\u004d\u0042\u0049\u004e", Combin)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u004f\u004d\u0042\u0049\u004e\u0041", Combina)
	RegisterFunction("\u0043\u004f\u0053", _ceggf("\u0043\u004f\u0053", _dc.Cos))
	RegisterFunction("\u0043\u004f\u0053\u0048", _ceggf("\u0043\u004f\u0053\u0048", _dc.Cosh))
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0043\u004fT", _cefc("\u0043\u004f\u0054", _dc.Tan))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u004f\u0054\u0048", _cefc("\u0043\u004f\u0054\u0048", _dc.Tanh))
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0043\u0053C", _cefc("\u0043\u0053\u0043", _dc.Sin))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u0053\u0043\u0048", _cefc("\u0043\u0053\u0043", _dc.Sinh))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0044\u0045\u0043\u0049\u004d\u0041\u004c", Decimal)
	RegisterFunction("\u0044E\u0047\u0052\u0045\u0045\u0053", Degrees)
	RegisterFunction("\u0045\u0056\u0045\u004e", Even)
	RegisterFunction("\u0045\u0058\u0050", _ceggf("\u0045\u0058\u0050", _dc.Exp))
	RegisterFunction("\u0046\u0041\u0043\u0054", Fact)
	RegisterFunction("\u0046\u0041\u0043\u0054\u0044\u004f\u0055\u0042\u004c\u0045", FactDouble)
	RegisterFunction("\u0046\u004c\u004fO\u0052", Floor)
	RegisterFunction("\u005f\u0078l\u0066\u006e\u002eF\u004c\u004f\u004f\u0052\u002e\u004d\u0041\u0054\u0048", FloorMath)
	RegisterFunction("\u005f\u0078\u006c\u0066n.\u0046\u004c\u004f\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045", FloorPrecise)
	RegisterFunction("\u0047\u0043\u0044", GCD)
	RegisterFunction("\u0049\u004e\u0054", Int)
	RegisterFunction("I\u0053\u004f\u002e\u0043\u0045\u0049\u004c\u0049\u004e\u0047", CeilingPrecise)
	RegisterFunction("\u004c\u0043\u004d", LCM)
	RegisterFunction("\u004c\u004e", _ceggf("\u004c\u004e", _dc.Log))
	RegisterFunction("\u004c\u004f\u0047", Log)
	RegisterFunction("\u004c\u004f\u00471\u0030", _ceggf("\u004c\u004f\u00471\u0030", _dc.Log10))
	RegisterFunction("\u004dD\u0045\u0054\u0045\u0052\u004d", MDeterm)
	RegisterFunction("\u004d\u004f\u0044", Mod)
	RegisterFunction("\u004d\u0052\u004f\u0055\u004e\u0044", Mround)
	RegisterFunction("M\u0055\u004c\u0054\u0049\u004e\u004f\u004d\u0049\u0041\u004c", Multinomial)
	RegisterFunction("_\u0078\u006c\u0066\u006e\u002e\u004d\u0055\u004e\u0049\u0054", Munit)
	RegisterFunction("\u004f\u0044\u0044", Odd)
	RegisterFunction("\u0050\u0049", Pi)
	RegisterFunction("\u0050\u004f\u0057E\u0052", Power)
	RegisterFunction("\u0050R\u004f\u0044\u0055\u0043\u0054", Product)
	RegisterFunction("\u0051\u0055\u004f\u0054\u0049\u0045\u004e\u0054", Quotient)
	RegisterFunction("\u0052A\u0044\u0049\u0041\u004e\u0053", Radians)
	RegisterFunction("\u0052\u0041\u004e\u0044", Rand)
	RegisterFunction("R\u0041\u004e\u0044\u0042\u0045\u0054\u0057\u0045\u0045\u004e", RandBetween)
	RegisterFunction("\u0052\u004f\u004dA\u004e", Roman)
	RegisterFunction("\u0052\u004f\u0055N\u0044", Round)
	RegisterFunction("\u0052O\u0055\u004e\u0044\u0044\u004f\u0057N", RoundDown)
	RegisterFunction("\u0052O\u0055\u004e\u0044\u0055\u0050", RoundUp)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0053\u0045C", _cefc("\u0053\u0045\u0043", _dc.Cos))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0053\u0045\u0043\u0048", _cefc("\u0053\u0045\u0043\u0048", _dc.Cosh))
	RegisterFunction("\u0053E\u0052\u0049\u0045\u0053\u0053\u0055M", SeriesSum)
	RegisterFunction("\u0053\u0049\u0047\u004e", Sign)
	RegisterFunction("\u0053\u0049\u004e", _ceggf("\u0053\u0049\u004e", _dc.Sin))
	RegisterFunction("\u0053\u0049\u004e\u0048", _ceggf("\u0053\u0049\u004e\u0048", _dc.Sinh))
	RegisterFunction("\u0053\u0051\u0052\u0054", _ceggf("\u0053\u0051\u0052\u0054", _dc.Sqrt))
	RegisterFunction("\u0053\u0051\u0052\u0054\u0050\u0049", _ceggf("\u0053\u0051\u0052\u0054\u0050\u0049", func(_fafc float64) float64 { return _dc.Sqrt(_fafc * _dc.Pi) }))
	RegisterFunction("\u0053\u0055\u004d", Sum)
	RegisterFunction("\u0053\u0055\u004dI\u0046", SumIf)
	RegisterFunction("\u0053\u0055\u004d\u0049\u0046\u0053", SumIfs)
	RegisterFunction("\u0053\u0055\u004d\u0050\u0052\u004f\u0044\u0055\u0043\u0054", SumProduct)
	RegisterFunction("\u0053\u0055\u004dS\u0051", SumSquares)
	RegisterFunction("\u0054\u0041\u004e", _ceggf("\u0054\u0041\u004e", _dc.Tan))
	RegisterFunction("\u0054\u0041\u004e\u0048", _ceggf("\u0054\u0041\u004e\u0048", _dc.Tanh))
	RegisterFunction("\u0054\u0052\u0055N\u0043", Trunc)
}

func _faf(_fbfd, _feab, _afa, _acee float64, _cage int) float64 {
	var _gafa float64
	if _fbfd == 0 {
		_gafa = (_afa + _acee) / _feab
	} else {
		_aaea := _dc.Pow(1+_fbfd, _feab)
		if _cage == 1 {
			_gafa = (_acee*_fbfd/(_aaea-1) + _afa*_fbfd/(1-1/_aaea)) / (1 + _fbfd)
		} else {
			_gafa = _acee*_fbfd/(_aaea-1) + _afa*_fbfd/(1-1/_aaea)
		}
	}
	return -_gafa
}

// String returns a string representation for Negate.
func (_edfdc Negate) String() string { return "\u002d" + _edfdc._ggbdc.String() }

// String returns a string representation of a vertical range with prefix.
func (_fece PrefixVerticalRange) String() string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _fece._edebe.String(), _fece._bgcag, _fece._gadad)
}

func _dacd(_fcggd, _ggcdb []float64, _bace float64) Result {
	_dbfdd := false
	_fecg := false
	for _fcde := 0; _fcde < len(_fcggd); _fcde++ {
		if _fcggd[_fcde] > 0 {
			_dbfdd = true
		}
		if _fcggd[_fcde] < 0 {
			_fecg = true
		}
	}
	if !_dbfdd || !_fecg {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	_ffga := _bace
	_eebe := 1e-10
	_ggcff := 0
	_baab := 50
	_daeec := false
	for {
		_cegg := _ggg(_fcggd, _ggcdb, _ffga)
		_fag := _ffga - _cegg/_bbfbe(_fcggd, _ggcdb, _ffga)
		_cafg := _dc.Abs(_fag - _ffga)
		_ffga = _fag
		_ggcff++
		if _cafg <= _eebe || _dc.Abs(_cegg) <= _eebe {
			break
		}
		if _ggcff > _baab {
			_daeec = true
			break
		}
	}
	if _daeec || _dc.IsNaN(_ffga) || _dc.IsInf(_ffga, 0) {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	return MakeNumberResult(_ffga)
}

// NA is an implementation of the Excel NA() function that just returns the #N/A! error.
func NA(args []Result) Result {
	if len(args) != 0 {
		MakeErrorResult("\u004eA\u0028\u0029\u0020\u0061c\u0063\u0065\u0070\u0074\u0073 \u006eo\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s")
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}

// Ipmt implements the Excel IPMT function.
func Ipmt(args []Result) Result {
	_bfade := len(args)
	if _bfade < 4 || _bfade > 6 {
		return MakeErrorResult("\u0049P\u004d\u0054\u0020\u0072\u0065\u0071\u0075ir\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074s\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0062\u0065\u0074\u0077\u0065\u0065n\u0020\u0066ou\u0072\u0020\u0061n\u0064\u0020\u0073\u0069\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("I\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_fabb := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004dT\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ecgff := args[1].ValueNumber
	if _ecgff <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0050\u004d\u0054\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_adg := args[2].ValueNumber
	if _adg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062er\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_ggad := args[3].ValueNumber
	_efece := 0.0
	if _bfade > 4 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_efece = args[4].ValueNumber
	}
	_abccc := 0
	if _bfade == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("I\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_abccc = int(args[5].ValueNumber)
		if _abccc != 0 {
			_abccc = 1
		}
	}
	return MakeNumberResult(_cgfc(_fabb, _ecgff, _adg, _ggad, _efece, _abccc))
}

// Char is an implementation of the Excel CHAR function that takes an integer in
// the range [0,255] and returns the corresponding ASCII character.
func Char(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gcbgg := args[0].AsNumber()
	if _gcbgg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ecda := int(_gcbgg.ValueNumber)
	if _ecda < 0 || _ecda > 255 {
		return MakeErrorResult("\u0043H\u0041\u0052 \u0072\u0065\u0071\u0075i\u0072\u0065\u0073 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073 i\u006e\u0020\u0074h\u0065\u0020r\u0061\u006e\u0067\u0065\u0020\u005b0\u002c\u00325\u0035\u005d")
	}
	return MakeStringResult(_c.Sprintf("\u0025\u0063", _ecda))
}

// Eval evaluates a vertical range with prefix returning a list of results or an error.
func (_egdac PrefixVerticalRange) Eval(ctx Context, ev Evaluator) Result {
	_cbdc := _egdac._edebe.Reference(ctx, ev)
	switch _cbdc.Type {
	case ReferenceTypeSheet:
		_fegaf := _egdac.verticalRangeReference(_cbdc.Value)
		if _eafg, _efbcc := ev.GetFromCache(_fegaf); _efbcc {
			return _eafg
		}
		_ccfcg := ctx.Sheet(_cbdc.Value)
		_afccfe, _gabbd := _gfbef(_ccfcg, _egdac._bgcag, _egdac._gadad)
		_cccba := _efbfc(_ccfcg, ev, _afccfe, _gabbd)
		ev.SetCache(_fegaf, _cccba)
		return _cccba
	default:
		return MakeErrorResult(_c.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _cbdc.Type))
	}
}

var _cdaef = [...]uint8{0, 20, 37, 60, 78, 96}

func _gcad(_caab int, _afc _ce.Month, _ggcd int) int64 {
	if _caab == 1900 && int(_afc) <= 2 {
		_ggcd--
	}
	_ccdc := _ce.Date(_caab, _afc, _ggcd, 0, 0, 0, 0, _ce.UTC)
	return _ccdc.Unix()
}

var _caeg = []ri{{1000, "\u004d"}, {995, "\u0056\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {495, "\u0056\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

func _abgaf(_ebfb string) *criteriaRegex {
	_fagf := &criteriaRegex{}
	if _ebfb == "" {
		return _fagf
	}
	if _feff := _fcaa.FindStringSubmatch(_ebfb); len(_feff) > 1 {
		_fagf._fbffg = _cgef
		_fagf._fffea = _feff[1]
	} else if _babba := _ceae.FindStringSubmatch(_ebfb); len(_babba) > 1 {
		_fagf._fbffg = _cgef
		_fagf._fffea = _babba[1]
	} else if _gdge := _ecaee.FindStringSubmatch(_ebfb); len(_gdge) > 1 {
		_fagf._fbffg = _cabdg
		_fagf._fffea = _gdge[1]
	} else if _bccdc := _gfee.FindStringSubmatch(_ebfb); len(_bccdc) > 1 {
		_fagf._fbffg = _adcef
		_fagf._fffea = _bccdc[1]
	} else if _ffgdd := _bacdb.FindStringSubmatch(_ebfb); len(_ffgdd) > 1 {
		_fagf._fbffg = _cfab
		_fagf._fffea = _ffgdd[1]
	} else if _gggc := _eacg.FindStringSubmatch(_ebfb); len(_gggc) > 1 {
		_fagf._fbffg = _baegf
		_fagf._fffea = _gggc[1]
	}
	return _fagf
}

const _faggb = 57363

// GetLabelPrefix returns an empty string for the invalid reference context.
func (_gfae *ivr) GetLabelPrefix(cellRef string) string { return "" }

// Roman is an implementation of the Excel ROMAN function that convers numbers
// to roman numerals in one of 5 formats.
func Roman(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_gcab := args[0].AsNumber()
	if _gcab.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bbfgb := 0
	if len(args) > 1 {
		_gdabeb := args[1]
		if _gdabeb.Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063")
		}
		_bbfgb = int(_gdabeb.ValueNumber)
		if _bbfgb < 0 {
			_bbfgb = 0
		} else if _bbfgb > 4 {
			_bbfgb = 4
		}
	}
	_feba := _cfgeg
	switch _bbfgb {
	case 1:
		_feba = _egda
	case 2:
		_feba = _adfca
	case 3:
		_feba = _caeg
	case 4:
		_feba = _cccg
	}
	_cgbdf := _dc.Trunc(_gcab.ValueNumber)
	_gadag := _d.Buffer{}
	for _, _afdf := range _feba {
		for _cgbdf >= _afdf._bdgf {
			_gadag.WriteString(_afdf._eagead)
			_cgbdf -= _afdf._bdgf
		}
	}
	return MakeStringResult(_gadag.String())
}

var _cddd []byte = []byte{0, 1, 2, 1, 11, 1, 12, 1, 13, 1, 14, 1, 15, 1, 16, 1, 17, 1, 18, 1, 19, 1, 20, 1, 21, 1, 22, 1, 23, 1, 24, 1, 25, 1, 26, 1, 27, 1, 28, 1, 29, 1, 30, 1, 31, 1, 32, 1, 33, 1, 34, 1, 35, 1, 36, 1, 37, 1, 38, 1, 39, 1, 40, 1, 41, 1, 42, 1, 43, 2, 0, 1, 2, 3, 4, 2, 3, 5, 2, 3, 6, 2, 3, 7, 2, 3, 8, 2, 3, 9, 2, 3, 10}

const _cfe = "\u0028\u0028\u005b\u0030\u002d\u0039]\u0029\u002b\u0029:\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b(\\\u002e\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u003f\u0029\u0028\u0020\u0028\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"

// ISTEXT is an implementation of the Excel ISTEXT() function.
func IsText(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u0054EX\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070t\u0073 \u0061 \u0073i\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeString)
}

// LastColumn returns empty string for the invalid reference context.
func (_aebge *ivr) LastColumn(rowFrom, rowTo int) string { return "" }

// Rand is an implementation of the Excel RAND() function that returns random
// numbers in the range [0,1).
func Rand(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("R\u0041\u004e\u0044\u0028\u0029\u0020a\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006e\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	return MakeNumberResult(_cdcb.Float64())
}

var _cccg = []ri{{1000, "\u004d"}, {999, "\u0049\u004d"}, {995, "\u0056\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {499, "\u0049\u0044"}, {495, "\u0056\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

// SumSquares is an implementation of the Excel SUMSQ() function.
func SumSquares(args []Result) Result {
	_bfac := MakeNumberResult(0)
	for _, _dcba := range args {
		_dcba = _dcba.AsNumber()
		switch _dcba.Type {
		case ResultTypeNumber:
			_bfac.ValueNumber += _dcba.ValueNumber * _dcba.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_aade := SumSquares(_dcba.ListValues())
			if _aade.Type != ResultTypeNumber {
				return _aade
			}
			_bfac.ValueNumber += _aade.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _dcba
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0053\u0055\u004dS\u0051\u0055\u0041\u0052\u0045\u0053(\u0029\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0073", _dcba.Type))
		}
	}
	return _bfac
}

type parsedReplaceObject struct {
	_ddcce string
	_ebaa  int
	_gcdcf int
	_baef  string
}

type yyParserImpl struct {
	_dgacb yySymType
	_gbead [_eacd]yySymType
	_gafef int
}

// Update updates references in the Range after removing a row/column.
func (_ecafb Range) Update(q *_cc.UpdateQuery) Expression {
	_fegad := _ecafb
	if q.UpdateCurrentSheet {
		_fegad._eadcf = _ecafb._eadcf.Update(q)
		_fegad._dfbgf = _ecafb._dfbgf.Update(q)
	}
	return _fegad
}

// Right implements the Excel RIGHT(string,[n]) function which returns the
// rightmost n characters.
func Right(args []Result) Result {
	_bbdgc := 1
	switch len(args) {
	case 1:
	case 2:
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0049\u0047\u0048\u0054\u0020\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_bbdgc = int(args[1].ValueNumber)
		if _bbdgc < 0 {
			return MakeErrorResult("R\u0049\u0047\u0048\u0054\u0020\u0065x\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u003e\u003d \u0030")
		}
		if _bbdgc == 0 {
			return MakeStringResult("")
		}
	default:
		return MakeErrorResult("\u0052\u0049\u0047HT\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeList {
		return MakeErrorResult("\u0052\u0049\u0047\u0048\u0054\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020c\u0061l\u006c\u0065\u0064\u0020\u006f\u006e\u0020\u0061\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_ddcd := args[0].Value()
	_eebg := len(_ddcd)
	if _bbdgc > _eebg {
		return MakeStringResult(_ddcd)
	}
	return MakeStringResult(_ddcd[_eebg-_bbdgc : _eebg])
}

// NewHorizontalRange constructs a new full rows range.
func NewHorizontalRange(v string) Expression {
	_efdaf := _ee.Split(v, "\u003a")
	if len(_efdaf) != 2 {
		return nil
	}
	_eggf, _ := _ff.Atoi(_efdaf[0])
	_ggab, _ := _ff.Atoi(_efdaf[1])
	return HorizontalRange{_eggf, _ggab}
}

// LCM implements the Excel LCM() function which returns the least common
// multiple of a range of numbers.
func LCM(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004c\u0043M(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0061t \u006c\u0065\u0061\u0073\u0074\u0020\u006fne\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_gaag := []float64{}
	for _, _fgbf := range args {
		switch _fgbf.Type {
		case ResultTypeString:
			_effa := _fgbf.AsNumber()
			if _effa.Type != ResultTypeNumber {
				return MakeErrorResult("\u004c\u0043M(\u0029\u0020\u006fn\u006c\u0079\u0020\u0061cce\u0070ts\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
			}
			_gaag = append(_gaag, _effa.ValueNumber)
		case ResultTypeList:
			_acdc := LCM(_fgbf.ValueList)
			if _acdc.Type != ResultTypeNumber {
				return _acdc
			}
			_gaag = append(_gaag, _acdc.ValueNumber)
		case ResultTypeNumber:
			_gaag = append(_gaag, _fgbf.ValueNumber)
		case ResultTypeError:
			return _fgbf
		}
	}
	if _gaag[0] < 0 {
		return MakeErrorResult("\u004c\u0043M\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(_gaag) == 1 {
		return MakeNumberResult(_gaag[0])
	}
	_daca := _gaag[0]
	for _bdaa := 1; _bdaa < len(_gaag); _bdaa++ {
		if _gaag[_bdaa] < 0 {
			return MakeErrorResult("\u004c\u0043M\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
		}
		_daca = _cedd(_daca, _gaag[_bdaa])
	}
	return MakeNumberResult(_daca)
}

func _gfgb(_bbed, _dfbc _ce.Time, _dff int) float64 {
	if _bbed.After(_dfbc) {
		_bbed, _dfbc = _dfbc, _bbed
	}
	_fbf := 0
	_ffaa, _gfbf, _ecdc := _bbed.Date()
	_fgef, _fdgd, _dcee := _dfbc.Date()
	_add, _ecbb := int(_gfbf), int(_fdgd)
	_gac, _bgec := _fgbb(_ffaa, _add, _ecdc, _dff), _fgbb(_fgef, _ecbb, _dcee, _dff)
	if !_ecbad(_dff) {
		return _acb(_fgef, _ecbb, _bgec) - _acb(_ffaa, _add, _gac)
	}
	if _dff == 0 {
		if (_add == 2 || _gac < 30) && _dcee == 31 {
			_bgec = 31
		} else if _ecbb == 2 && _bgec == _gfgc(_fgef, _ecbb) {
			_bgec = _gfgc(_fgef, 2)
		}
	} else {
		if _add == 2 && _gac == 30 {
			_gac = _gfgc(_ffaa, 2)
		}
		if _ecbb == 2 && _bgec == 30 {
			_bgec = _gfgc(_fgef, 2)
		}
	}
	if _ffaa < _fgef || (_ffaa == _fgef && _add < _ecbb) {
		_fbf = 30 - _gac + 1
		_ecdc = 1
		_gac = 1
		_ace := _ce.Date(_ffaa, _ce.Month(_add), _ecdc, 0, 0, 0, 0, _ce.UTC).AddDate(0, 1, 0)
		if _ace.Year() < _fgef {
			_fbf += _bgac(_ace.Year(), int(_ace.Month()), 12, _dff)
			_ace = _ace.AddDate(0, 13-int(_ace.Month()), 0)
			_fbf += _agdcc(_ace.Year(), _fgef-1, _dff)
		}
		_fbf += _bgac(_fgef, int(_ace.Month()), _ecbb-1, _dff)
		_ace = _ace.AddDate(0, _ecbb-int(_ace.Month()), 0)
		_add = _ace.Day()
	}
	_fbf += _bgec - _gac
	if _fbf > 0 {
		return float64(_fbf)
	} else {
		return 0
	}
}

// String returns a string representation of FunctionCall expression.
func (_cbdbdd FunctionCall) String() string {
	_fefgf := _d.Buffer{}
	_fefgf.WriteString(_cbdbdd._fbae)
	_fefgf.WriteString("\u0028")
	_bfcfe := len(_cbdbdd._agff) - 1
	for _gafc, _ggcc := range _cbdbdd._agff {
		_fefgf.WriteString(_ggcc.String())
		if _gafc != _bfcfe {
			_fefgf.WriteString("\u002c")
		}
	}
	_fefgf.WriteString("\u0029")
	return _fefgf.String()
}

func (_fabad *plex) Error(s string) {
	_ge.Log("\u0070a\u0072s\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0073", s)
}

const _gca = "\u0028(\u005b0\u002d\u0039\u005d\u0029\u002b)\u0020\u0028a\u006d\u007c\u0070\u006d\u0029"

func LexReader(r _e.Reader) chan *node { _gggd := NewLexer(); go _gggd.lex(r); return _gggd._daeg }

const _bcab = 57350

func _gbea(_gcfa []Result) Result {
	_gbdbg := _gcfa[0].ValueArray
	if len(_gcfa) == 1 {
		_ccbb := [][]Result{}
		for _, _agfg := range _gbdbg {
			_ccbb = append(_ccbb, _gdad([]Result{MakeListResult(_agfg)}).ValueList)
		}
		return MakeArrayResult(_ccbb)
	} else if len(_gcfa) == 2 {
		_cffgg := len(_gbdbg)
		_baed := len(_gbdbg[0])
		_fbec := _aebcb(_gcfa[1], _cffgg, _baed)
		_gfdf := len(_fbec)
		_gaed := [][]Result{}
		var _bdad []Result
		for _efbc, _gbcf := range _gbdbg {
			if _efbc < _gfdf {
				_bdad = _fbec[_efbc]
			} else {
				_bdad = _gadf(MakeErrorResultType(ErrorTypeNA, ""), _baed)
			}
			_gaed = append(_gaed, _gdad([]Result{MakeListResult(_gbcf), MakeListResult(_bdad)}).ValueList)
		}
		return MakeArrayResult(_gaed)
	} else if len(_gcfa) == 3 {
		_ddef := len(_gbdbg)
		_fgda := len(_gbdbg[0])
		_gfbc := _aebcb(_gcfa[1], _ddef, _fgda)
		_agece := _aebcb(_gcfa[2], _ddef, _fgda)
		_bddea := len(_gfbc)
		_ddfb := len(_agece)
		_egcgc := [][]Result{}
		var _geefg, _edbf []Result
		for _babc, _gggb := range _gbdbg {
			if _babc < _bddea {
				_geefg = _gfbc[_babc]
			} else {
				_geefg = _gadf(MakeErrorResultType(ErrorTypeNA, ""), _fgda)
			}
			if _babc < _ddfb {
				_edbf = _agece[_babc]
			} else {
				_edbf = _gadf(MakeErrorResultType(ErrorTypeNA, ""), _fgda)
			}
			_egcgc = append(_egcgc, _gdad([]Result{MakeListResult(_gggb), MakeListResult(_geefg), MakeListResult(_edbf)}).ValueList)
		}
		return MakeArrayResult(_egcgc)
	}
	return MakeErrorResultType(ErrorTypeValue, "")
}

// Reference returns an invalid reference for Number.
func (_gabb Number) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

func _bdbbb(_fcgae Context, _gfdeg, _dedbb int) (string, string) {
	_ebefa := "\u0041" + _ff.Itoa(_gfdeg)
	_aacf := _fcgae.LastColumn(_gfdeg, _dedbb)
	_bffc := _aacf + _ff.Itoa(_dedbb)
	return _ebefa, _bffc
}

// Left implements the Excel LEFT(string,[n]) function which returns the
// leftmost n characters.
func Left(args []Result) Result {
	_aecfb := 1
	switch len(args) {
	case 1:
	case 2:
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("\u004c\u0045F\u0054\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075me\u006e\u0074")
		}
		_aecfb = int(args[1].ValueNumber)
		if _aecfb < 0 {
			return MakeErrorResult("\u004c\u0045\u0046T \u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020n\u0075m\u0062e\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u003e\u003d\u0020\u0030")
		}
		if _aecfb == 0 {
			return MakeStringResult("")
		}
	default:
		return MakeErrorResult("\u004c\u0045\u0046T \u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeList {
		return MakeErrorResult("\u004c\u0045\u0046T\u0020\u0063\u0061\u006e'\u0074\u0020\u0062\u0065\u0020\u0063\u0061l\u006c\u0065\u0064\u0020\u006f\u006e\u0020\u0061\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_gcbc := args[0].Value()
	if _aecfb > len(_gcbc) {
		return MakeStringResult(_gcbc)
	}
	return MakeStringResult(_gcbc[0:_aecfb])
}

// Couppcd implements the Excel COUPPCD function.
func Couppcd(args []Result) Result {
	_ega, _aca := _dccda(args, "\u0043O\u0055\u0050\u0050\u0043\u0044")
	if _aca.Type == ResultTypeError {
		return _aca
	}
	_bccb := _fae(_ega._ggbd)
	_edeg := _fae(_ega._eedd)
	_ecaef := _ega._ecf
	_ggd := _ega._deagf
	_agda := _dfcf(_bccb, _edeg, _ecaef, _ggd)
	_cbdb, _eege, _ddbc := _agda.Date()
	return MakeNumberResult(_acb(_cbdb, int(_eege), _ddbc))
}

// NewVerticalRange constructs a new full columns range.
func NewVerticalRange(v string) Expression {
	_egdcd := _ee.Split(v, "\u003a")
	if len(_egdcd) != 2 {
		return nil
	}
	return VerticalRange{_egdcd[0], _egdcd[1]}
}

// Match implements the MATCH function.
func Match(args []Result) Result {
	_feeeb := len(args)
	if _feeeb != 2 && _feeeb != 3 {
		return MakeErrorResult("\u004d\u0041T\u0043\u0048\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020o\u0072\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_fffb := 1
	if _feeeb == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065q\u0075\u0069\u0072es\u0020\u0074\u0068\u0065\u0020\u0074h\u0069\u0072\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006db\u0065\u0072")
		}
		_cadc := args[2].ValueNumber
		if _cadc == -1 || _cadc == 0 {
			_fffb = int(_cadc)
		}
	}
	_cfdcb := args[1]
	var _abdg []Result
	switch _cfdcb.Type {
	case ResultTypeList:
		_abdg = _cfdcb.ValueList
	case ResultTypeArray:
		_gedd := _cfdcb.ValueArray
		if len(_gedd[0]) != 1 {
			return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068e\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006f\u006e\u0065\u002dd\u0069\u006d\u0065\u006e\u0073\u0069o\u006e\u0061l\u0020\u0072a\u006eg\u0065")
		}
		for _, _fecag := range _gedd {
			_abdg = append(_abdg, _fecag[0])
		}
	default:
		return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068e\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006f\u006e\u0065\u002dd\u0069\u006d\u0065\u006e\u0073\u0069o\u006e\u0061l\u0020\u0072a\u006eg\u0065")
	}
	_dccfg := _cacg(args[0])
	switch _fffb {
	case 0:
		for _cfbde, _gade := range _abdg {
			if _aebg(_gade, _dccfg) {
				return MakeNumberResult(float64(_cfbde + 1))
			}
		}
	case -1:
		for _cdbc := 0; _cdbc < len(_abdg); _cdbc++ {
			if _aebg(_abdg[_cdbc], _dccfg) {
				return MakeNumberResult(float64(_cdbc + 1))
			}
			if _dccfg._eaebd && (_abdg[_cdbc].ValueNumber < _dccfg._cbga) {
				if _cdbc == 0 {
					return MakeErrorResultType(ErrorTypeNA, "")
				}
				return MakeNumberResult(float64(_cdbc))
			}
		}
	case 1:
		for _dfec := 0; _dfec < len(_abdg); _dfec++ {
			if _aebg(_abdg[_dfec], _dccfg) {
				return MakeNumberResult(float64(_dfec + 1))
			}
			if _dccfg._eaebd && (_abdg[_dfec].ValueNumber > _dccfg._cbga) {
				if _dfec == 0 {
					return MakeErrorResultType(ErrorTypeNA, "")
				}
				return MakeNumberResult(float64(_dfec))
			}
		}
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}

// Proper is an implementation of the Excel PROPER function that returns a copy
// of the string with each word capitalized.
func Proper(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("P\u0052\u004f\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006eg \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_abbg := args[0].AsString()
	if _abbg.Type != ResultTypeString {
		return MakeErrorResult("P\u0052\u004f\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006eg \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_ccag := _d.Buffer{}
	_afafb := false
	for _, _aecc := range _abbg.ValueString {
		if !_afafb && _gc.IsLetter(_aecc) {
			_ccag.WriteRune(_gc.ToUpper(_aecc))
		} else {
			_ccag.WriteRune(_gc.ToLower(_aecc))
		}
		_afafb = _gc.IsLetter(_aecc)
	}
	return MakeStringResult(_ccag.String())
}

const _bacdbf = 57377

func (_gaeff *ivr) NamedRange(ref string) Reference { return ReferenceInvalid }

const (
	_aabe rmode = iota
	_eecgb
	_agcbg
)

// IsNA is an implementation of the Excel ISNA() function.
func IsNA(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u004e\u0041\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError && args[0].ValueString == "\u0023\u004e\u002f\u0041")
}

const _aedd = 57367

func _bbbfe() yyParser { return &yyParserImpl{} }

// GetFormat returns an empty string for the invalid reference context.
func (_ggbf *ivr) GetFormat(cellRef string) string { return "" }

var _fcfe = [...]uint8{0, 16, 29, 43, 56, 68, 80, 91, 102, 113, 125, 137, 148, 163}

const _afcdb = 57352

const _bfaa = 57366

func _aga(_agag, _dgfd, _dccg int) bool {
	if _dgfd < 1 || _dgfd > 12 {
		return false
	}
	if _dccg < 1 {
		return false
	}
	return _dccg <= _gfgc(_agag, _dgfd)
}

// Reference returns a string reference value to a named range.
func (_dgaa NamedRangeRef) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeNamedRange, Value: _dgaa._bdggc}
}

// NewString constructs a new string expression.
func NewString(v string) Expression {
	v = _ee.Replace(v, "\u0022\u0022", "\u0022", -1)
	return String{v}
}

// FloorMath implements _xlfn.FLOOR.MATH which rounds numbers down to the
// nearest multiple of the second argument, toward or away from zero as
// specified by the third argument.
func FloorMath(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u002e\u004dA\u0054\u0048\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u002e\u004dA\u0054\u0048\u0028)\u0020\u0061\u006c\u006co\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_gegf := args[0].AsNumber()
	if _gegf.Type != ResultTypeNumber {
		return MakeErrorResult("f\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020FL\u004f\u004f\u0052\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073t \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_cgbc := float64(1)
	if _gegf.ValueNumber < 0 {
		_cgbc = -1
	}
	if len(args) > 1 {
		_abeaf := args[1].AsNumber()
		if _abeaf.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061r\u0067\u0075\u006den\u0074\u0020\u0074\u006f\u0020\u0046L\u004f\u004f\u0052\u002e\u004d\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006db\u0065\u0072")
		}
		_cgbc = _abeaf.ValueNumber
	}
	_ecbe := float64(1)
	if len(args) > 2 {
		_eggc := args[2].AsNumber()
		if _eggc.Type != ResultTypeNumber {
			return MakeErrorResult("t\u0068\u0069\u0072\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020FL\u004f\u004f\u0052\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073t \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_ecbe = _eggc.ValueNumber
	}
	if len(args) == 1 {
		return MakeNumberResult(_dc.Floor(_gegf.ValueNumber))
	}
	_ddaa := _gegf.ValueNumber
	_ddaa, _cgcc := _dc.Modf(_ddaa / _cgbc)
	if _cgcc != 0 && _gegf.ValueNumber < 0 && _ecbe > 0 {
		_ddaa++
	}
	return MakeNumberResult(_ddaa * _cgbc)
}

// Update updates the FunctionCall references after removing a row/column.
func (_ddffc FunctionCall) Update(q *_cc.UpdateQuery) Expression {
	_abaa := []Expression{}
	for _, _gafee := range _ddffc._agff {
		_agddd := _gafee.Update(q)
		_abaa = append(_abaa, _agddd)
	}
	return FunctionCall{_fbae: _ddffc._fbae, _agff: _abaa}
}

func _gdad(_gefd []Result) Result {
	_cgd := _gefd[0].ValueList
	_egdff := len(_cgd)
	switch len(_gefd) {
	case 1:
		_fabg := []Result{}
		for _, _gbgd := range _cgd {
			_fabg = append(_fabg, MakeBoolResult(_gbgd.ValueNumber != 0))
		}
		return MakeListResult(_fabg)
	case 2:
		_dgdae := _gefd[1]
		switch _dgdae.Type {
		case ResultTypeNumber, ResultTypeString, ResultTypeEmpty:
			_acbd := []Result{}
			for _, _eabg := range _cgd {
				var _gcce Result
				if _eabg.ValueNumber == 0 {
					_gcce = MakeBoolResult(false)
				} else {
					_gcce = _dgdae
				}
				_acbd = append(_acbd, _gcce)
			}
			return MakeListResult(_acbd)
		case ResultTypeList:
			_cdef := _gadf(_dgdae, _egdff)
			_dbfea := []Result{}
			for _bbee, _dfgg := range _cgd {
				var _bgaa Result
				if _dfgg.ValueNumber == 0 {
					_bgaa = MakeBoolResult(false)
				} else {
					_bgaa = _cdef[_bbee]
				}
				_dbfea = append(_dbfea, _bgaa)
			}
			return MakeListResult(_dbfea)
		case ResultTypeArray:
			_cbba := _aebcb(_dgdae, len(_dgdae.ValueArray), _egdff)
			_gdffb := [][]Result{}
			for _, _ggefd := range _cbba {
				_adef := []Result{}
				for _dcacc, _ebdcd := range _cgd {
					var _daeba Result
					if _ebdcd.ValueNumber == 0 {
						_daeba = MakeBoolResult(false)
					} else {
						_daeba = _ggefd[_dcacc]
					}
					_adef = append(_adef, _daeba)
				}
				_gdffb = append(_gdffb, _adef)
			}
			return MakeArrayResult(_gdffb)
		}
	case 3:
		_dfdf := _gefd[1]
		_gbcg := _gefd[2]
		_afcgg := _dceg(_dfdf)
		_bbfg := _dceg(_gbcg)
		if _afcgg && _bbfg {
			_egeg := []Result{}
			for _, _gbbf := range _cgd {
				var _gebg Result
				if _gbbf.ValueNumber == 0 {
					_gebg = _gbcg
				} else {
					_gebg = _dfdf
				}
				_egeg = append(_egeg, _gebg)
			}
			return MakeListResult(_egeg)
		}
		if _dfdf.Type != ResultTypeArray && _gbcg.Type != ResultTypeArray {
			_ddfd := _gadf(_dfdf, _egdff)
			_egbc := _gadf(_gbcg, _egdff)
			_acagg := []Result{}
			for _dfef, _agcf := range _cgd {
				var _ddba Result
				if _agcf.ValueNumber == 0 {
					_ddba = _egbc[_dfef]
				} else {
					_ddba = _ddfd[_dfef]
				}
				_acagg = append(_acagg, _ddba)
			}
			return MakeListResult(_acagg)
		}
		_afcdf := len(_dfdf.ValueArray)
		if len(_gbcg.ValueArray) > _afcdf {
			_afcdf = len(_gbcg.ValueArray)
		}
		_dcga := _aebcb(_dfdf, _afcdf, _egdff)
		_bccbd := _aebcb(_gbcg, _afcdf, _egdff)
		_caabc := [][]Result{}
		for _fgdf := 0; _fgdf < _afcdf; _fgdf++ {
			_cfge := []Result{}
			for _gaedc, _fdaeg := range _cgd {
				var _eage Result
				if _fdaeg.ValueNumber == 0 {
					_eage = _bccbd[_fgdf][_gaedc]
				} else {
					_eage = _dcga[_fgdf][_gaedc]
				}
				_cfge = append(_cfge, _eage)
			}
			_caabc = append(_caabc, _cfge)
		}
		return MakeArrayResult(_caabc)
	}
	return MakeErrorResult("")
}

// GetLocked returns FALSE for the invalid reference context.
func (_fgged *ivr) GetLocked(cellRef string) bool { return false }

const _cdaba = 57371

// ConstArrayExpr is a constant array expression.
type ConstArrayExpr struct{ _fdb [][]Expression }

// RegisterFunctionComplex registers a standard function.
func RegisterFunctionComplex(name string, fn FunctionComplex) {
	_fafbc.Lock()
	defer _fafbc.Unlock()
	if _, _dfcfee := _bedfa[name]; _dfcfee {
		_ge.Log("\u0064\u0075p\u006c\u0069\u0063\u0061t\u0065\u0020r\u0065\u0067\u0069\u0073\u0074\u0072\u0061\u0074i\u006f\u006e\u0020\u006f\u0066\u0020\u0066\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0025\u0073", name)
	}
	_bedfa[name] = fn
}

func init() {
	_fegbd()
	RegisterFunction("\u0041V\u0045\u0052\u0041\u0047\u0045", Average)
	RegisterFunction("\u0041\u0056\u0045\u0052\u0041\u0047\u0045\u0041", Averagea)
	RegisterFunction("\u0043\u004f\u0055N\u0054", Count)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0041", Counta)
	RegisterFunction("\u0043O\u0055\u004e\u0054\u0049\u0046", CountIf)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0049\u0046\u0053", CountIfs)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0042\u004c\u0041\u004e\u004b", CountBlank)
	RegisterFunction("\u004d\u0041\u0058", Max)
	RegisterFunction("\u004d\u0041\u0058\u0041", MaxA)
	RegisterFunction("\u004d\u0041\u0058\u0049\u0046\u0053", MaxIfs)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u004d\u0041\u0058\u0049\u0046\u0053", MaxIfs)
	RegisterFunction("\u004d\u0045\u0044\u0049\u0041\u004e", Median)
	RegisterFunction("\u004d\u0049\u004e", Min)
	RegisterFunction("\u004d\u0049\u004e\u0041", MinA)
	RegisterFunction("\u004d\u0049\u004e\u0049\u0046\u0053", MinIfs)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u004d\u0049\u004e\u0049\u0046\u0053", MinIfs)
}

// Concat is an implementation of the Excel CONCAT() and deprecated CONCATENATE() function.
func Concat(args []Result) Result {
	_fcea := _d.Buffer{}
	for _, _fabe := range args {
		switch _fabe.Type {
		case ResultTypeString:
			_fcea.WriteString(_fabe.ValueString)
		case ResultTypeNumber:
			var _bebag string
			if _fabe.IsBoolean {
				if _fabe.ValueNumber == 0 {
					_bebag = "\u0046\u0041\u004cS\u0045"
				} else {
					_bebag = "\u0054\u0052\u0055\u0045"
				}
			} else {
				_bebag = _fabe.AsString().ValueString
			}
			_fcea.WriteString(_bebag)
		default:
			return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041T\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0073")
		}
	}
	return MakeStringResult(_fcea.String())
}

const (
	_aafg  cmpResult = 0
	_bcea  cmpResult = -1
	_cdad  cmpResult = 1
	_deecf cmpResult = 2
)

// Reference returns a string reference value to an expression with prefix.
func (_ebcdbc PrefixExpr) Reference(ctx Context, ev Evaluator) Reference {
	_bcece := _ebcdbc._agaa.Reference(ctx, ev)
	_cbge := _ebcdbc._ddfc.Reference(ctx, ev)
	if _bcece.Type == ReferenceTypeSheet && _cbge.Type == ReferenceTypeCell {
		return Reference{Type: ReferenceTypeCell, Value: _bcece.Value + "\u0021" + _cbge.Value}
	}
	return ReferenceInvalid
}

// Update returns the same object as updating sheet references does not affect String.
func (_ccaba String) Update(q *_cc.UpdateQuery) Expression { return _ccaba }

// Reference returns an invalid reference for Error.
func (_deae Error) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

const _acabf int = 0

// Eval evaluates a range returning a list of results or an error.
func (_gbdbc Range) Eval(ctx Context, ev Evaluator) Result {
	_cacgb := _gbdbc._eadcf.Reference(ctx, ev)
	_ecdb := _gbdbc._dfbgf.Reference(ctx, ev)
	_gbdc := _ddbfg(_cacgb, _ecdb)
	if _cacgb.Type == ReferenceTypeCell && _ecdb.Type == ReferenceTypeCell {
		if _eaggc, _gfbcf := ev.GetFromCache(_gbdc); _gfbcf {
			return _eaggc
		} else {
			_fbgc := _efbfc(ctx, ev, _cacgb.Value, _ecdb.Value)
			ev.SetCache(_gbdc, _fbgc)
			return _fbgc
		}
	}
	return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072a\u006e\u0067\u0065\u0020" + _gbdc)
}

func _cdfdb(_cgffd yyLexer, _dagef *yySymType) (_ebea, _cfaae int) {
	_cfaae = 0
	_ebea = _cgffd.Lex(_dagef)
	if _ebea <= 0 {
		_cfaae = _efbb[0]
		goto _eead
	}
	if _ebea < len(_efbb) {
		_cfaae = _efbb[_ebea]
		goto _eead
	}
	if _ebea >= _dfbae {
		if _ebea < _dfbae+len(_dabbd) {
			_cfaae = _dabbd[_ebea-_dfbae]
			goto _eead
		}
	}
	for _gbfga := 0; _gbfga < len(_befd); _gbfga += 2 {
		_cfaae = _befd[_gbfga+0]
		if _cfaae == _ebea {
			_cfaae = _befd[_gbfga+1]
			goto _eead
		}
	}
_eead:
	if _cfaae == 0 {
		_cfaae = _dabbd[1]
	}
	if _fabd >= 3 {
		_c.Printf("l\u0065\u0078\u0020\u0025\u0073\u0028\u0025\u0064\u0029\u000a", _ffdeg(_cfaae), uint(_ebea))
	}
	return _ebea, _cfaae
}

type node struct {
	_faaa  tokenType
	_acccf string
}

// String returns a string representation of a vertical range.
func (_ffbbb VerticalRange) String() string { return _ffbbb.verticalRangeReference() }

func (_affc ReferenceType) String() string {
	if _affc >= ReferenceType(len(_cdaef)-1) {
		return _c.Sprintf("\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070e\u0028\u0025\u0064\u0029", _affc)
	}
	return _bbdfb[_cdaef[_affc]:_cdaef[_affc+1]]
}

// IsLeapYear is an implementation of the Excel ISLEAPYEAR() function.
func IsLeapYear(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049S\u004c\u0045A\u0050\u0059\u0045\u0041R\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073in\u0067\u006c\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_agdaf := ctx.GetEpoch()
	_afcg, _bbge := _aefcg(args[0].Value(), _agdaf)
	if _bbge != nil {
		return MakeErrorResult("\u0049S\u004c\u0045A\u0050\u0059\u0045\u0041R\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073in\u0067\u006c\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_dcbg := _afcg.Year()
	return MakeBoolResult(_dfa(_dcbg))
}

// Odd is an implementation of the Excel ODD() that rounds a number to the
// nearest odd integer.
func Odd(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("O\u0044\u0044\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006ee\u0020\u0061\u0072g\u0075m\u0065\u006e\u0074")
	}
	_ffba := args[0].AsNumber()
	if _ffba.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bagc := _dc.Signbit(_ffba.ValueNumber)
	_fdec, _beba := _dc.Modf((_ffba.ValueNumber - 1) / 2)
	_gegb := _fdec*2 + 1
	if _beba != 0 {
		if !_bagc {
			_gegb += 2
		} else {
			_gegb -= 2
		}
	}
	return MakeNumberResult(_gegb)
}

// SumIf implements the SUMIF function.
func SumIf(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0053\u0055\u004d\u0049\u0046\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0068\u0072e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_aaae := args[0]
	if _aaae.Type != ResultTypeArray && _aaae.Type != ResultTypeList {
		return MakeErrorResult("\u0053\u0055\u004d\u0049\u0046\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0066i\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_edfga := _cdafd(_aaae)
	_addd := args[2]
	if _addd.Type != ResultTypeArray && _addd.Type != ResultTypeList {
		return MakeErrorResult("\u0053\u0055\u004dI\u0046\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0061\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_gcafb := _cdafd(_addd)
	_effab := _cacg(args[1])
	_aafgd := 0.0
	for _cfaag, _fafca := range _edfga {
		for _bded, _fegf := range _fafca {
			if _egaa(_fegf, _effab) {
				_aafgd += _gcafb[_cfaag][_bded].ValueNumber
			}
		}
	}
	return MakeNumberResult(_aafgd)
}

func _edad(_dcdd float64) float64 { return float64(int(_dcdd + 0.5)) }

// NewError constructs a new error expression from a string.
func NewError(v string) Expression { return Error{v} }

const _edbb = "\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065U\u006e\u006b\u006e\u006f\u0077\u006e\u0052\u0065\u0073u\u006c\u0074\u0054y\u0070\u0065\u004e\u0075\u006d\u0062\u0065\u0072\u0052\u0065s\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0053\u0074\u0072\u0069\u006e\u0067\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0073\u0074\u0052\u0065\u0073\u0075lt\u0054\u0079p\u0065\u0041r\u0072\u0061\u0079\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0045\u0072\u0072\u006f\u0072\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0045\u006d\u0070\u0074\u0079"

// Choose implements the Excel CHOOSE function.
func Choose(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0043\u0048O\u004f\u0053\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_acefd := args[0]
	if _acefd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043H\u004f\u004fS\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_daaf := int(_acefd.ValueNumber)
	if len(args) <= _daaf {
		return MakeErrorResult("\u0049\u006e\u0064\u0065\u0078\u0020\u0073\u0068\u006f\u0075\u006cd\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073 \u006fr\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0076\u0061\u006c\u0075\u0065\u0073")
	}
	return args[_daaf]
}

// Base is an implementation of the Excel BASE function that returns a string
// form of an integer in a specified base and of a minimum length with padded
// zeros.
func Base(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0042\u0041\u0053\u0045\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0042\u0041S\u0045\u0028\u0029\u0020a\u006c\u006co\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006fs\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_gbdef := args[0].AsNumber()
	if _gbdef.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042A\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_edaa := args[1].AsNumber()
	if _edaa.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063o\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042\u0041\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_effc := int(_edaa.ValueNumber)
	if _effc < 0 || _effc > 36 {
		return MakeErrorResult("\u0072\u0061\u0064\u0069\u0078\u0020m\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065 \u0072\u0061\u006e\u0067\u0065\u0020\u005b0\u002c\u0033\u0036\u005d")
	}
	_gbdd := 0
	if len(args) > 2 {
		_dcdg := args[2].AsNumber()
		if _dcdg.Type != ResultTypeNumber {
			return MakeErrorResult("\u0074\u0068\u0069\u0072\u0064 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042A\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_gbdd = int(_dcdg.ValueNumber)
	}
	_aecbd := _ff.FormatInt(int64(_gbdef.ValueNumber), _effc)
	if len(_aecbd) < _gbdd {
		_aecbd = _ee.Repeat("\u0030", _gbdd-len(_aecbd)) + _aecbd
	}
	return MakeStringResult(_aecbd)
}

// Eval evaluates and returns the result of a Negate expression.
func (_gbffc Negate) Eval(ctx Context, ev Evaluator) Result {
	_dfgc := _gbffc._ggbdc.Eval(ctx, ev)
	if _dfgc.Type == ResultTypeNumber {
		return MakeNumberResult(-_dfgc.ValueNumber)
	}
	return MakeErrorResult("\u004e\u0045\u0047A\u0054\u0045\u0020\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
}

// IfError is an implementation of the Excel IFERROR() function. It takes two arguments.
func IfError(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0049\u0046\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeError {
		if args[0].Type == ResultTypeEmpty {
			return MakeNumberResult(0)
		}
		return args[0]
	}
	return args[1]
}

const _deecg = 57357

// Transpose implements the TRANSPOSE function that transposes a cell range.
func Transpose(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0054\u0052AN\u0053\u0050\u004fS\u0045\u0020\u0072\u0065qui\u0072es\u0020\u0061\u0020\u0073\u0069\u006e\u0067le\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[0].Type != ResultTypeArray && args[0].Type != ResultTypeList {
		return MakeErrorResult("T\u0052\u0041\u004e\u0053\u0050\u004fS\u0045\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0061\u0020\u0072a\u006e\u0067\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_ebbf := args[0]
	if _ebbf.Type == ResultTypeList {
		_fffef := [][]Result{}
		for _, _gcbd := range _ebbf.ValueList {
			_fffef = append(_fffef, []Result{_gcbd})
		}
		return MakeArrayResult(_fffef)
	}
	_dfcga := make([][]Result, len(_ebbf.ValueArray[0]))
	for _, _dbaa := range _ebbf.ValueArray {
		for _acff, _egcd := range _dbaa {
			_dfcga[_acff] = append(_dfcga[_acff], _egcd)
		}
	}
	return MakeArrayResult(_dfcga)
}

// Dollarfr implements the Excel DOLLARFR function.
func Dollarfr(args []Result) Result {
	_bdbc, _dbbe, _bbdaf := _cffd(args, "\u0044\u004f\u004c\u004c\u0041\u0052\u0046\u0052")
	if _bbdaf.Type == ResultTypeError {
		return _bbdaf
	}
	if _bdbc == 0 {
		return MakeNumberResult(0)
	}
	_ebcdb := _bdbc < 0
	if _ebcdb {
		_bdbc = -_bdbc
	}
	_gcaa := float64(int(_bdbc))
	_cgaa := args[0].Value()
	_geeb := _ee.Split(_cgaa, "\u002e")
	_gad := _geeb[1]
	_ecacd, _caga := _ff.ParseFloat(_gad, 64)
	if _caga != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006fr \u0044\u004f\u004cL\u0041R\u0046\u0052")
	}
	_gefc := float64(len(_gad))
	_ecacd /= _dc.Pow(10, _gefc)
	_bccf := _ecacd*_dbbe/_dc.Pow(10, float64(int(_dc.Log10(_dbbe)))+1) + _gcaa
	if _ebcdb {
		_bccf = -_bccf
	}
	return MakeNumberResult(_bccf)
}

// MaxIfs implements the MAXIFS function.
func MaxIfs(args []Result) Result {
	_eddea := _gdgfe(args, true, "\u004d\u0041\u0058\u0049\u0046\u0053")
	if _eddea.Type != ResultTypeEmpty {
		return _eddea
	}
	_dacg := _eabc(args[1:])
	_dagc := -_dc.MaxFloat64
	_bdbb := _cdafd(args[0])
	for _, _ffdd := range _dacg {
		_gcgae := _bdbb[_ffdd._ffaab][_ffdd._edga].ValueNumber
		if _dagc < _gcgae {
			_dagc = _gcgae
		}
	}
	if _dagc == -_dc.MaxFloat64 {
		_dagc = 0
	}
	return MakeNumberResult(float64(_dagc))
}

// CountIfs implements the COUNTIFS function.
func CountIfs(args []Result) Result {
	_efecef := _gdgfe(args, false, "\u0043\u004f\u0055\u004e\u0054\u0049\u0046\u0053")
	if _efecef.Type != ResultTypeEmpty {
		return _efecef
	}
	_bdded := _eabc(args)
	return MakeNumberResult(float64(len(_bdded)))
}

// SupportedFunctions returns a list of supported functions.
func SupportedFunctions() []string {
	_gfgg := []string{}
	for _abfgd := range _baad {
		_gfgg = append(_gfgg, _abfgd)
	}
	for _dccdaa := range _bedfa {
		_gfgg = append(_gfgg, _dccdaa)
	}
	_a.Strings(_gfgg)
	return _gfgg
}

// Update updates references in the PrefixExpr after removing a row/column.
func (_geafd PrefixExpr) Update(q *_cc.UpdateQuery) Expression {
	_cgac := _geafd
	_gcfcc := _geafd._agaa.String()
	if _gcfcc == q.SheetToUpdate {
		_egeeb := *q
		_egeeb.UpdateCurrentSheet = true
		_cgac._ddfc = _geafd._ddfc.Update(&_egeeb)
	}
	return _cgac
}

var _fgeed = [...]int{0, 0, 71, 70, 69, 4, 67, 66, 53, 51, 50, 49, 48, 47, 46, 45, 44, 2}

type ri struct {
	_bdgf   float64
	_eagead string
}

func _cbeg(_gebga Result) Result {
	if _gebga.Type == ResultTypeEmpty {
		return _gebga
	}
	_gcada := _gebga.AsString()
	if _gcada.Type != ResultTypeString {
		return MakeErrorResult("\u004c\u004f\u0057\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if _gebga.IsBoolean {
		if _gcada.ValueString == "\u0031" {
			return MakeStringResult("\u0074\u0072\u0075\u0065")
		} else if _gcada.ValueString == "\u0030" {
			return MakeStringResult("\u0066\u0061\u006cs\u0065")
		} else {
			return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004c\u004fW\u0045\u0052")
		}
	} else {
		return MakeStringResult(_ee.ToLower(_gcada.ValueString))
	}
}

const _dfbae = 57344

// Eval evaluates and returns an expression with prefix.
func (_caegd PrefixExpr) Eval(ctx Context, ev Evaluator) Result {
	_aeba := _caegd._agaa.Reference(ctx, ev)
	switch _aeba.Type {
	case ReferenceTypeSheet:
		_dagfd := ctx.Sheet(_aeba.Value)
		return _caegd._ddfc.Eval(_dagfd, ev)
	default:
		return MakeErrorResult(_c.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _aeba.Type))
	}
}

type countMode byte

// Ppmt implements the Excel PPPMT function.
func Ppmt(args []Result) Result {
	_cgee := len(args)
	if _cgee < 4 || _cgee > 6 {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006ff\u0020\u0066\u006f\u0075\u0072\u0020a\u006e\u0064\u0020s\u0069\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_edbe := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004dT\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_agdf := args[1].ValueNumber
	if _agdf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "P\u0050\u004d\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020p\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069v\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gdaac := args[2].ValueNumber
	if _gdaac < _agdf {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064s\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065s\u0073\u0020\u0074\u0068\u0061\u006e \u0070\u0065\u0072i\u006f\u0064")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_geff := args[3].ValueNumber
	_bagf := 0.0
	if _cgee >= 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_bagf = args[4].ValueNumber
	}
	_adbd := 0
	if _cgee == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("P\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_adbd = int(args[5].ValueNumber)
		if _adbd != 0 {
			_adbd = 1
		}
	}
	return MakeNumberResult(_faf(_edbe, _gdaac, _geff, _bagf, _adbd) - _cgfc(_edbe, _agdf, _gdaac, _geff, _bagf, _adbd))
}

func init() {
	RegisterFunction("\u0043\u0048\u0041\u0052", Char)
	RegisterFunction("\u0043\u004c\u0045A\u004e", Clean)
	RegisterFunction("\u0043\u004f\u0044\u0045", Code)
	RegisterFunction("C\u004f\u004e\u0043\u0041\u0054\u0045\u004e\u0041\u0054\u0045", Concat)
	RegisterFunction("\u0043\u004f\u004e\u0043\u0041\u0054", Concat)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u0043\u004f\u004e\u0043\u0041\u0054", Concat)
	RegisterFunction("\u0045\u0058\u0041C\u0054", Exact)
	RegisterFunction("\u0046\u0049\u004e\u0044", Find)
	RegisterFunctionComplex("\u0046\u0049\u004eD\u0042", Findb)
	RegisterFunction("\u004c\u0045\u0046\u0054", Left)
	RegisterFunction("\u004c\u0045\u0046T\u0042", Left)
	RegisterFunction("\u004c\u0045\u004e", Len)
	RegisterFunction("\u004c\u0045\u004e\u0042", Len)
	RegisterFunction("\u004c\u004f\u0057E\u0052", Lower)
	RegisterFunction("\u004d\u0049\u0044", Mid)
	RegisterFunction("\u0050\u0052\u004f\u0050\u0045\u0052", Proper)
	RegisterFunction("\u0052E\u0050\u004c\u0041\u0043\u0045", Replace)
	RegisterFunction("\u0052\u0045\u0050\u0054", Rept)
	RegisterFunction("\u0052\u0049\u0047H\u0054", Right)
	RegisterFunction("\u0052\u0049\u0047\u0048\u0054\u0042", Right)
	RegisterFunction("\u0053\u0045\u0041\u0052\u0043\u0048", Search)
	RegisterFunctionComplex("\u0053E\u0041\u0052\u0043\u0048\u0042", Searchb)
	RegisterFunction("\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", Substitute)
	RegisterFunction("\u0054", T)
	RegisterFunction("\u0054\u0045\u0058\u0054", Text)
	RegisterFunction("\u0054\u0045\u0058\u0054\u004a\u004f\u0049\u004e", TextJoin)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0054\u0045\u0058T\u004a\u004f\u0049\u004e", TextJoin)
	RegisterFunction("\u0054\u0052\u0049\u004d", Trim)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0055\u004e\u0049\u0043\u0048\u0041\u0052", Char)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0055\u004e\u0049\u0043\u004f\u0044\u0045", Unicode)
	RegisterFunction("\u0055\u0050\u0050E\u0052", Upper)
	RegisterFunction("\u0056\u0041\u004cU\u0045", Value)
}

func _gbcc(_feee, _fgcb float64) bool { return _dc.Abs(_feee-_fgcb) < 1.0e-6 }

func _fegbd() {
	_fcaa = _gf.MustCompile("\u005e\u0028\u005b\u0030\u002d\u0039\u005d\u002b\u0029\u0024")
	_ceae = _gf.MustCompile("\u005e=\u0028\u002e\u002a\u0029\u0024")
	_bacdb = _gf.MustCompile("\u005e<\u0028\u002e\u002a\u0029\u0024")
	_eacg = _gf.MustCompile("\u005e>\u0028\u002e\u002a\u0029\u0024")
	_ecaee = _gf.MustCompile("\u005e\u003c\u003d\u0028\u002e\u002a\u0029\u0024")
	_gfee = _gf.MustCompile("\u005e\u003e\u003d\u0028\u002e\u002a\u0029\u0024")
}

// NewNegate constructs a new negate expression.
func NewNegate(e Expression) Expression { return Negate{e} }

// Average implements the AVERAGE function. It differs slightly from Excel (and
// agrees with LibreOffice) in that boolean values are counted. As an example,
// AVERAGE of two cells containing TRUE & FALSE is 0.5 in LibreOffice and
// #DIV/0! in Excel. unioffice will return 0.5 in this case.
func Average(args []Result) Result {
	_bddc, _fbcg := _cbag(args, false)
	if _fbcg == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0041\u0056\u0045\u0052AG\u0045\u0020\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065r\u006f")
	}
	return MakeNumberResult(_bddc / _fbcg)
}

func _dfcf(_cgbf, _gaff _ce.Time, _aged, _ggfb int) _ce.Time {
	_cebb := _gaff
	_cgg := _cgbf.Year() - _gaff.Year()
	_cebb = _cebb.AddDate(_cgg, 0, 0)
	if _cgbf.After(_cebb) {
		_cebb = _cebb.AddDate(1, 0, 0)
	}
	_ecafg := -12 / _aged
	for _cebb.After(_cgbf) {
		_cebb = _cebb.AddDate(0, _ecafg, 0)
	}
	return _cebb
}

var _fafbc _f.Mutex

func ParseString(s string) Expression {
	if s == "" {
		return NewEmptyExpr()
	}
	return Parse(_ee.NewReader(s))
}

func (_ddgca tokenType) String() string { return _ffdeg(int(_ddgca)) }

// Negate is a negate expression like -A1.
type Negate struct{ _ggbdc Expression }

// Result is the result of a formula or cell evaluation .
type Result struct {
	ValueNumber  float64
	ValueString  string
	ValueList    []Result
	ValueArray   [][]Result
	IsBoolean    bool
	ErrorMessage string
	Type         ResultType
	Ref          Reference
}

func _gadf(_dddf Result, _dbga int) []Result {
	_dccad := []Result{}
	switch _dddf.Type {
	case ResultTypeList:
		_acae := _dddf.ValueList
		_gdfc := len(_acae)
		for _bgbgc := 0; _bgbgc < _dbga; _bgbgc++ {
			if _bgbgc < _gdfc {
				_dccad = append(_dccad, _acae[_bgbgc])
			} else {
				_dccad = append(_dccad, MakeErrorResultType(ErrorTypeNA, ""))
			}
		}
	case ResultTypeNumber, ResultTypeString, ResultTypeError, ResultTypeEmpty:
		for _abce := 0; _abce < _dbga; _abce++ {
			_dccad = append(_dccad, _dddf)
		}
	}
	return _dccad
}

const _fcf = "\u0042\u0069\u006e\u004f\u0070\u0054y\u0070\u0065\u0055\u006e\u006bn\u006fw\u006e\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0050\u006c\u0075\u0073\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u004d\u0069\u006e\u0075\u0073\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065M\u0075lt\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0044\u0069\u0076\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0045\u0078\u0070\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u004c\u0054\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065G\u0054B\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0045\u0051\u0042\u0069nO\u0070\u0054\u0079\u0070\u0065\u004c\u0045\u0051\u0042i\u006eO\u0070\u0054\u0079\u0070\u0065\u0047\u0045\u0051\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065N\u0045\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0043\u006f\u006e\u0063\u0061\u0074"

// Findb is an implementation of the Excel FINDB().
func Findb(ctx Context, ev Evaluator, args []Result) Result {
	if !ctx.IsDBCS() {
		return Find(args)
	}
	_ecaad, _cdfe := _acfc("\u0046\u0049\u004e\u0044", args)
	if _cdfe.Type != ResultTypeEmpty {
		return _cdfe
	}
	_gafbg := _ecaad._dede
	if _gafbg == "" {
		return MakeNumberResult(1.0)
	}
	_cdcg := _ecaad._affa
	_faag := _ecaad._caacac - 1
	_dfaf := 1
	_daag := 0
	for _gffb := range _cdcg {
		if _gffb != 0 {
			_eaccd := 1
			if _gffb-_daag > 1 {
				_eaccd = 2
			}
			_dfaf += _eaccd
		}
		if _dfaf > _faag {
			_adgd := _ee.Index(_cdcg[_gffb:], _gafbg)
			if _adgd == 0 {
				return MakeNumberResult(float64(_dfaf))
			}
		}
		_daag = _gffb
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// ReferenceType is a type of reference
//go:generate stringer -type=ReferenceType
type ReferenceType byte

// String returns a string representation of a range with prefix.
func (_bgde PrefixRangeExpr) String() string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _bgde._cgegf.String(), _bgde._gaga.String(), _bgde._dbaf.String())
}

const _gfdec = 57368

func _ecec(_cdbebe int) string {
	if _cdbebe >= 0 && _cdbebe < len(_feaa) {
		if _feaa[_cdbebe] != "" {
			return _feaa[_cdbebe]
		}
	}
	return _c.Sprintf("\u0073\u0074\u0061\u0074\u0065\u002d\u0025\u0076", _cdbebe)
}

func _bgac(_ggcf, _deccg, _fbff, _fggf int) int {
	if _deccg > _fbff {
		return 0
	}
	if _ecbad(_fggf) {
		return (_fbff - _deccg + 1) * 30
	}
	_caff := 0
	for _ddag := _deccg; _ddag <= _fbff; _ddag++ {
		_caff += _gfgc(_ggcf, _ddag)
	}
	return _caff
}

func (_cdfde Result) String() string { return _cdfde.Value() }

const _gdbgc = 57349

// NewCellRef constructs a new cell reference.
func NewCellRef(v string) Expression { return CellRef{v} }

const _ddff = "(\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002d" + _dae + "-\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

// Effect implements the Excel EFFECT function.
func Effect(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u0046F\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u006f\u006d\u0069n\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_adac := args[0].ValueNumber
	if _adac <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0045\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u006f\u006d\u0069n\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0046\u0046\u0045\u0043\u0054 \u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066 \u0063\u006f\u006d\u0070\u006f\u0075\u006e\u0064\u0069\u006e\u0067\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	_aaa := float64(int(args[1].ValueNumber))
	if _aaa < 1 {
		return MakeErrorResultType(ErrorTypeNum, "E\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0063o\u006dp\u006f\u0075\u006e\u0064i\u006e\u0067 \u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0031\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065")
	}
	return MakeNumberResult(_dc.Pow((1+_adac/_aaa), _aaa) - 1)
}

const _efa = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u0028\u0020\u0028\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"

func _ffdeg(_adfaf int) string {
	if _adfaf >= 1 && _adfaf-1 < len(_fefab) {
		if _fefab[_adfaf-1] != "" {
			return _fefab[_adfaf-1]
		}
	}
	return _c.Sprintf("\u0074\u006f\u006b\u002d\u0025\u0076", _adfaf)
}

// Eval evaluates a range with prefix returning a list of results or an error.
func (_dagb PrefixRangeExpr) Eval(ctx Context, ev Evaluator) Result {
	_febd := _dagb._cgegf.Reference(ctx, ev)
	_dfge := _dagb._gaga.Reference(ctx, ev)
	_ebgfe := _dagb._dbaf.Reference(ctx, ev)
	switch _febd.Type {
	case ReferenceTypeSheet:
		_gcef := _agbd(_febd, _dfge, _ebgfe)
		if _dfge.Type == ReferenceTypeCell && _ebgfe.Type == ReferenceTypeCell {
			if _gcfbee, _cggb := ev.GetFromCache(_gcef); _cggb {
				return _gcfbee
			} else {
				_cffdf := _efbfc(ctx.Sheet(_febd.Value), ev, _dfge.Value, _ebgfe.Value)
				ev.SetCache(_gcef, _cffdf)
				return _cffdf
			}
		}
		return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072a\u006e\u0067\u0065\u0020" + _gcef)
	default:
		return MakeErrorResult(_c.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _febd.Type))
	}
}

func _eabc(_gbbd []Result) []rangeIndex {
	_gebf := []rangeIndex{}
	_bcgee := len(_gbbd)
	for _abafd := 0; _abafd < _bcgee-1; _abafd += 2 {
		_fecc := []rangeIndex{}
		_fdd := _cdafd(_gbbd[_abafd])
		_dadd := _cacg(_gbbd[_abafd+1])
		if _abafd == 0 {
			for _dcdc, _dbbd := range _fdd {
				for _gbfaf, _bebba := range _dbbd {
					if _egaa(_bebba, _dadd) {
						_fecc = append(_fecc, rangeIndex{_dcdc, _gbfaf})
					}
				}
			}
		} else {
			for _, _agggb := range _gebf {
				_ebgbc := _fdd[_agggb._ffaab][_agggb._edga]
				if _egaa(_ebgbc, _dadd) {
					_fecc = append(_fecc, _agggb)
				}
			}
		}
		if len(_fecc) == 0 {
			return []rangeIndex{}
		}
		_gebf = _fecc[:]
	}
	return _gebf
}

// Munit is an implementation of the Excel MUNIT function that returns an
// identity matrix.
func Munit(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0055\u004eIT\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073 \u006fn\u0065 \u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069\u006e\u0070\u0075\u0074")
	}
	_beabc := args[0].AsNumber()
	if _beabc.Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0055\u004eIT\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073 \u006fn\u0065 \u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069\u006e\u0070\u0075\u0074")
	}
	_fefag := int(_beabc.ValueNumber)
	_fbbgd := make([][]Result, 0, _fefag)
	for _cedaf := 0; _cedaf < _fefag; _cedaf++ {
		_bgefd := make([]Result, _fefag)
		for _aaab := 0; _aaab < _fefag; _aaab++ {
			if _cedaf == _aaab {
				_bgefd[_aaab] = MakeNumberResult(1.0)
			} else {
				_bgefd[_aaab] = MakeNumberResult(0.0)
			}
		}
		_fbbgd = append(_fbbgd, _bgefd)
	}
	return MakeArrayResult(_fbbgd)
}

// Coupncd implements the Excel COUPNCD function.
func Coupncd(args []Result) Result {
	_eebcg, _gfd := _dccda(args, "\u0043O\u0055\u0050\u004e\u0043\u0044")
	if _gfd.Type == ResultTypeError {
		return _gfd
	}
	_fce := _fae(_eebcg._ggbd)
	_aec := _fae(_eebcg._eedd)
	_gfde := _eebcg._ecf
	_abg := _aacd(_fce, _aec, _gfde)
	_deef, _gffa, _cae := _abg.Date()
	return MakeNumberResult(_acb(_deef, int(_gffa), _cae))
}

const _gefbd = 57353

var (
	_fabd  = 0
	_adgdg = false
)

const _ded = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002f\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u002f\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

var _eccf = [...]int{123, -1000, -1000, 74, 163, 103, 163, 163, -1000, -1000, -1000, -1000, 163, -1000, -1000, -1000, -1000, -1000, -12, 106, -1000, -1000, 143, -1000, -1000, -1000, -1000, -1000, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 74, 163, 163, 6, -28, 74, -15, -15, 60, 10, -14, -1000, -1000, -1000, 7, -1000, 74, -15, -15, -23, -23, -1000, -8, -8, -8, -8, -8, -8, -4, 33, -1000, 163, 163, -1000, -1000, 10, -1000, 163, -1000, -28, 74, -1000, -1000, 74}

// String returns a string representation of a named range.
func (_ebfgc NamedRangeRef) String() string { return _ebfgc._bdggc }

// Tbillyield implements the Excel TBILLYIELD function.
func Tbillyield(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0059\u0049E\u004c\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_bcbde, _dcaaa, _addf := _dfd(args[0], args[1], "\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044")
	if _addf.Type == ResultTypeError {
		return _addf
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0064\u0069\u0073\u0063\u006f\u0075n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bega := _dcaaa - _bcbde
	if _bega > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004cY\u0049\u0045\u004c\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020t\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079e\u0061\u0072\u0020\u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_dabb := args[2].ValueNumber
	if _dabb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020p\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fcaf := (100 - _dabb) / _dabb
	_ceac := 360 / _bega
	return MakeNumberResult(_fcaf * _ceac)
}

// Ddb implements the Excel DDB function.
func Ddb(args []Result) Result {
	_aaga := len(args)
	if _aaga != 4 && _aaga != 5 {
		return MakeErrorResult("\u0044\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fdgf := args[0].ValueNumber
	if _fdgf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044B \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 co\u0073t \u0074\u006f\u0020\u0062\u0065\u0020\u006eon\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gbde := args[1].ValueNumber
	if _gbde < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gagca := args[2].ValueNumber
	if _gagca <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cecg := args[3].ValueNumber
	if _cecg < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0070\u0065\u0072i\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065")
	}
	if _cecg > _gagca {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072i\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0044\u0042")
	}
	_cccc := 2.0
	if _aaga == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_cccc = args[4].ValueNumber
		if _cccc < 0 {
			return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
		}
	}
	return MakeNumberResult(_eddf(_fdgf, _gbde, _gagca, _cecg, _cccc))
}

const _gebb = 57373

func _fea(_fadg, _febg float64, _bbd int) (float64, Result) {
	_ddfg, _eed := _fae(_fadg), _fae(_febg)
	_fde := _ddfg.Unix()
	_abda := _eed.Unix()
	if _fde == _abda {
		return 0, _ffe
	}
	_acg, _aag, _bccg := _ddfg.Date()
	_efec, _aae, _eaee := _eed.Date()
	_daa, _fed := int(_aag), int(_aae)
	var _ccgb, _eede float64
	switch _bbd {
	case 0:
		if _bccg == 31 {
			_bccg--
		}
		if _bccg == 30 && _eaee == 31 {
			_eaee--
		} else if _babd := _dfa(_acg); _daa == 2 && ((_babd && _bccg == 29) || (!_babd && _bccg == 28)) {
			_bccg = 30
			if _efgf := _dfa(_efec); _fed == 2 && ((_efgf && _eaee == 29) || (!_efgf && _eaee == 28)) {
				_eaee = 30
			}
		}
		_ccgb = float64((_efec-_acg)*360 + (_fed-_daa)*30 + (_eaee - _bccg))
		_eede = 360
	case 1:
		_ccgb = _febg - _fadg
		_eefd := _acg != _efec
		if _eefd && (_efec != _acg+1 || _daa < _fed || (_daa == _fed && _bccg < _eaee)) {
			_cdc := 0
			for _bgfe := _acg; _bgfe <= _efec; _bgfe++ {
				_cdc += _ebab(_bgfe, 1)
			}
			_eede = float64(_cdc) / float64(_efec-_acg+1)
		} else {
			if !_eefd && _dfa(_acg) {
				_eede = 366
			} else {
				if _eefd && ((_dfa(_acg) && (_daa < 2 || (_daa == 2 && _bccg <= 29))) || (_dfa(_efec) && (_fed > 2 || (_fed == 2 && _eaee == 29)))) {
					_eede = 366
				} else {
					_eede = 365
				}
			}
		}
	case 2:
		_ccgb = _febg - _fadg
		_eede = 360
	case 3:
		_ccgb = _febg - _fadg
		_eede = 365
	case 4:
		if _bccg == 31 {
			_bccg--
		}
		if _eaee == 31 {
			_eaee--
		}
		_ccgb = float64((_efec-_acg)*360 + (_fed-_daa)*30 + (_eaee - _bccg))
		_eede = 360
	default:
		return 0, MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073 \u0066o\u0072\u0020\u0059\u0065\u0061\u0072\u0046r\u0061\u0063")
	}
	return _ccgb / _eede, _ffe
}

// Update returns the same object as updating sheet references does not affect named ranges.
func (_fabfc NamedRangeRef) Update(q *_cc.UpdateQuery) Expression { return _fabfc }

func (_cfbg *yyParserImpl) Lookahead() int { return _cfbg._gafef }

const (
	BinOpTypeUnknown BinOpType = iota
	BinOpTypePlus
	BinOpTypeMinus
	BinOpTypeMult
	BinOpTypeDiv
	BinOpTypeExp
	BinOpTypeLT
	BinOpTypeGT
	BinOpTypeEQ
	BinOpTypeLEQ
	BinOpTypeGEQ
	BinOpTypeNE
	BinOpTypeConcat
)

// String returns a string representation of String.
func (_gegbd String) String() string { return "\u0022" + _gegbd._abace + "\u0022" }

// Indirect is an implementation of the Excel INDIRECT function that returns the
// contents of a cell.
func Indirect(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 && len(args) != 2 {
		return MakeErrorResult("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u006f\u0072 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_eacb := args[0].AsString()
	if _eacb.Type != ResultTypeString {
		return MakeErrorResult("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069r\u0073t\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066 \u0074\u0079\u0070\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	return ctx.Cell(_eacb.ValueString, ev)
}

// Yielddisc implements the Excel YIELDDISC function.
func Yielddisc(args []Result) Result {
	_ebgbf := len(args)
	if _ebgbf != 4 && _ebgbf != 5 {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_cdaeb, _acga, _bdbea := _dfd(args[0], args[1], "\u0059I\u0045\u004c\u0044\u0044\u0049\u0053C")
	if _bdbea.Type == ResultTypeError {
		return _bdbea
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0044\u0049S\u0043\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_acaa := args[2].ValueNumber
	if _acaa <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0049E\u004c\u0044\u0044\u0049\u0053C\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_afaf := args[3].ValueNumber
	if _afaf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "YI\u0045\u004cD\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076e\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072g\u0075m\u0065\u006et")
	}
	_gagd := 0
	if _ebgbf == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0059\u0049E\u004c\u0044\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_gagd = int(args[4].ValueNumber)
		if !_cfee(_gagd) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0059I\u0045\u004cD\u0044\u0049\u0053\u0043")
		}
	}
	_abgb, _bdbea := _fea(_cdaeb, _acga, _gagd)
	if _bdbea.Type == ResultTypeError {
		return _bdbea
	}
	return MakeNumberResult((_afaf/_acaa - 1) / _abgb)
}

// Rept is an implementation of the Excel REPT function that returns n copies of
// a string.
func Rept(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("R\u0045\u0050\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	_bgfb := args[0].AsString()
	if _bgfb.Type != ResultTypeString {
		return MakeErrorResult("\u0050R\u004f\u0050E\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_agcd := args[1].AsNumber()
	if _agcd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052O\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	if _agcd.ValueNumber < 0 {
		return MakeErrorResult("\u0050\u0052\u004fP\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074o\u0020\u0062\u0065\u0020\u003e\u003d\u0020\u0030")
	}
	if _agcd.ValueNumber == 0 {
		return MakeStringResult("")
	}
	_afacf := _d.Buffer{}
	for _beeb := 0; _beeb < int(_agcd.ValueNumber); _beeb++ {
		_afacf.WriteString(_bgfb.ValueString)
	}
	return MakeStringResult(_afacf.String())
}

// MakeBoolResult constructs a boolean result (internally a number).
func MakeBoolResult(b bool) Result {
	if b {
		return Result{Type: ResultTypeNumber, ValueNumber: 1, IsBoolean: true}
	}
	return Result{Type: ResultTypeNumber, ValueNumber: 0, IsBoolean: true}
}

func _eb() evCache {
	_gfg := evCache{}
	_gfg._cda = make(map[string]Result)
	_gfg._deag = &_f.Mutex{}
	return _gfg
}

// Eval evaluates the binary expression using the context given.
func (_fbe BinaryExpr) String() string {
	_aac := ""
	switch _fbe._dd {
	case BinOpTypePlus:
		_aac = "\u002b"
	case BinOpTypeMinus:
		_aac = "\u002d"
	case BinOpTypeMult:
		_aac = "\u002a"
	case BinOpTypeDiv:
		_aac = "\u002f"
	case BinOpTypeExp:
		_aac = "\u005e"
	case BinOpTypeLT:
		_aac = "\u003c"
	case BinOpTypeGT:
		_aac = "\u003e"
	case BinOpTypeEQ:
		_aac = "\u003d"
	case BinOpTypeLEQ:
		_aac = "\u003c\u003d"
	case BinOpTypeGEQ:
		_aac = "\u003e\u003d"
	case BinOpTypeNE:
		_aac = "\u003c\u003e"
	case BinOpTypeConcat:
		_aac = "\u0026"
	}
	return _fbe._age.String() + _aac + _fbe._bd.String()
}

func _cdgd(_faefb Result, _edec *criteriaParsed) bool {
	_ggaa := _ee.ToLower(_faefb.ValueString)
	_cbff := _edec._eeac._fbffg
	_bgce := _edec._eeac._fffea
	if _cbff == _cgef {
		return _ggaa == _bgce || _ag.Match(_bgce, _ggaa)
	}
	if _faefb.Type != ResultTypeEmpty {
		if _ggaa == _edec._ebaec || _ag.Match(_edec._ebaec, _ggaa) {
			return true
		}
		if _, _eagd := _ff.ParseFloat(_bgce, 64); _eagd == nil {
			return false
		}
		switch _cbff {
		case _cabdg:
			return _ggaa <= _bgce
		case _adcef:
			return _ggaa >= _bgce
		case _cfab:
			return _ggaa < _bgce
		case _baegf:
			return _ggaa > _bgce
		}
	}
	return false
}

// VerticalRange is a range expression that when evaluated returns a list of Results from references like AA:IJ (all cells from columns AA to IJ).
type VerticalRange struct{ _efdad, _ddbe string }

var _egda = []ri{{1000, "\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {95, "\u0056\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

var _befd = [...]int{0}

// Value is an implementation of the Excel VALUE function.
func Value(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0056\u0041\u004c\u0055\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020a\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cdee := args[0]
	if _cdee.Type == ResultTypeNumber {
		return _cdee
	}
	if _cdee.Type == ResultTypeString {
		_egfa, _bgbba := _ff.ParseFloat(_cdee.Value(), 64)
		if _bgbba == nil {
			return MakeNumberResult(_egfa)
		}
	}
	return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0056\u0041L\u0055\u0045")
}

// Upper is an implementation of the Excel UPPER function that returns a upper
// case version of a string.
func Upper(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0055\u0050\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gdbee := args[0].AsString()
	if _gdbee.Type != ResultTypeString {
		return MakeErrorResult("\u0055\u0050\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeStringResult(_ee.ToUpper(_gdbee.ValueString))
}

// Replace is an implementation of the Excel REPLACE().
func Replace(args []Result) Result {
	_eabe, _ddfdf := _cfced("\u0052E\u0050\u004c\u0041\u0043\u0045", args)
	if _ddfdf.Type != ResultTypeEmpty {
		return _ddfdf
	}
	_dbbad := _eabe._ddcce
	_dbeee := _eabe._ebaa
	_ecebga := _eabe._gcdcf
	_dfaa := _eabe._baef
	_eefdd := len(_dbbad)
	if _dbeee > _eefdd {
		_dbeee = _eefdd
	}
	_abbea := _dbeee + _ecebga
	if _abbea > _eefdd {
		_abbea = _eefdd
	}
	_geafe := _dbbad[0:_dbeee] + _dfaa + _dbbad[_abbea:]
	return MakeStringResult(_geafe)
}

func _bbfbe(_bfea, _bdgd []float64, _ccab float64) float64 {
	_fcfg := _ccab + 1
	_afdg := 0.0
	_bea := len(_bfea)
	_dged := _bdgd[0]
	for _daac := 1; _daac < _bea; _daac++ {
		_cded := (_bdgd[_daac] - _dged) / 365
		_afdg -= _cded * _bfea[_daac] / _dc.Pow(_fcfg, _cded+1)
	}
	return _afdg
}

const (
	_ byte = iota
	_cgef
	_cabdg
	_adcef
	_cfab
	_baegf
)

type tokenType int

const _gaafa = 57356

// Vdb implements the Excel VDB function.
func Vdb(args []Result) Result {
	_gdag := len(args)
	if _gdag < 5 || _gdag > 7 {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0062\u0065\u0074\u0077\u0065\u0065\u006e\u0020\u0066\u0069\u0076\u0065\u0020a\u006e\u0064\u0020\u0073\u0065v\u0065\u006e")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_agac := args[0].ValueNumber
	if _agac < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044B \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 co\u0073t \u0074\u006f\u0020\u0062\u0065\u0020\u006eon\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fbcd := args[1].ValueNumber
	if _fbcd < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fdfd := args[2].ValueNumber
	if _fdfd == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if _fdfd < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("V\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0074\u0061\u0072\u0074 p\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cgbbf := args[3].ValueNumber
	if _cgbbf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065\u0073\u0073\u0020\u0074h\u0061n\u0020\u006f\u006e\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056D\u0042\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0065\u006e\u0064 \u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gcgc := args[4].ValueNumber
	if _cgbbf > _gcgc {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020s\u0074\u0061\u0072\u0074\u0020\u0070\u0065r\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0056\u0044\u0042")
	}
	if _gcgc > _fdfd {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0065\u006e\u0064\u0020\u0070e\u0072i\u006f\u0064\u0020\u0066\u006f\u0072\u0020V\u0044\u0042")
	}
	_aagae := 2.0
	if _gdag > 5 {
		if args[5].Type == ResultTypeEmpty {
			_aagae = 0.0
		} else {
			if args[5].Type != ResultTypeNumber {
				return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
			}
			_aagae = args[5].ValueNumber
			if _aagae < 0 {
				return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
			}
		}
	}
	_eagb := false
	if _gdag > 6 && args[6].Type != ResultTypeEmpty {
		if args[6].Type != ResultTypeNumber {
			return MakeErrorResult("\u0056D\u0042\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020n\u006f\u005f\u0073\u0077\u0069\u0074\u0063\u0068\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
		}
		_eagb = args[6].ValueNumber != 0
	}
	_dfdc := 0.0
	_fcec := _dc.Floor(_cgbbf)
	_fcad := _dc.Ceil(_gcgc)
	if _eagb {
		for _fbbg := _fcec + 1; _fbbg <= _fcad; _fbbg++ {
			_bfcae := _eddf(_agac, _fbcd, _fdfd, _fbbg, _aagae)
			if _fbbg == _fcec+1 {
				_bfcae *= _dc.Min(_gcgc, _fcec+1) - _cgbbf
			} else if _fbbg == _fcad {
				_bfcae *= _gcgc + 1 - _fcad
			}
			_dfdc += _bfcae
		}
	} else {
		_fgff := _fdfd
		var _becg float64
		if !_gbcc(_cgbbf, _dc.Floor(_cgbbf)) {
			if _aagae == 1 {
				_dacfa := _fdfd / 2
				if _cgbbf > _dacfa || _gbcc(_cgbbf, _dacfa) {
					_becg = _cgbbf - _dacfa
					_cgbbf = _dacfa
					_gcgc -= _becg
					_fgff++
				}
			}
		}
		if _aagae != 0 {
			_agac -= _dabd(_agac, _fbcd, _fdfd, _fgff, _cgbbf, _aagae)
		}
		_dfdc = _dabd(_agac, _fbcd, _fdfd, _fdfd-_cgbbf, _gcgc-_cgbbf, _aagae)
	}
	return MakeNumberResult(_dfdc)
}

// Now is an implementation of the Excel NOW() function.
func Now(args []Result) Result {
	if len(args) > 0 {
		return MakeErrorResult("\u004e\u004fW\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_babb := _ce.Now()
	_, _ffad := _babb.Zone()
	_bba := _fff + float64(_babb.Unix()+int64(_ffad))/86400
	return MakeNumberResult(_bba)
}

// HasFormula returns FALSE for the invalid reference context.
func (_afda *ivr) HasFormula(cellRef string) bool { return false }

// NewPrefixRangeExpr constructs a new range with prefix.
func NewPrefixRangeExpr(pfx, from, to Expression) Expression { return PrefixRangeExpr{pfx, from, to} }

// NewEmptyExpr constructs a new empty expression.
func NewEmptyExpr() Expression { return EmptyExpr{} }

// Or is an implementation of the Excel OR() function and takes a variable
// number of arguments.
func Or(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004f\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u006f\u006e\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dbcc := false
	for _, _eeea := range args {
		switch _eeea.Type {
		case ResultTypeList, ResultTypeArray:
			_cabe := Or(_eeea.ListValues())
			if _cabe.Type == ResultTypeError {
				return _cabe
			}
			if _cabe.ValueNumber != 0 {
				_dbcc = true
			}
		case ResultTypeNumber:
			if _eeea.ValueNumber != 0 {
				_dbcc = true
			}
		case ResultTypeString:
			return MakeErrorResult("\u004f\u0052 \u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u0065\u0020\u006f\u006e\u0020\u0073\u0074\u0072in\u0067\u0073")
		case ResultTypeError:
			return _eeea
		default:
			return MakeErrorResult("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u004f\u0052")
		}
	}
	return MakeBoolResult(_dbcc)
}

func _eca(_gdf BinOpType, _bdf [][]Result, _af Result) Result {
	_gaa := [][]Result{}
	for _ccgg := range _bdf {
		_ecb := _ecaf(_gdf, _bdf[_ccgg], _af)
		if _ecb.Type == ResultTypeError {
			return _ecb
		}
		_gaa = append(_gaa, _ecb.ValueList)
	}
	return MakeArrayResult(_gaa)
}

// Floor is an implementation of the FlOOR function.
func Floor(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_bccc := args[0].AsNumber()
	if _bccc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	var _fcff float64
	_cfagd := args[1].AsNumber()
	if _cfagd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_fcff = _cfagd.ValueNumber
	if _fcff < 0 && _bccc.ValueNumber >= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0046L\u004f\u004f\u0052")
	}
	_cdgg := _bccc.ValueNumber
	_cdgg, _eagea := _dc.Modf(_cdgg / _fcff)
	if _eagea != 0 {
		if _bccc.ValueNumber < 0 && _eagea < 0 {
			_cdgg--
		}
	}
	return MakeNumberResult(_cdgg * _fcff)
}

func (_ddbad node) String() string {
	return _c.Sprintf("\u007b%\u0073\u0020\u0025\u0073\u007d", _ddbad._faaa, _egedb(string(_ddbad._acccf)))
}

func _dccda(_fcdb []Result, _bbda string) (*couponArgs, Result) {
	_acab := len(_fcdb)
	if _acab != 3 && _acab != 4 {
		return nil, MakeErrorResult(_bbda + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u0066o\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_cgba, _egcg, _gfeca := _dfd(_fcdb[0], _fcdb[1], _bbda)
	if _gfeca.Type == ResultTypeError {
		return nil, _gfeca
	}
	if _fcdb[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_bbda + "\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gdff := _fcdb[2].ValueNumber
	if !_bccga(_gdff) {
		return nil, MakeErrorResult("\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0065q\u0075\u0065\u006e\u0063\u0079\u0020\u0066\u006f\u0072\u0020" + _bbda)
	}
	_dfde := 0
	if _acab == 4 && _fcdb[3].Type != ResultTypeEmpty {
		if _fcdb[3].Type != ResultTypeNumber {
			return nil, MakeErrorResult(_bbda + "\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_dfde = int(_fcdb[3].ValueNumber)
		if !_cfee(_dfde) {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020"+_bbda)
		}
	}
	return &couponArgs{_cgba, _egcg, int(_gdff), _dfde}, _ffe
}

// SumProduct is an implementation of the Excel SUMPRODUCT() function.
func SumProduct(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004f\u0044U\u0043\u0054\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bfdcf := args[0].Type
	for _, _gcedg := range args {
		if _gcedg.Type != _bfdcf {
			return MakeErrorResult("\u0053\u0055M\u0050\u0052\u004f\u0044\u0055C\u0054\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006c\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u006f\u0066\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065\u0020\u0074\u0079\u0070\u0065")
		}
	}
	switch _bfdcf {
	case ResultTypeNumber:
		return Product(args)
	case ResultTypeList, ResultTypeArray:
		_edfgc := len(args[0].ListValues())
		_fagg := make([]float64, _edfgc)
		for _dacbf := range _fagg {
			_fagg[_dacbf] = 1.0
		}
		for _, _bfgca := range args {
			if len(_bfgca.ListValues()) != _edfgc {
				return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004f\u0044\u0055\u0043\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069re\u0073 \u0061\u006c\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074s\u0020\u0074\u006f\u0020\u0068\u0061\u0076\u0065\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065 \u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006f\u006e")
			}
			for _bbbdg, _bgag := range _bfgca.ListValues() {
				_bgag = _bgag.AsNumber()
				if _bgag.Type != ResultTypeNumber {
					return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004fD\u0055\u0043\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006c\u006c\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020n\u0075m\u0065\u0072\u0069\u0063")
				}
				_fagg[_bbbdg] = _fagg[_bbbdg] * _bgag.ValueNumber
			}
		}
		_effff := 0.0
		for _, _fdfa := range _fagg {
			_effff += _fdfa
		}
		return MakeNumberResult(_effff)
	}
	return MakeNumberResult(1.0)
}

// Reference returns an invalid reference for FunctionCall.
func (_gfecf FunctionCall) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Combin is an implementation of the Excel COMBINA function whic returns the
// number of combinations.
func Combin(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004d\u0042\u0049\u004e\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cbbe := args[0].AsNumber()
	_fbada := args[1].AsNumber()
	if _cbbe.Type != ResultTypeNumber || _fbada.Type != ResultTypeNumber {
		return MakeErrorResult("C\u004f\u004d\u0042\u0049\u004e\u0028)\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_ebdb := _dc.Trunc(_cbbe.ValueNumber)
	_gccde := _dc.Trunc(_fbada.ValueNumber)
	if _gccde > _ebdb {
		return MakeErrorResult("\u0043O\u004d\u0042\u0049\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006b\u0020\u003c\u003d\u0020\u006e")
	}
	if _gccde == _ebdb || _gccde == 0 {
		return MakeNumberResult(1)
	}
	_bcbf := float64(1)
	for _cfedf := float64(1); _cfedf <= _gccde; _cfedf++ {
		_bcbf *= (_ebdb + 1 - _cfedf) / _cfedf
	}
	return MakeNumberResult(_bcbf)
}

// PrefixRangeExpr is a range expression that when evaluated returns a list of Results from a given sheet like Sheet1!A1:B4 (all cells from A1 to B4 from a sheet 'Sheet1').
type PrefixRangeExpr struct{ _cgegf, _gaga, _dbaf Expression }

// Reference returns a string reference value to a cell.
func (_fad CellRef) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeCell, Value: _fad._bda}
}

// Eval evaluates and returns the result of the cell reference.
func (_db CellRef) Eval(ctx Context, ev Evaluator) Result { return ctx.Cell(_db._bda, ev) }

// SetLocked does nothing for the invalid reference context.
func (_bgacf *ivr) SetLocked(cellRef string, locked bool) {}

var _afd = []*_gf.Regexp{}

// IsBool returns false for the invalid reference context.
func (_dbege *ivr) IsBool(cellRef string) bool { return false }

// Reference returns a string reference value to a horizontal range with prefix.
func (_bebde PrefixHorizontalRange) Reference(ctx Context, ev Evaluator) Reference {
	_gcdb := _bebde._eegae.Reference(ctx, ev)
	return Reference{Type: ReferenceTypeHorizontalRange, Value: _bebde.horizontalRangeReference(_gcdb.Value)}
}

func _fae(_cfd float64) _ce.Time {
	_ggf := int64((_cfd - _fff) * _bbf)
	return _ce.Unix(0, _ggf).UTC()
}

// String returns a string representation of a horizontal range with prefix.
func (_dedgc PrefixHorizontalRange) String() string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0064\u003a\u0025\u0064", _dedgc._eegae.String(), _dedgc._gfad, _dedgc._cfaf)
}

func _ecbad(_cbda int) bool { return _cbda == 0 || _cbda == 4 }

// MakeStringResult constructs a string result.
func MakeStringResult(s string) Result { return Result{Type: ResultTypeString, ValueString: s} }

// Median implements the MEDIAN function that returns the median of a range of
// values.
func Median(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004d\u0045D\u0049\u0041\u004e\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020l\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gdeg := _gfag(args)
	_a.Float64s(_gdeg)
	var _gfeb float64
	if len(_gdeg)%2 == 0 {
		_gfeb = (_gdeg[len(_gdeg)/2-1] + _gdeg[len(_gdeg)/2]) / 2
	} else {
		_gfeb = _gdeg[len(_gdeg)/2]
	}
	return MakeNumberResult(_gfeb)
}

func _egaa(_baaea Result, _daeeg *criteriaParsed) bool {
	if _baaea.IsBoolean {
		return false
	}
	_deaec := _baaea.Type
	if _daeeg._eaebd {
		return _deaec == ResultTypeNumber && _baaea.ValueNumber == _daeeg._cbga
	} else if _deaec == ResultTypeNumber {
		return _ecfc(_baaea.ValueNumber, _daeeg._eeac)
	}
	return _cdgd(_baaea, _daeeg)
}

// String is a string expression.
type String struct{ _abace string }

var InvalidReferenceContext = &ivr{}

// Eval evaluates and returns the result of an empty expression.
func (_cbd EmptyExpr) Eval(ctx Context, ev Evaluator) Result { return MakeEmptyResult() }

// Eomonth is an implementation of the Excel EOMONTH() function.
func Eomonth(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u004f\u004d\u004f\u004e\u0054\u0048\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	_cad := args[1].ValueNumber
	_gege := args[0]
	var _gddf float64
	switch _gege.Type {
	case ResultTypeEmpty:
		_gddf = 0
	case ResultTypeNumber:
		_gddf = _gege.ValueNumber
	case ResultTypeString:
		_ccb := DateValue([]Result{args[0]})
		if _ccb.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
		}
		_gddf = _ccb.ValueNumber
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	_dbdf := _fae(_gddf)
	_dcce := _dbdf.AddDate(0, int(_cad+1), 0)
	_aba, _dcg, _ := _dcce.Date()
	_bag := _acb(_aba, int(_dcg), 0)
	if _bag < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	if _aba == 1900 && _dcg == 3 {
		_bag--
	}
	return MakeNumberResult(_bag)
}

// ISODD is an implementation of the Excel ISODD() function.
func IsOdd(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u004f\u0044\u0044\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u004f\u0044\u0044\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061 \u006eu\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eaff := int(args[0].ValueNumber)
	return MakeBoolResult(_eaff != _eaff/2*2)
}

func _efab(_agef string) bool {
	for _, _bgc := range _cdd {
		_dfe := _bgc.FindStringSubmatch(_agef)
		if len(_dfe) > 1 {
			return true
		}
	}
	return false
}

// Pmt implements the Excel PMT function.
func Pmt(args []Result) Result {
	_abbec := len(args)
	if _abbec < 3 || _abbec > 5 {
		return MakeErrorResult("\u0050\u004dT\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u0020\u0035")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_beab := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004dT\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_egef := args[1].ValueNumber
	if _egef == 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u00200")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065\u006e\u0074 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_acgb := args[2].ValueNumber
	_fdcb := 0.0
	if _abbec >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("P\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0075\u0074\u0075\u0072e \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_fdcb = args[3].ValueNumber
	}
	_adec := 0.0
	if _abbec == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0079\u0070\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_adec = args[4].ValueNumber
		if _adec != 0 {
			_adec = 1
		}
	}
	var _ebge float64
	if _beab == 0 {
		_ebge = (_acgb + _fdcb) / _egef
	} else {
		_egge := _dc.Pow(1+_beab, _egef)
		if _adec == 1 {
			_ebge = (_fdcb*_beab/(_egge-1) + _acgb*_beab/(1-1/_egge)) / (1 + _beab)
		} else {
			_ebge = _fdcb*_beab/(_egge-1) + _acgb*_beab/(1-1/_egge)
		}
	}
	return MakeNumberResult(-_ebge)
}

func _fe(_fb BinOpType, _aa, _cfc []Result) Result {
	_dca := []Result{}
	for _eae := range _aa {
		_ad := _aa[_eae].AsNumber()
		_fgc := _cfc[_eae].AsNumber()
		if _ad.Type != ResultTypeNumber || _fgc.Type != ResultTypeNumber {
			return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
		}
		switch _fb {
		case BinOpTypePlus:
			_dca = append(_dca, MakeNumberResult(_ad.ValueNumber+_fgc.ValueNumber))
		case BinOpTypeMinus:
			_dca = append(_dca, MakeNumberResult(_ad.ValueNumber-_fgc.ValueNumber))
		case BinOpTypeMult:
			_dca = append(_dca, MakeNumberResult(_ad.ValueNumber*_fgc.ValueNumber))
		case BinOpTypeDiv:
			if _fgc.ValueNumber == 0 {
				return MakeErrorResultType(ErrorTypeDivideByZero, "")
			}
			_dca = append(_dca, MakeNumberResult(_ad.ValueNumber/_fgc.ValueNumber))
		case BinOpTypeExp:
			_dca = append(_dca, MakeNumberResult(_dc.Pow(_ad.ValueNumber, _fgc.ValueNumber)))
		case BinOpTypeLT:
			_dca = append(_dca, MakeBoolResult(_ad.ValueNumber < _fgc.ValueNumber))
		case BinOpTypeGT:
			_dca = append(_dca, MakeBoolResult(_ad.ValueNumber > _fgc.ValueNumber))
		case BinOpTypeEQ:
			_dca = append(_dca, MakeBoolResult(_ad.ValueNumber == _fgc.ValueNumber))
		case BinOpTypeLEQ:
			_dca = append(_dca, MakeBoolResult(_ad.ValueNumber <= _fgc.ValueNumber))
		case BinOpTypeGEQ:
			_dca = append(_dca, MakeBoolResult(_ad.ValueNumber >= _fgc.ValueNumber))
		case BinOpTypeNE:
			_dca = append(_dca, MakeBoolResult(_ad.ValueNumber != _fgc.ValueNumber))
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _fb))
		}
	}
	return MakeListResult(_dca)
}

// Month is an implementation of the Excel MONTH() function.
func Month(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("M\u004f\u004e\u0054\u0048\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006ee\u0020\u0061\u0072g\u0075m\u0065\u006e\u0074")
	}
	_be := args[0]
	switch _be.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(1)
	case ResultTypeNumber:
		_bfa := _fae(_be.ValueNumber)
		return MakeNumberResult(float64(_bfa.Month()))
	case ResultTypeString:
		_efag := _ee.ToLower(_be.ValueString)
		if !_aabb(_efag) {
			_, _, _, _, _edd, _ebgb := _ffge(_efag)
			if _ebgb.Type == ResultTypeError {
				_ebgb.ErrorMessage = "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u004dON\u0054\u0048"
				return _ebgb
			}
			if _edd {
				return MakeNumberResult(1)
			}
		}
		_, _eba, _, _, _ebf := _dfb(_efag)
		if _ebf.Type == ResultTypeError {
			return _ebf
		}
		return MakeNumberResult(float64(_eba))
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004d\u004fN\u0054\u0048")
	}
}

// Reference returns a string reference value to a range.
func (_eaeac Range) Reference(ctx Context, ev Evaluator) Reference {
	_dgca := _eaeac._eadcf.Reference(ctx, ev)
	_bcfdc := _eaeac._dfbgf.Reference(ctx, ev)
	if _dgca.Type == ReferenceTypeCell && _bcfdc.Type == ReferenceTypeCell {
		return MakeRangeReference(_ddbfg(_dgca, _bcfdc))
	}
	return ReferenceInvalid
}

// Disc implements the Excel DISC function.
func Disc(args []Result) Result {
	_dcfc := len(args)
	if _dcfc != 4 && _dcfc != 5 {
		return MakeErrorResult("\u0044\u0049SC\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s f\u006fur\u0020\u006f\u0072\u0020\u0066\u0069\u0076e \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_abga, _fegb, _aaf := _dfd(args[0], args[1], "\u0044\u0049\u0053\u0043")
	if _aaf.Type == ResultTypeError {
		return _aaf
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_aege := args[2].ValueNumber
	if _aege <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0072\u0020\u0074o \u0062\u0065\u0020\u0070o\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0049S\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bbdb := args[3].ValueNumber
	if _bbdb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0049\u0053\u0043\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0072e\u0064\u0065m\u0070\u0074\u0069\u006f\u006e\u0020t\u006f b\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bbdg := 0
	if _dcfc == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0049\u0053\u0043\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_bbdg = int(args[4].ValueNumber)
		if !_cfee(_bbdg) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0066\u006f\u0072 \u0044\u0049\u0053\u0043")
		}
	}
	_fbbf, _aaf := _fea(_abga, _fegb, _bbdg)
	if _aaf.Type == ResultTypeError {
		return _aaf
	}
	return MakeNumberResult((_bbdb - _aege) / _bbdb / _fbbf)
}

type cumulArgs struct {
	_agec float64
	_ggec float64
	_cab  float64
	_efdb float64
	_gdga float64
	_bacb int
}

type criteriaRegex struct {
	_fbffg byte
	_fffea string
}

type criteriaParsed struct {
	_eaebd bool
	_cbga  float64
	_ebaec string
	_eeac  *criteriaRegex
}

type rmode byte

func _fgeb(_aeg, _faeg float64, _cadd, _edae int) float64 {
	_fcb := _fae(_aeg)
	_bcf := _fae(_faeg)
	_cbg := _dfcf(_fcb, _bcf, _cadd, _edae)
	return _gfgb(_cbg, _fcb, _edae)
}

// GetWidth returns 0 for the invalid reference context.
func (_edge *ivr) GetWidth(colIdx int) float64 { return float64(0) }

func _acfc(_aada string, _ffab []Result) (*parsedSearchObject, Result) {
	_ffce := len(_ffab)
	if _ffce != 2 && _ffce != 3 {
		return nil, MakeErrorResult(_aada + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006fr\u0020t\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_affe := _ffab[0]
	if _affe.Type == ResultTypeError {
		return nil, _affe
	}
	if _affe.Type != ResultTypeString && _affe.Type != ResultTypeNumber {
		return nil, MakeErrorResult("\u0054\u0068e\u0020\u0066\u0069\u0072s\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_ebaba := _ffab[1]
	if _ebaba.Type == ResultTypeError {
		return nil, _ebaba
	}
	if _ebaba.Type != ResultTypeString && _ebaba.Type != ResultTypeNumber {
		return nil, MakeErrorResult("\u0054\u0068\u0065\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020a\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_daabf := _ebaba.Value()
	_deca := _affe.Value()
	_cdgfg := 1
	if _ffce == 3 && _ffab[2].Type != ResultTypeEmpty {
		_dcfbc := _ffab[2]
		if _dcfbc.Type != ResultTypeNumber {
			return nil, MakeErrorResult("P\u006f\u0073\u0069\u0074\u0069\u006fn\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0061\u0020n\u0075m\u0062\u0065\u0072")
		}
		_cdgfg = int(_dcfbc.ValueNumber)
		if _cdgfg < 1 {
			return nil, MakeErrorResultType(ErrorTypeValue, "\u0050\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u0061 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074h\u0061\u006e\u0020\u0030")
		}
		if _cdgfg > len(_daabf) {
			return nil, MakeErrorResultType(ErrorTypeValue, "\u0050\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u0061 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074h\u0061\u006e\u0020\u0030")
		}
	}
	return &parsedSearchObject{_deca, _daabf, _cdgfg}, _ffe
}

// RoundUp is an implementation of the Excel ROUNDUP function that rounds a number
// up to a specified number of digits.
func RoundUp(args []Result) Result { return _ebcfc(args, _agcbg) }

// Tbilleq implements the Excel TBILLEQ function.
func Tbilleq(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020t\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dcfcf, _dbbfg, _egfe := _dfd(args[0], args[1], "\u0054B\u0049\u004c\u004c\u0045\u0051")
	if _egfe.Type == ResultTypeError {
		return _egfe
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0064is\u0063\u006f\u0075\u006et\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fefg := _dbbfg - _dcfcf
	if _fefg > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020m\u006f\u0072e\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079\u0065\u0061r \u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074t\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_gfca := args[2].ValueNumber
	if _gfca <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0045Q\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074 \u0074\u006f\u0020\u0062\u0065 p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult((365 * _gfca) / (360 - _gfca*_fefg))
}

// Oddlprice implements the Excel ODDLPRICE function.
func Oddlprice(args []Result) Result {
	if len(args) != 8 && len(args) != 9 {
		return MakeErrorResult("\u004f\u0044\u0044L\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u006e\u0069\u006e\u0065\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_bfge, _aeef, _gdgd := _dfd(args[0], args[1], "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _gdgd.Type == ResultTypeError {
		return _gdgd
	}
	_abbeb, _gdgd := _faeb(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _gdgd.Type == ResultTypeError {
		return _gdgd
	}
	if _abbeb >= _bfge {
		return MakeErrorResultType(ErrorTypeNum, "\u004c\u0061\u0073\u0074\u0020i\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0064\u0061\u0074\u0065\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074e")
	}
	_cfgd := args[3]
	if _cfgd.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cabg := _cfgd.ValueNumber
	if _cabg < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	_fbc := args[4]
	if _fbc.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0079i\u0065\u006c\u0064\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_fdae := _fbc.ValueNumber
	if _fdae < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_ebcc := args[5]
	if _ebcc.Type != ResultTypeNumber {
		return MakeErrorResult("\u004fD\u0044\u004cP\u0052\u0049\u0043\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_eefa := _ebcc.ValueNumber
	if _eefa < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_eaaa := args[6]
	if _eaaa.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049C\u0045\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_gcgg := float64(int(_eaaa.ValueNumber))
	if !_bccga(_gcgg) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_efgd := 0
	if len(args) == 8 && args[7].Type != ResultTypeEmpty {
		_ddbd := args[7]
		if _ddbd.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0062a\u0073\u0069\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
		}
		_efgd = int(_ddbd.ValueNumber)
		if !_cfee(_efgd) {
			return MakeErrorResultType(ErrorTypeNum, "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0062\u0061\u0073\u0069s\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020\u004f\u0044\u0044\u004c\u0050\u0052\u0049C\u0045")
		}
	}
	_gafga, _gdgd := _fea(_abbeb, _aeef, _efgd)
	if _gdgd.Type == ResultTypeError {
		return _gdgd
	}
	_gafga *= _gcgg
	_fbad, _gdgd := _fea(_bfge, _aeef, _efgd)
	if _gdgd.Type == ResultTypeError {
		return _gdgd
	}
	_fbad *= _gcgg
	_bcba, _gdgd := _fea(_abbeb, _bfge, _efgd)
	if _gdgd.Type == ResultTypeError {
		return _gdgd
	}
	_bcba *= _gcgg
	_cceg := _eefa + _gafga*100*_cabg/_gcgg
	_cceg /= _fbad*_fdae/_gcgg + 1
	_cceg -= _bcba * 100 * _cabg / _gcgg
	return MakeNumberResult(_cceg)
}

// Counta implements the COUNTA function.
func Counta(args []Result) Result { return MakeNumberResult(_edbeb(args, _ecaa)) }

func (_fbba *ivr) SetOffset(col, row uint32) {}

func (_ecbg *Lexer) nextRaw() *node {
	for len(_ecbg._fgcg) != 0 {
		_acccfc := <-_ecbg._fgcg[len(_ecbg._fgcg)-1]
		if _acccfc != nil {
			return _acccfc
		}
		_ecbg._fgcg = _ecbg._fgcg[0 : len(_ecbg._fgcg)-1]
	}
	return <-_ecbg._daeg
}

const _fefgc = 1

const _eacd = 16

const _bgfd = 57362

// LastEvalIsRef returns if last evaluation with the evaluator was a reference.
func (_cfcd *defEval) LastEvalIsRef() bool { return _cfcd._egb }

func _cefc(_cbgg string, _efcf func(_cefa float64) float64) Function {
	return func(_cdedc []Result) Result {
		if len(_cdedc) != 1 {
			return MakeErrorResult(_cbgg + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_bcecc := _cdedc[0].AsNumber()
		switch _bcecc.Type {
		case ResultTypeNumber:
			_bfadf := _efcf(_bcecc.ValueNumber)
			if _dc.IsNaN(_bfadf) {
				return MakeErrorResult(_cbgg + "\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0065\u0064\u0020\u004e\u0061\u004e")
			}
			if _dc.IsInf(_bfadf, 0) {
				return MakeErrorResult(_cbgg + "\u0020r\u0065t\u0075\u0072\u006e\u0065\u0064 \u0069\u006ef\u0069\u006e\u0069\u0074\u0079")
			}
			if _bfadf == 0 {
				return MakeErrorResultType(ErrorTypeDivideByZero, _cbgg+"\u0020d\u0069v\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065\u0072\u006f")
			}
			return MakeNumberResult(1 / _bfadf)
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult(_cbgg + "\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072i\u0063\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		case ResultTypeError:
			return _bcecc
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068a\u006e\u0064\u006c\u0065d\u0020\u0025\u0073\u0028\u0029\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _cbgg, _bcecc.Type))
		}
	}
}

// SumIfs implements the SUMIFS function.
func SumIfs(args []Result) Result {
	_ccccf := _gdgfe(args, true, "\u0053\u0055\u004d\u0049\u0046\u0053")
	if _ccccf.Type != ResultTypeEmpty {
		return _ccccf
	}
	_gaafc := _eabc(args[1:])
	_fgbad := 0.0
	_geffe := _cdafd(args[0])
	for _, _ggcb := range _gaafc {
		_fgbad += _geffe[_ggcb._ffaab][_ggcb._edga].ValueNumber
	}
	return MakeNumberResult(float64(_fgbad))
}

// Offset is an implementation of the Excel OFFSET function.
func Offset(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 3 && len(args) != 5 {
		return MakeErrorResult("\u004f\u0046\u0046\u0053\u0045\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0068\u0072\u0065e\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_abccb := args[0].Ref
	for _abccb.Type == ReferenceTypeNamedRange {
		_abccb = ctx.NamedRange(_abccb.Value)
	}
	_efcc := ""
	switch _abccb.Type {
	case ReferenceTypeCell:
		_efcc = _abccb.Value
	case ReferenceTypeRange:
		_aggf := _ee.Split(_abccb.Value, "\u003a")
		if len(_aggf) == 2 {
			_efcc = _aggf[0]
		}
	default:
		return MakeErrorResult(_c.Sprintf("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0069\u006e\u0020\u004f\u0046\u0046\u0053\u0045\u0054\u0028\u0029: \u0025\u0073", _abccb.Type))
	}
	_fagd, _cfac := _cb.ParseCellReference(_efcc)
	if _cfac != nil {
		return MakeErrorResult(_c.Sprintf("\u0070\u0061\u0072s\u0065\u0020\u006f\u0072i\u0067\u0069\u006e\u0020\u0065\u0072\u0072o\u0072\u0020\u004f\u0046\u0046\u0053\u0045\u0054\u0028\u0029\u003a\u0020\u0025\u0073", _cfac.Error()))
	}
	_eafda, _adebg, _cegd := _fagd.Column, _fagd.RowIdx, _fagd.SheetName
	_badag := args[1].AsNumber()
	if _badag.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0046\u0046SE\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u0075m\u0065r\u0069\u0063\u0020\u0072\u006f\u0077\u0020\u006f\u0066\u0066\u0073\u0065\u0074")
	}
	_dbee := args[2].AsNumber()
	if _dbee.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0046\u0046SE\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u0075m\u0065r\u0069\u0063\u0020\u0063\u006f\u006c\u0020\u006f\u0066\u0066\u0073\u0065\u0074")
	}
	var _bbfd, _acda Result
	if len(args) == 3 {
		_bbfd = MakeNumberResult(1)
		_acda = MakeNumberResult(1)
	} else {
		_bbfd = args[3].AsNumber()
		if _bbfd.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0046\u0046\u0053\u0045\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0068\u0065\u0069\u0067\u0068\u0074")
		}
		if _bbfd.ValueNumber == 0 {
			return MakeErrorResultType(ErrorTypeRef, "")
		}
		_acda = args[4].AsNumber()
		if _acda.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0046F\u0053\u0045\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0077id\u0074\u0068")
		}
		if _acda.ValueNumber == 0 {
			return MakeErrorResultType(ErrorTypeRef, "")
		}
	}
	_fade := _cb.ColumnToIndex(_eafda)
	_bbcg := _adebg + uint32(_badag.ValueNumber)
	_dbea := _fade + uint32(_dbee.ValueNumber)
	_cgfcc := _bbcg + uint32(_bbfd.ValueNumber)
	_ddddd := _dbea + uint32(_acda.ValueNumber)
	if _bbfd.ValueNumber > 0 {
		_cgfcc--
	} else {
		_cgfcc++
		_bbcg, _cgfcc = _cgfcc, _bbcg
	}
	if _acda.ValueNumber > 0 {
		_ddddd--
	} else {
		_ddddd++
		_dbea, _ddddd = _ddddd, _dbea
	}
	_bebb := _c.Sprintf("\u0025\u0073\u0025\u0064", _cb.IndexToColumn(_dbea), _bbcg)
	_dccef := _c.Sprintf("\u0025\u0073\u0025\u0064", _cb.IndexToColumn(_ddddd), _cgfcc)
	if _cegd == "" {
		return _efbfc(ctx, ev, _bebb, _dccef)
	} else {
		return _efbfc(ctx.Sheet(_cegd), ev, _bebb, _dccef)
	}
}

const _gbaf = 57348

func _aebcb(_dcfce Result, _acccb, _ebec int) [][]Result {
	_bbeg := [][]Result{}
	switch _dcfce.Type {
	case ResultTypeArray:
		for _cadcg, _dded := range _dcfce.ValueArray {
			if _cadcg < _acccb {
				_bbeg = append(_bbeg, _gadf(MakeListResult(_dded), _ebec))
			} else {
				_bbeg = append(_bbeg, _gadf(MakeErrorResultType(ErrorTypeNA, ""), _ebec))
			}
		}
	case ResultTypeList:
		_cddea := _gadf(_dcfce, _ebec)
		for _cdbb := 0; _cdbb < _acccb; _cdbb++ {
			_bbeg = append(_bbeg, _cddea)
		}
	case ResultTypeNumber, ResultTypeString, ResultTypeError, ResultTypeEmpty:
		for _dgda := 0; _dgda < _acccb; _dgda++ {
			_fegc := _gadf(_dcfce, _ebec)
			_bbeg = append(_bbeg, _fegc)
		}
	}
	return _bbeg
}

// Sln implements the Excel SLN function.
func Sln(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0053\u004c\u004e\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cagb := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bdde := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dbg := args[2].ValueNumber
	if _dbg == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u007a\u0065\u0072\u006f")
	}
	return MakeNumberResult((_cagb - _bdde) / _dbg)
}

var _eddb = [...]int{0, 1, 1, 2, 4, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 2, 1, 1, 1, 3, 4, 1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 2, 3, 1, 3, 1, 1, 0}

// HLookup implements the HLOOKUP function that returns a matching value from a
// row in an array.
func HLookup(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004bU\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if len(args) > 4 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0074\u0020m\u006f\u0073\u0074\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_efgdg := args[0]
	_ebae := args[1]
	if _ebae.Type != ResultTypeArray {
		return MakeErrorResult("\u0048\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_dbge := args[2].AsNumber()
	if _dbge.Type != ResultTypeNumber {
		return MakeErrorResult("\u0048\u004cO\u004f\u004b\u0055\u0050 \u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0072\u006f\u0077\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ccca := false
	if len(args) == 4 {
		_eged := args[3].AsNumber()
		if _eged.Type != ResultTypeNumber {
			return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		if _eged.ValueNumber == 0 {
			_ccca = true
		}
	}
	_efggg := -1
	_ccecd := false
	if len(_ebae.ValueArray) == 0 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u006f\u006e\u002d\u0065\u006d\u0070\u0074\u0079\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_daad := _ebae.ValueArray[0]
_cbafc:
	for _ccbc, _dfdcc := range _daad {
		switch _gdgf(_dfdcc, _efgdg, false, _ccca) {
		case _bcea:
			_efggg = _ccbc
		case _aafg:
			_efggg = _ccbc
			_ccecd = true
			break _cbafc
		}
	}
	if _efggg == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u0048\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_dgcg := int(_dbge.ValueNumber) - 1
	if _dgcg < 0 || _dgcg > len(_ebae.ValueArray) {
		return MakeErrorResult("\u0048L\u004f\u004f\u004b\u0055P\u0020\u0068\u0061\u0064\u0020i\u006ev\u0061l\u0069\u0064\u0020\u0069\u006e\u0064\u0065x")
	}
	_daad = _ebae.ValueArray[_dgcg]
	if _efggg < 0 || _efggg >= len(_daad) {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0063\u006f\u006c\u0075\u006d\u006e\u0020\u0069\u006e\u0064\u0065\u0078")
	}
	if _ccecd || !_ccca {
		return _daad[_efggg]
	}
	return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
}

func _gbdgg(_ebaaf, _eeff int) string {
	const TOKSTART = 4
	if !_adgdg {
		return "\u0073\u0079\u006et\u0061\u0078\u0020\u0065\u0072\u0072\u006f\u0072"
	}
	for _, _dcff := range _ddddbe {
		if _dcff._fafgc == _ebaaf && _dcff._bgfbg == _eeff {
			return "\u0073\u0079\u006e\u0074\u0061\u0078\u0020\u0065\u0072r\u006f\u0072\u003a\u0020" + _dcff._dbagf
		}
	}
	_geac := "\u0073y\u006e\u0074\u0061\u0078 \u0065\u0072\u0072\u006f\u0072:\u0020u\u006ee\u0078\u0070\u0065\u0063\u0074\u0065\u0064 " + _ffdeg(_eeff)
	_aeeg := make([]int, 0, 4)
	_cggef := _eccf[_ebaaf]
	for _gdaeb := TOKSTART; _gdaeb-1 < len(_fefab); _gdaeb++ {
		if _gfagg := _cggef + _gdaeb; _gfagg >= 0 && _gfagg < _daabe && _adbea[_aabgb[_gfagg]] == _gdaeb {
			if len(_aeeg) == cap(_aeeg) {
				return _geac
			}
			_aeeg = append(_aeeg, _gdaeb)
		}
	}
	if _ccee[_ebaaf] == -2 {
		_ggacf := 0
		for _egeea[_ggacf] != -1 || _egeea[_ggacf+1] != _ebaaf {
			_ggacf += 2
		}
		for _ggacf += 2; _egeea[_ggacf] >= 0; _ggacf += 2 {
			_aeggf := _egeea[_ggacf]
			if _aeggf < TOKSTART || _egeea[_ggacf+1] == 0 {
				continue
			}
			if len(_aeeg) == cap(_aeeg) {
				return _geac
			}
			_aeeg = append(_aeeg, _aeggf)
		}
		if _egeea[_ggacf+1] != 0 {
			return _geac
		}
	}
	for _dbgb, _adddd := range _aeeg {
		if _dbgb == 0 {
			_geac += "\u002c\u0020\u0065x\u0070\u0065\u0063\u0074\u0069\u006e\u0067\u0020"
		} else {
			_geac += "\u0020\u006f\u0072\u0020"
		}
		_geac += _ffdeg(_adddd)
	}
	return _geac
}

var _gcde = [...]int{0, 7, 3, 3, 3, 8, 8, 8, 8, 1, 1, 1, 2, 2, 2, 2, 2, 14, 15, 15, 17, 17, 4, 4, 4, 13, 5, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, 9, 9, 16, 16, 11, 10, 10}

// If is an implementation of the Excel IF() function. It takes one, two or
// three arguments.
func If(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0049\u0046\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u006f\u006e\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0049\u0046\u0020ac\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0074\u0020m\u006fs\u0074 \u0074h\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_ccecb := args[0]
	switch _ccecb.Type {
	case ResultTypeError:
		return _ccecb
	case ResultTypeNumber:
		if len(args) == 1 {
			return MakeBoolResult(_ccecb.ValueNumber != 0)
		}
		if _ccecb.ValueNumber != 0 {
			return args[1]
		}
		if len(args) == 3 {
			return args[2]
		} else {
			return MakeBoolResult(false)
		}
	case ResultTypeList:
		return _gdad(args)
	case ResultTypeArray:
		return _gbea(args)
	default:
		return MakeErrorResult("\u0049F\u0020\u0069n\u0069\u0074\u0069\u0061l\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u006d\u0075\u0073t \u0062\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u006f\u0072 \u0061\u0072r\u0061\u0079")
	}
}

// Update returns the same object as updating sheet references does not affect Number.
func (_cfgbd Number) Update(q *_cc.UpdateQuery) Expression { return _cfgbd }

// String returns a string representation of SheetPrefixExpr.
func (_eegf SheetPrefixExpr) String() string { return _eegf._edaee }

// Syd implements the Excel SYD function.
func Syd(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("S\u0059\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072 \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_edada := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dcda := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ccabb := args[2].ValueNumber
	if _ccabb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ddaf := args[3].ValueNumber
	if _ddaf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070e\u0072i\u006fd\u0020t\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if _ddaf > _ccabb {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0065q\u0075\u0061\u006c\u0020\u006f\u0072\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068a\u006e \u006c\u0069\u0066\u0065")
	}
	_dbdb := (_edada - _dcda) * (_ccabb - _ddaf + 1) * 2
	_bacd := _ccabb * (_ccabb + 1)
	return MakeNumberResult(_dbdb / _bacd)
}

func (_gfbeb *yyParserImpl) Parse(yylex yyLexer) int {
	var _dbec int
	var _fcfac yySymType
	var _bcdag []yySymType
	_ = _bcdag
	_dbgaa := _gfbeb._gbead[:]
	Nerrs := 0
	Errflag := 0
	_acbcg := 0
	_gfbeb._gafef = -1
	_cbcc := -1
	defer func() { _acbcg = -1; _gfbeb._gafef = -1; _cbcc = -1 }()
	_ggdac := -1
	goto _aaabb
_gcgf:
	return 0
_fcdfc:
	return 1
_aaabb:
	if _fabd >= 4 {
		_c.Printf("\u0063\u0068\u0061\u0072\u0020\u0025\u0076\u0020\u0069n\u0020\u0025\u0076\u000a", _ffdeg(_cbcc), _ecec(_acbcg))
	}
	_ggdac++
	if _ggdac >= len(_dbgaa) {
		_gbege := make([]yySymType, len(_dbgaa)*2)
		copy(_gbege, _dbgaa)
		_dbgaa = _gbege
	}
	_dbgaa[_ggdac] = _fcfac
	_dbgaa[_ggdac]._gbae = _acbcg
_fbaec:
	_dbec = _eccf[_acbcg]
	if _dbec <= _dfga {
		goto _eadaf
	}
	if _gfbeb._gafef < 0 {
		_gfbeb._gafef, _cbcc = _cdfdb(yylex, &_gfbeb._dgacb)
	}
	_dbec += _cbcc
	if _dbec < 0 || _dbec >= _daabe {
		goto _eadaf
	}
	_dbec = _aabgb[_dbec]
	if _adbea[_dbec] == _cbcc {
		_gfbeb._gafef = -1
		_cbcc = -1
		_fcfac = _gfbeb._dgacb
		_acbcg = _dbec
		if Errflag > 0 {
			Errflag--
		}
		goto _aaabb
	}
_eadaf:
	_dbec = _ccee[_acbcg]
	if _dbec == -2 {
		if _gfbeb._gafef < 0 {
			_gfbeb._gafef, _cbcc = _cdfdb(yylex, &_gfbeb._dgacb)
		}
		_baaa := 0
		for {
			if _egeea[_baaa+0] == -1 && _egeea[_baaa+1] == _acbcg {
				break
			}
			_baaa += 2
		}
		for _baaa += 2; ; _baaa += 2 {
			_dbec = _egeea[_baaa+0]
			if _dbec < 0 || _dbec == _cbcc {
				break
			}
		}
		_dbec = _egeea[_baaa+1]
		if _dbec < 0 {
			goto _gcgf
		}
	}
	if _dbec == 0 {
		switch Errflag {
		case 0:
			yylex.Error(_gbdgg(_acbcg, _cbcc))
			Nerrs++
			if _fabd >= 1 {
				_c.Printf("\u0025\u0073", _ecec(_acbcg))
				_c.Printf("\u0020\u0073\u0061\u0077\u0020\u0025\u0073\u000a", _ffdeg(_cbcc))
			}
			fallthrough
		case 1, 2:
			Errflag = 3
			for _ggdac >= 0 {
				_dbec = _eccf[_dbgaa[_ggdac]._gbae] + _effd
				if _dbec >= 0 && _dbec < _daabe {
					_acbcg = _aabgb[_dbec]
					if _adbea[_acbcg] == _effd {
						goto _aaabb
					}
				}
				if _fabd >= 2 {
					_c.Printf("\u0065\u0072r\u006f\u0072\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u0070\u006f\u0070\u0073\u0020\u0073\u0074\u0061\u0074\u0065 %\u0064\u000a", _dbgaa[_ggdac]._gbae)
				}
				_ggdac--
			}
			goto _fcdfc
		case 3:
			if _fabd >= 2 {
				_c.Printf("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u0064\u0069s\u0063\u0061\u0072d\u0073 \u0025\u0073\u000a", _ffdeg(_cbcc))
			}
			if _cbcc == _fefgc {
				goto _fcdfc
			}
			_gfbeb._gafef = -1
			_cbcc = -1
			goto _fbaec
		}
	}
	if _fabd >= 2 {
		_c.Printf("\u0072e\u0064u\u0063\u0065\u0020\u0025\u0076 \u0069\u006e:\u000a\u0009\u0025\u0076\u000a", _dbec, _ecec(_acbcg))
	}
	_gfabg := _dbec
	_bgeb := _ggdac
	_ = _bgeb
	_ggdac -= _eddb[_dbec]
	if _ggdac+1 >= len(_dbgaa) {
		_dgcd := make([]yySymType, len(_dbgaa)*2)
		copy(_dgcd, _dbgaa)
		_dbgaa = _dgcd
	}
	_fcfac = _dbgaa[_ggdac+1]
	_dbec = _gcde[_dbec]
	_fagb := _fgeed[_dbec]
	_cagcf := _fagb + _dbgaa[_ggdac]._gbae + 1
	if _cagcf >= _daabe {
		_acbcg = _aabgb[_fagb]
	} else {
		_acbcg = _aabgb[_cagcf]
		if _adbea[_acbcg] != -_dbec {
			_acbcg = _aabgb[_fagb]
		}
	}
	switch _gfabg {
	case 1:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			yylex.(*plex)._deddc = _fcfac._aagaec
		}
	case 3:
		_bcdag = _dbgaa[_bgeb-2 : _bgeb+1]
		{
			_fcfac._aagaec = _bcdag[2]._aagaec
		}
	case 4:
		_bcdag = _dbgaa[_bgeb-4 : _bgeb+1]
		{
		}
	case 5:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewBool(_bcdag[1]._dfcfe._acccf)
		}
	case 6:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewNumber(_bcdag[1]._dfcfe._acccf)
		}
	case 7:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewString(_bcdag[1]._dfcfe._acccf)
		}
	case 8:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewError(_bcdag[1]._dfcfe._acccf)
		}
	case 9:
		_bcdag = _dbgaa[_bgeb-2 : _bgeb+1]
		{
			_fcfac._aagaec = _bcdag[2]._aagaec
		}
	case 10:
		_bcdag = _dbgaa[_bgeb-2 : _bgeb+1]
		{
			_fcfac._aagaec = NewNegate(_bcdag[2]._aagaec)
		}
	case 15:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = _bcdag[2]._aagaec
		}
	case 17:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewConstArrayExpr(_bcdag[2]._aead)
		}
	case 18:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aead = append(_fcfac._aead, _bcdag[1]._efaac)
		}
	case 19:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aead = append(_bcdag[1]._aead, _bcdag[3]._efaac)
		}
	case 20:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._efaac = append(_fcfac._efaac, _bcdag[1]._aagaec)
		}
	case 21:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._efaac = append(_bcdag[1]._efaac, _bcdag[3]._aagaec)
		}
	case 23:
		_bcdag = _dbgaa[_bgeb-2 : _bgeb+1]
		{
			_fcfac._aagaec = NewPrefixExpr(_bcdag[1]._aagaec, _bcdag[2]._aagaec)
		}
	case 25:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewSheetPrefixExpr(_bcdag[1]._dfcfe._acccf)
		}
	case 26:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewCellRef(_bcdag[1]._dfcfe._acccf)
		}
	case 27:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewRange(_bcdag[1]._aagaec, _bcdag[3]._aagaec)
		}
	case 28:
		_bcdag = _dbgaa[_bgeb-4 : _bgeb+1]
		{
			_fcfac._aagaec = NewPrefixRangeExpr(_bcdag[1]._aagaec, _bcdag[2]._aagaec, _bcdag[4]._aagaec)
		}
	case 29:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewNamedRangeRef(_bcdag[1]._dfcfe._acccf)
		}
	case 30:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewHorizontalRange(_bcdag[1]._dfcfe._acccf)
		}
	case 31:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._aagaec = NewVerticalRange(_bcdag[1]._dfcfe._acccf)
		}
	case 32:
		_bcdag = _dbgaa[_bgeb-2 : _bgeb+1]
		{
			_fcfac._aagaec = NewPrefixHorizontalRange(_bcdag[1]._aagaec, _bcdag[2]._dfcfe._acccf)
		}
	case 33:
		_bcdag = _dbgaa[_bgeb-2 : _bgeb+1]
		{
			_fcfac._aagaec = NewPrefixVerticalRange(_bcdag[1]._aagaec, _bcdag[2]._dfcfe._acccf)
		}
	case 34:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypePlus, _bcdag[3]._aagaec)
		}
	case 35:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeMinus, _bcdag[3]._aagaec)
		}
	case 36:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeMult, _bcdag[3]._aagaec)
		}
	case 37:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeDiv, _bcdag[3]._aagaec)
		}
	case 38:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeExp, _bcdag[3]._aagaec)
		}
	case 39:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeLT, _bcdag[3]._aagaec)
		}
	case 40:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeGT, _bcdag[3]._aagaec)
		}
	case 41:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeLEQ, _bcdag[3]._aagaec)
		}
	case 42:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeGEQ, _bcdag[3]._aagaec)
		}
	case 43:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeEQ, _bcdag[3]._aagaec)
		}
	case 44:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeNE, _bcdag[3]._aagaec)
		}
	case 45:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewBinaryExpr(_bcdag[1]._aagaec, BinOpTypeConcat, _bcdag[3]._aagaec)
		}
	case 47:
		_bcdag = _dbgaa[_bgeb-2 : _bgeb+1]
		{
			_fcfac._aagaec = NewFunction(_bcdag[1]._dfcfe._acccf, nil)
		}
	case 48:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._aagaec = NewFunction(_bcdag[1]._dfcfe._acccf, _bcdag[2]._efaac)
		}
	case 49:
		_bcdag = _dbgaa[_bgeb-1 : _bgeb+1]
		{
			_fcfac._efaac = append(_fcfac._efaac, _bcdag[1]._aagaec)
		}
	case 50:
		_bcdag = _dbgaa[_bgeb-3 : _bgeb+1]
		{
			_fcfac._efaac = append(_bcdag[1]._efaac, _bcdag[3]._aagaec)
		}
	case 53:
		_bcdag = _dbgaa[_bgeb-0 : _bgeb+1]
		{
			_fcfac._aagaec = NewEmptyExpr()
		}
	}
	goto _aaabb
}

// Degrees is an implementation of the Excel function DEGREES() that converts
// radians to degrees.
func Degrees(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0044\u0045\u0047R\u0045\u0045\u0053\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cecf := args[0].AsNumber()
	if _cecf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0045\u0047RE\u0045\u0053\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u006eu\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(180.0 / _dc.Pi * _cecf.ValueNumber)
}

func _dfa(_eda int) bool {
	if _eda == _eda/400*400 {
		return true
	}
	if _eda == _eda/100*100 {
		return false
	}
	return _eda == _eda/4*4
}

// Radians is an implementation of the Excel function RADIANS() that converts
// degrees to radians.
func Radians(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0052\u0041\u0044I\u0041\u004e\u0053\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_agdd := args[0].AsNumber()
	if _agdd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0044IA\u004e\u0053\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u006eu\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(_dc.Pi / 180.0 * _agdd.ValueNumber)
}

func _acb(_gdb, _cbb, _cgc int) float64 {
	return float64(_gcad(_gdb, _ce.Month(_cbb), _cgc)/86400) + _fff
}

type Expression interface {
	Eval(_eac Context, _dbb Evaluator) Result
	Reference(_gbc Context, _ggb Evaluator) Reference
	String() string
	Update(_dbfd *_cc.UpdateQuery) Expression
}

func MakeRangeReference(ref string) Reference {
	return Reference{Type: ReferenceTypeRange, Value: ref}
}

// Substitute is an implementation of the Excel SUBSTITUTE function.
func Substitute(args []Result) Result {
	_fegg := len(args)
	if _fegg != 3 && _fegg != 4 {
		return MakeErrorResult("\u0053\u0055\u0042\u0053\u0054\u0049\u0054U\u0054\u0045\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dcgg, _abdc := _cffgb(args[0], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u0074\u0065\u0078\u0074")
	if _abdc.Type == ResultTypeError {
		return _abdc
	}
	_gcadad, _abdc := _cffgb(args[1], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u006f\u006c\u0064\u0020\u0074\u0065\u0078\u0074")
	if _abdc.Type == ResultTypeError {
		return _abdc
	}
	_cfgb, _abdc := _cffgb(args[2], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u006e\u0065\u0077\u0020\u0074\u0065\u0078\u0074")
	if _abdc.Type == ResultTypeError {
		return _abdc
	}
	_fafbd := 0
	if _fegg == 3 {
		return MakeStringResult(_ee.Replace(_dcgg, _gcadad, _cfgb, -1))
	} else {
		_gafe, _cegb := _bfdgd(args[3], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u0069\u006e\u0073t\u0061\u006e\u0063\u0065\u005f\u006e\u0075\u006d")
		if _cegb.Type == ResultTypeError {
			return _cegb
		}
		_fafbd = int(_gafe)
		if _fafbd < 1 {
			return MakeErrorResult("\u0069\u006es\u0074\u0061\u006e\u0063e\u005f\u006eu\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e \u007a\u0065\u0072\u006f")
		}
		_gdffg := _dcgg
		_addag := _fafbd
		_eedc := -1
		_ddec := len(_gcadad)
		_ceecac := 0
		for {
			_addag--
			_ecab := _ee.Index(_gdffg, _gcadad)
			if _ecab == -1 {
				_eedc = -1
				break
			} else {
				_eedc = _ecab + _ceecac
				if _addag == 0 {
					break
				}
				_fdecd := _ddec + _ecab
				_ceecac += _fdecd
				_gdffg = _gdffg[_fdecd:]
			}
		}
		if _eedc == -1 {
			return MakeStringResult(_dcgg)
		} else {
			_cdbd := _dcgg[:_eedc]
			_cbef := _dcgg[_eedc+_ddec:]
			return MakeStringResult(_cdbd + _cfgb + _cbef)
		}
	}
}

// Time is an implementation of the Excel TIME() function.
func Time(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0049ME\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0068re\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_gbdb := args[0].ValueNumber
	_bcd := args[1].ValueNumber
	_bbfb := args[2].ValueNumber
	_ecae := _gdfdg(_gbdb, _bcd, _bbfb)
	if _ecae >= 0 {
		return MakeNumberResult(_ecae)
	} else {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
}

// Accrintm implements the Excel ACCRINTM function.
func Accrintm(args []Result) Result {
	_dcaa := len(args)
	if _dcaa != 4 && _dcaa != 5 {
		return MakeErrorResult("A\u0043\u0043\u0052\u0049\u004e\u0054\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066o\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_gbgg, _bbg := _faeb(args[0], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d")
	if _bbg.Type == ResultTypeError {
		return _bbg
	}
	_dafc, _bbg := _faeb(args[1], "\u0073e\u0074t\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065", "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d")
	if _bbg.Type == ResultTypeError {
		return _bbg
	}
	if _gbgg >= _dafc {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0073\u0073\u0075\u0065\u0020d\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0065\u0061\u0072\u006c\u0069\u0065r\u0020\u0074\u0068\u0061\u006e\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065n\u0074 \u0064\u0061\u0074\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0041C\u0043\u0052I\u004e\u0054\u004d\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_gef := args[2].ValueNumber
	if _gef <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061t\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0041\u0043\u0043\u0052\u0049\u004e\u0054M\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0070\u0061\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dgfdc := args[3].ValueNumber
	if _dgfdc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u0043C\u0052\u0049\u004e\u0054\u004d \u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0061\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cdfb := 0
	if _dcaa == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0041C\u0043\u0052I\u004e\u0054\u004d \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_cdfb = int(args[4].ValueNumber)
		if !_cfee(_cdfb) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0041\u0043\u0043R\u0049\u004e\u0054\u004d")
		}
	}
	_ebbb, _bbg := _fea(_gbgg, _dafc, _cdfb)
	if _bbg.Type == ResultTypeError {
		return _bbg
	}
	return MakeNumberResult(_dgfdc * _gef * _ebbb)
}

// NewFunction constructs a new function call expression.
func NewFunction(name string, args []Expression) Expression { return FunctionCall{name, args} }

func (_ab BinOpType) String() string {
	if _ab >= BinOpType(len(_fcfe)-1) {
		return _c.Sprintf("\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029", _ab)
	}
	return _fcf[_fcfe[_ab]:_fcfe[_ab+1]]
}

type yyLexer interface {
	Lex(_ffadf *yySymType) int
	Error(_cacgd string)
}

func (_bbdec *noCache) GetFromCache(key string) (Result, bool) { return _ffe, false }

func _gdgfe(_dedb []Result, _afdfed bool, _dedg string) Result {
	var _gagcc, _aace string
	if _afdfed {
		_gagcc = "\u0074\u0068\u0072e\u0065"
		_aace = "\u006f\u0064\u0064"
	} else {
		_gagcc = "\u0074\u0077\u006f"
		_aace = "\u0065\u0076\u0065\u006e"
	}
	_fbfa := len(_dedb)
	if (_afdfed && _fbfa < 3) || (!_afdfed && _fbfa < 2) {
		return MakeErrorResult(_dedg + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020" + _gagcc + " \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0073")
	}
	if (_fbfa/2*2 == _fbfa) == _afdfed {
		return MakeErrorResult(_dedg + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _aace + " \u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020a\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_gbda := -1
	_ffag := -1
	for _ecdg := 0; _ecdg < _fbfa; _ecdg += 2 {
		_abagc := _dedb[_ecdg]
		if _abagc.Type != ResultTypeArray && _abagc.Type != ResultTypeList {
			return MakeErrorResult(_dedg + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u006e\u0067\u0065\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065 \u006c\u0069\u0073\u0074\u0020o\u0072\u0020a\u0072\u0072\u0061\u0079")
		}
		_dbdeb := _cdafd(_abagc)
		if _ffag == -1 {
			_ffag = len(_dbdeb)
			_gbda = len(_dbdeb[0])
		} else if len(_dbdeb) != _ffag || len(_dbdeb[0]) != _gbda {
			return MakeErrorResult(_dedg + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0061l\u006c\u0020\u0072\u0061n\u0067\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065\u0020\u0073\u0069\u007a\u0065")
		}
		if _afdfed && _ecdg == 0 {
			_ecdg--
		}
	}
	return _ffe
}

// FactDouble is an implementation of the excel FACTDOUBLE function which
// returns the double factorial of a positive numeric input.
func FactDouble(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0046\u0041C\u0054\u0044\u004f\u0055\u0042\u004c\u0045\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_facdd := args[0].AsNumber()
	if _facdd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0041C\u0054\u0044\u004f\u0055\u0042\u004c\u0045\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _facdd.ValueNumber < 0 {
		return MakeErrorResult("\u0046A\u0043\u0054D\u004f\u0055\u0042\u004cE\u0028\u0029\u0020a\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006f\u006ely\u0020\u0070\u006fs\u0069\u0074i\u0076\u0065\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_gbcd := float64(1)
	_agcb := _dc.Trunc(_facdd.ValueNumber)
	for _acdbd := _agcb; _acdbd > 1; _acdbd -= 2 {
		_gbcd *= _acdbd
	}
	return MakeNumberResult(_gbcd)
}

// Int is an implementation of the Excel INT() function that rounds a number
// down to an integer.
func Int(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("I\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_edaab := args[0].AsNumber()
	if _edaab.Type != ResultTypeNumber {
		return MakeErrorResult("I\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_acage, _bbbd := _dc.Modf(_edaab.ValueNumber)
	if _bbbd < 0 {
		_acage--
	}
	return MakeNumberResult(_acage)
}

type rangeIndex struct {
	_ffaab int
	_edga  int
}

// Db implements the Excel DB function.
func Db(args []Result) Result {
	_dagd := len(args)
	if _dagd != 4 && _dagd != 5 {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u006f\u0072 \u0066\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0063\u006f\u0073\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dbcg := args[0].ValueNumber
	if _dbcg < 0 {
		return MakeErrorResultType(ErrorTypeNum, "D\u0042\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0063\u006fs\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ffgd := args[1].ValueNumber
	if _ffgd < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069\u0066\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cca := args[2].ValueNumber
	if _cca <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006c\u0069\u0066\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("D\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_dbeg := args[3].ValueNumber
	if _dbeg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	if _dbeg-_cca > 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0042")
	}
	_fgcaf := 12.0
	if _dagd == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006do\u006e\u0074\u0068\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_fgcaf = args[4].ValueNumber
		if _fgcaf < 1 || _fgcaf > 12 {
			return MakeErrorResultType(ErrorTypeNum, "\u0044B\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u006do\u006e\u0074\u0068\u0020\u0074\u006f\u0020\u0062\u0065 i\u006e\u0020\u0072a\u006e\u0067e\u0020\u006f\u0066\u0020\u0031\u0020a\u006e\u0064 \u0031\u0032")
		}
	}
	if _fgcaf == 12 && _dbeg > _cca {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0042")
	}
	if _ffgd >= _dbcg {
		return MakeNumberResult(0)
	}
	_aef := 1 - _dc.Pow(_ffgd/_dbcg, 1/_cca)
	_aef = float64(int(_aef*1000+0.5)) / 1000
	_dgbe := _dbcg * _aef * _fgcaf / 12
	if _dbeg == 1 {
		return MakeNumberResult(_dgbe)
	}
	_gacf := _dgbe
	_eaea := 0.0
	_faba := _cca
	if _faba > _dbeg {
		_faba = _dbeg
	}
	for _ddabd := 2.0; _ddabd <= _faba; _ddabd++ {
		_eaea = (_dbcg - _gacf) * _aef
		_gacf += _eaea
	}
	if _dbeg > _cca {
		return MakeNumberResult((_dbcg - _gacf) * _aef * (12 - _fgcaf) / 12)
	}
	return MakeNumberResult(_eaea)
}

var _ccf int64 = _gcad(1900, _ce.January, 1)

func _bfdgd(_bebbc Result, _fdcg, _acfb string) (float64, Result) {
	switch _bebbc.Type {
	case ResultTypeEmpty:
		return 0, _ffe
	case ResultTypeNumber:
		return _bebbc.ValueNumber, _ffe
	case ResultTypeString:
		_fedf, _cbdaf := _ff.ParseFloat(_bebbc.ValueString, 64)
		if _cbdaf != nil {
			return 0, MakeErrorResult(_acfb + "\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020" + _fdcg)
		}
		return _fedf, _ffe
	default:
		return 0, MakeErrorResult(_fdcg + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _acfb + "\u0020t\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0065\u006d\u0070\u0074\u0079")
	}
}

func (_caag PrefixVerticalRange) verticalRangeReference(_cdbed string) string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _cdbed, _caag._bgcag, _caag._gadad)
}

// MakeErrorResultType makes an error result of a given type with a specified
// debug message
func MakeErrorResultType(t ErrorType, msg string) Result {
	switch t {
	case ErrorTypeNull:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0055\u004c\u004c\u0021", ErrorMessage: msg}
	case ErrorTypeValue:
		return Result{Type: ResultTypeError, ValueString: "\u0023V\u0041\u004c\u0055\u0045\u0021", ErrorMessage: msg}
	case ErrorTypeRef:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u0052\u0045F\u0021", ErrorMessage: msg}
	case ErrorTypeName:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0041\u004d\u0045\u003f", ErrorMessage: msg}
	case ErrorTypeNum:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0055M\u0021", ErrorMessage: msg}
	case ErrorTypeSpill:
		return Result{Type: ResultTypeError, ValueString: "\u0023S\u0050\u0049\u004c\u004c\u0021", ErrorMessage: msg}
	case ErrorTypeNA:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u002f\u0041", ErrorMessage: msg}
	case ErrorTypeDivideByZero:
		return Result{Type: ResultTypeError, ValueString: "\u0023D\u0049\u0056\u002f\u0030\u0021", ErrorMessage: msg}
	default:
		return Result{Type: ResultTypeError, ValueString: "\u0023V\u0041\u004c\u0055\u0045\u0021", ErrorMessage: msg}
	}
}

// ISEVEN is an implementation of the Excel ISEVEN() function.
func IsEven(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u0045VE\u004e\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070t\u0073 \u0061 \u0073i\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0045\u0056\u0045\u004e \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_aeca := int(args[0].ValueNumber)
	return MakeBoolResult(_aeca == _aeca/2*2)
}

// NewNamedRangeRef constructs a new named range reference.
func NewNamedRangeRef(v string) Expression { return NamedRangeRef{v} }

func _egedb(_acbf string) string {
	_acbf = _ee.Replace(_acbf, "\u000a", "\u005c\u006e", -1)
	_acbf = _ee.Replace(_acbf, "\u000d", "\u005c\u0072", -1)
	_acbf = _ee.Replace(_acbf, "\u0009", "\u005c\u0074", -1)
	return _acbf
}

var _fff float64 = 25569.0

func _gdfbf(_fggbf, _dba Result, _dafcf string) (*xargs, Result) {
	if _fggbf.Type != ResultTypeList && _fggbf.Type != ResultTypeArray {
		return nil, MakeErrorResult(_dafcf + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0076\u0061lue\u0073 t\u006f\u0020\u0062\u0065\u0020\u006f\u0066 a\u0072\u0072\u0061\u0079\u0020\u0074\u0079p\u0065")
	}
	_gacd := _cdafd(_fggbf)
	_acf := []float64{}
	for _, _eada := range _gacd {
		for _, _gcff := range _eada {
			if _gcff.Type == ResultTypeNumber && !_gcff.IsBoolean {
				_acf = append(_acf, _gcff.ValueNumber)
			} else {
				return nil, MakeErrorResult(_dafcf + "\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0073")
			}
		}
	}
	_agab := len(_acf)
	if len(_acf) < 2 {
		return nil, MakeErrorResultType(ErrorTypeNum, "")
	}
	if _dba.Type != ResultTypeList && _dba.Type != ResultTypeArray {
		return nil, MakeErrorResult(_dafcf + " \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0064\u0061\u0074\u0065s\u0020\u0074\u006f\u0020\u0062\u0065\u0020o\u0066\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0074\u0079p\u0065")
	}
	_ffbe := _cdafd(_dba)
	_dace := []float64{}
	_agce := 0.0
	for _, _fccb := range _ffbe {
		for _, _cfed := range _fccb {
			if _cfed.Type == ResultTypeNumber && !_cfed.IsBoolean {
				_dgc := float64(int(_cfed.ValueNumber))
				if _dgc < _agce {
					return nil, MakeErrorResultType(ErrorTypeNum, _dafcf+" \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0061\u0074\u0065\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u0069\u006e\u0020\u0061\u0073\u0063\u0065\u006edi\u006e\u0067\u0020o\u0072d\u0065\u0072")
				}
				_dace = append(_dace, _dgc)
				_agce = _dgc
			} else {
				return nil, MakeErrorResult(_dafcf + "\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0064\u0061\u0074\u0065\u0073\u0020t\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0073")
			}
		}
	}
	if len(_dace) != _agab {
		return nil, MakeErrorResultType(ErrorTypeNum, "")
	}
	return &xargs{_acf, _dace}, MakeEmptyResult()
}

func (_gdae *evCache) SetCache(key string, value Result) {
	_gdae._deag.Lock()
	_gdae._cda[key] = value
	_gdae._deag.Unlock()
}

// String returns a string representation of ConstArrayExpr.
func (_gbb ConstArrayExpr) String() string { return "" }

// HorizontalRange is a range expression that when evaluated returns a list of Results from references like 1:4 (all cells from rows 1 to 4).
type HorizontalRange struct{ _ddgg, _aabf int }

// LookupFunctionComplex looks up and returns a complex function or nil.
func LookupFunctionComplex(name string) FunctionComplex {
	_fafbc.Lock()
	defer _fafbc.Unlock()
	if _ffced, _fdbe := _bedfa[name]; _fdbe {
		return _ffced
	}
	return nil
}

// NewPrefixExpr constructs an expression with prefix.
func NewPrefixExpr(pfx, exp Expression) Expression { return &PrefixExpr{pfx, exp} }

const _eggd = _dae + "\u0020\u0028\u0028[0\u002d\u0039\u005d\u0029\u002b\u0029\u002c\u0020\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

func (_gdaacg *plex) Lex(lval *yySymType) int {
	_adgdg = true
	_fecf := <-_gdaacg._cecgd
	if _fecf != nil {
		lval._dfcfe = _fecf
		return int(lval._dfcfe._faaa)
	}
	return 0
}

// FunctionCall is a function call expression.
type FunctionCall struct {
	_fbae string
	_agff []Expression
}

var _cdd = []*_gf.Regexp{}

// Mod is an implementation of the Excel MOD function which returns the
// remainder after division. It requires two numeric argumnts.
func Mod(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004d\u004fD(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0074wo\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_bcff := args[0].AsNumber()
	_fdcbg := args[1].AsNumber()
	if _bcff.Type != ResultTypeNumber || _fdcbg.Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u004fD(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0074wo\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	if _fdcbg.ValueNumber == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "M\u004fD\u0028\u0029\u0020\u0064\u0069\u0076\u0069\u0064e\u0020\u0062\u0079\u0020ze\u0072\u006f")
	}
	_bcde, _dedf := _dc.Modf(_bcff.ValueNumber / _fdcbg.ValueNumber)
	if _dedf < 0 {
		_bcde--
	}
	return MakeNumberResult(_bcff.ValueNumber - _fdcbg.ValueNumber*_bcde)
}

type couponArgs struct {
	_ggbd  float64
	_eedd  float64
	_ecf   int
	_deagf int
}

func _bacc(_fbbd []Result, _aaaa bool) Result {
	_aabed := "\u004d\u0041\u0058"
	if _aaaa {
		_aabed = "\u004d\u0041\u0058\u0041"
	}
	if len(_fbbd) == 0 {
		return MakeErrorResult(_aabed + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061s\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gaae := -_dc.MaxFloat64
	for _, _fcga := range _fbbd {
		switch _fcga.Type {
		case ResultTypeNumber:
			if (_aaaa || !_fcga.IsBoolean) && _fcga.ValueNumber > _gaae {
				_gaae = _fcga.ValueNumber
			}
		case ResultTypeList, ResultTypeArray:
			_debf := _bacc(_fcga.ListValues(), _aaaa)
			if _debf.ValueNumber > _gaae {
				_gaae = _debf.ValueNumber
			}
		case ResultTypeEmpty:
		case ResultTypeString:
			_bcdd := 0.0
			if _aaaa {
				_bcdd = _fcga.AsNumber().ValueNumber
			}
			if _bcdd > _gaae {
				_gaae = _bcdd
			}
		default:
			_ge.Log("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020"+_aabed+"\u0028\u0029\u0020\u0061rg\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _fcga.Type)
		}
	}
	if _gaae == -_dc.MaxFloat64 {
		_gaae = 0
	}
	return MakeNumberResult(_gaae)
}

// Dollarde implements the Excel DOLLARDE function.
func Dollarde(args []Result) Result {
	_ddbf, _dffg, _eff := _cffd(args, "\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045")
	if _eff.Type == ResultTypeError {
		return _eff
	}
	if _dffg < 1 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072a\u0063t\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u006f\u0072 \u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0031")
	}
	if _ddbf == 0 {
		return MakeNumberResult(0)
	}
	_gfgf := _ddbf < 0
	if _gfgf {
		_ddbf = -_ddbf
	}
	_egcc := args[0].Value()
	_bgda := _ee.Split(_egcc, "\u002e")
	_cbaf := float64(int(_ddbf))
	_bgab := _bgda[1]
	_bbaa := len(_bgab)
	_ggdc := int(_dc.Log10(_dffg)) + 1
	_gga := float64(_ggdc - _bbaa)
	_ggeg, _becd := _ff.ParseFloat(_bgab, 64)
	if _becd != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006fr \u0044\u004f\u004cL\u0041R\u0044\u0045")
	}
	_ggeg *= _dc.Pow(10, _gga)
	_bgef := _cbaf + _ggeg/_dffg
	if _gfgf {
		_bgef = -_bgef
	}
	return MakeNumberResult(_bgef)
}

// Reference returns an invalid reference for BinaryExpr.
func (_fg BinaryExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

func _cdafd(_bcffb Result) [][]Result {
	switch _bcffb.Type {
	case ResultTypeArray:
		return _bcffb.ValueArray
	case ResultTypeList:
		return [][]Result{_bcffb.ValueList}
	default:
		return [][]Result{}
	}
}

const _bcbbe int = 30

var _aabgb = [...]int{45, 3, 44, 32, 18, 40, 72, 46, 47, 30, 31, 32, 39, 48, 28, 29, 30, 31, 32, 75, 39, 49, 32, 56, 50, 70, 23, 39, 76, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 77, 71, 69, 54, 43, 13, 19, 21, 55, 82, 11, 78, 9, 74, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 1, 20, 39, 10, 2, 8, 0, 80, 79, 0, 0, 0, 83, 0, 81, 73, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 0, 0, 39, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 26, 27, 39, 51, 52, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 23, 12, 0, 6, 7, 26, 27, 0, 42, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 5, 0, 12, 0, 6, 7, 26, 27, 0, 4, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 0, 12, 53, 6, 7, 26, 27, 0, 0, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 0, 12, 0, 6, 7}

// CeilingPrecise is an implementation of the CEILING.PRECISE function which
// returns the ceiling of a number.
func CeilingPrecise(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002eP\u0052\u0045\u0043IS\u0045\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0043\u0045I\u004c\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_gggef := args[0].AsNumber()
	if _gggef.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069r\u0073\u0074\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ebde := float64(1)
	if _gggef.ValueNumber < 0 {
		_ebde = -1
	}
	if len(args) > 1 {
		_ccdbg := args[1].AsNumber()
		if _ccdbg.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043E\u0049L\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_ebde = _dc.Abs(_ccdbg.ValueNumber)
	}
	if len(args) == 1 {
		return MakeNumberResult(_dc.Ceil(_gggef.ValueNumber))
	}
	_ccda := _gggef.ValueNumber
	_ccda, _cdgf := _dc.Modf(_ccda / _ebde)
	if _cdgf != 0 {
		if _gggef.ValueNumber > 0 {
			_ccda++
		}
	}
	return MakeNumberResult(_ccda * _ebde)
}

const _efdc = 57361

var _egbcg []byte = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

// Eval evaluates and returns the result of a function call.
func (_cagf FunctionCall) Eval(ctx Context, ev Evaluator) Result {
	_fbeg := LookupFunction(_cagf._fbae)
	if _fbeg != nil {
		_cffgbe := make([]Result, len(_cagf._agff))
		for _bdbg, _aece := range _cagf._agff {
			_cffgbe[_bdbg] = _aece.Eval(ctx, ev)
			_cffgbe[_bdbg].Ref = _aece.Reference(ctx, ev)
		}
		return _fbeg(_cffgbe)
	}
	_fabf := LookupFunctionComplex(_cagf._fbae)
	if _fabf != nil {
		_eaaf := make([]Result, len(_cagf._agff))
		for _afcec, _gdfg := range _cagf._agff {
			_eaaf[_afcec] = _gdfg.Eval(ctx, ev)
			_eaaf[_afcec].Ref = _gdfg.Reference(ctx, ev)
		}
		return _fabf(ctx, ev, _eaaf)
	}
	return MakeErrorResult("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0066\u0075\u006e\u0063t\u0069\u006f\u006e\u0020" + _cagf._fbae)
}

// Eval evaluates a vertical range returning a list of results or an error.
func (_ggaac VerticalRange) Eval(ctx Context, ev Evaluator) Result {
	_dfff := _ggaac.verticalRangeReference()
	if _edag, _ecddd := ev.GetFromCache(_dfff); _ecddd {
		return _edag
	}
	_ecdf, _gaadf := _gfbef(ctx, _ggaac._efdad, _ggaac._ddbe)
	_afbaf := _efbfc(ctx, ev, _ecdf, _gaadf)
	ev.SetCache(_dfff, _afbaf)
	return _afbaf
}

func _gfgc(_efbf, _fcfc int) int {
	if _fcfc == 2 && _dfa(_efbf) {
		return 29
	} else {
		return _fac[_fcfc-1]
	}
}

func _eebc(_geg int) int {
	if _geg < 1900 {
		if _geg < 30 {
			_geg += 2000
		} else {
			_geg += 1900
		}
	}
	return _geg
}

func _ffd(_ga BinOpType, _cf, _bf [][]Result) Result {
	_gd := [][]Result{}
	for _ecc := range _cf {
		_fga := _fe(_ga, _cf[_ecc], _bf[_ecc])
		if _fga.Type == ResultTypeError {
			return _fga
		}
		_gd = append(_gd, _fga.ValueList)
	}
	return MakeArrayResult(_gd)
}

// Bool is a boolean expression.
type Bool struct{ _gfbd bool }

func Trunc(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("T\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061t \u006c\u0065\u0061\u0073t\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065ri\u0063\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_cefg := args[0].AsNumber()
	if _cefg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0054\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_dced := float64(0)
	if len(args) > 1 {
		_geba := args[1].AsNumber()
		if _geba.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0054\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_dced = _geba.ValueNumber
	}
	_cacd := _cefg.ValueNumber
	_feabc := 1.0
	if _dced >= 0 {
		_feabc = _dc.Pow(1/10.0, _dced)
	} else {
		return MakeNumberResult(0)
	}
	_cacd, _gddd := _dc.Modf(_cacd / _feabc)
	_ddfdg := 0.99999
	if _gddd > _ddfdg {
		_cacd++
	} else if _gddd < -_ddfdg {
		_cacd--
	}
	_ = _gddd
	return MakeNumberResult(_cacd * _feabc)
}

// Update updates references in the Negate after removing a row/column.
func (_adbc Negate) Update(q *_cc.UpdateQuery) Expression {
	return Negate{_adbc._ggbdc.Update(q)}
}

// Text is an implementation of the Excel TEXT function.
func Text(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("T\u0045\u0058\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	_gafd := args[0]
	if _gafd.Type != ResultTypeNumber && _gafd.Type != ResultTypeString && _gafd.Type != ResultTypeEmpty {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	if args[1].Type != ResultTypeString {
		return MakeErrorResult("\u0054E\u0058\u0054 \u0072\u0065\u0071\u0075i\u0072\u0065\u0073 \u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072gu\u006d\u0065\u006et\u0020\u0074o\u0020\u0062\u0065\u0020\u0061\u0020s\u0074\u0072i\u006e\u0067")
	}
	_cfff := args[1].ValueString
	switch _gafd.Type {
	case ResultTypeNumber:
		return MakeStringResult(_ca.Number(_gafd.ValueNumber, _cfff))
	case ResultTypeString:
		return MakeStringResult(_ca.String(_gafd.ValueString, _cfff))
	case ResultTypeEmpty:
		return MakeStringResult(_ca.Number(0, _cfff))
	case ResultTypeArray, ResultTypeList:
		return MakeErrorResultType(ErrorTypeSpill, "\u0054\u0045X\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0077\u006f\u0072\u006b\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u0072ra\u0079\u0073")
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020T\u0045\u0058\u0054")
	}
}

func _agdcc(_edf, _bdfab, _ebcf int) int {
	if _edf > _bdfab {
		return 0
	}
	if _ecbad(_ebcf) {
		return (_bdfab - _edf + 1) * 360
	}
	_ecba := 0
	for _gfec := _edf; _gfec <= _bdfab; _gfec++ {
		_gcfb := 365
		if _dfa(_gfec) {
			_gcfb = 366
		}
		_ecba += _gcfb
	}
	return _ecba
}

// IsDBCS returns false for the invalid reference context.
func (_gafca *ivr) IsDBCS() bool { return false }

func _abgd(_fgea float64) float64 {
	_gdfca := float64(1)
	for _ddfa := float64(2); _ddfa <= _fgea; _ddfa++ {
		_gdfca *= _ddfa
	}
	return _gdfca
}

// Pi is an implementation of the Excel Pi() function that just returns the Pi
// constant.
func Pi(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0050I\u0028\u0029\u0020\u0061c\u0063\u0065\u0070\u0074\u0073 \u006eo\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s")
	}
	return MakeNumberResult(_dc.Pi)
}

// Npv implements the Excel NPV function.
func Npv(args []Result) Result {
	_faee := len(args)
	if _faee < 2 {
		return MakeErrorResult("\u004e\u0050\u0056 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f \u006fr\u0020m\u006f\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ageb := args[0].ValueNumber
	if _ageb == -1 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_bddgb := []float64{}
	for _, _gbce := range args[1:] {
		switch _gbce.Type {
		case ResultTypeNumber:
			_bddgb = append(_bddgb, _gbce.ValueNumber)
		case ResultTypeArray, ResultTypeList:
			_dde := _cdafd(_gbce)
			for _, _cef := range _dde {
				for _, _gccf := range _cef {
					if _gccf.Type == ResultTypeNumber && !_gccf.IsBoolean {
						_bddgb = append(_bddgb, _gccf.ValueNumber)
					}
				}
			}
		}
	}
	_ggge := 0.0
	for _eadd, _feef := range _bddgb {
		_ggge += _feef / _dc.Pow(1+_ageb, float64(_eadd)+1)
	}
	return MakeNumberResult(_ggge)
}

// AsNumber attempts to intepret a string cell value as a number. Upon success,
// it returns a new number result, upon  failure it returns the original result.
// This is used as functions return strings that can then act like number (e.g.
// LEFT(1.2345,3) + LEFT(1.2345,3) = 2.4)
func (_ddffa Result) AsNumber() Result {
	if _ddffa.Type == ResultTypeString {
		_afdd, _bgegg := _ff.ParseFloat(_ddffa.ValueString, 64)
		if _bgegg == nil {
			return MakeNumberResult(_afdd)
		}
	}
	if _ddffa.Type == ResultTypeEmpty {
		return MakeNumberResult(0)
	}
	return _ddffa
}

var _dabbd = [...]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36}

func _fgdfb(_ffdee [][]Result) float64 {
	if len(_ffdee) == 2 {
		_edda := _ffdee[0][0].AsNumber()
		_adag := _ffdee[0][1].AsNumber()
		_eebce := _ffdee[1][0].AsNumber()
		_dcfdd := _ffdee[1][1].AsNumber()
		if _edda.Type != ResultTypeNumber || _adag.Type != ResultTypeNumber || _eebce.Type != ResultTypeNumber || _dcfdd.Type != ResultTypeNumber {
			return _dc.NaN()
		}
		return _edda.ValueNumber*_dcfdd.ValueNumber - _eebce.ValueNumber*_adag.ValueNumber
	}
	_ccbba := float64(0)
	_acfa := float64(1)
	for _dcfb := range _ffdee {
		_ccbba += _acfa * _ffdee[0][_dcfb].ValueNumber * _fgdfb(_cegca(_ffdee, _dcfb))
		_acfa *= -1
	}
	return _ccbba
}

// Cumprinc implements the Excel CUMPRINC function.
func Cumprinc(args []Result) Result {
	_ecgf, _bdgce := _acef(args, "\u0043\u0055\u004d\u0050\u0052\u0049\u004e\u0043")
	if _bdgce.Type == ResultTypeError {
		return _bdgce
	}
	_ada := _ecgf._agec
	_faef := _ecgf._ggec
	_ebbac := _ecgf._cab
	_bfgf := _ecgf._efdb
	_dfca := _ecgf._gdga
	_eega := _ecgf._bacb
	_ecdd := _faf(_ada, _faef, _ebbac, 0, _eega)
	_baeb := 0.0
	if _bfgf == 1 {
		if _eega == 0 {
			_baeb = _ecdd + _ebbac*_ada
		} else {
			_baeb = _ecdd
		}
		_bfgf++
	}
	for _eccc := _bfgf; _eccc <= _dfca; _eccc++ {
		if _eega == 1 {
			_baeb += _ecdd - (_cfgg(_ada, _eccc-2, _ecdd, _ebbac, 1)-_ecdd)*_ada
		} else {
			_baeb += _ecdd - _cfgg(_ada, _eccc-1, _ecdd, _ebbac, 0)*_ada
		}
	}
	return MakeNumberResult(_baeb)
}

// Eval evaluates and returns the result of an error expression.
func (_gdfd Error) Eval(ctx Context, ev Evaluator) Result { return MakeErrorResult(_gdfd._gag) }

// Eval evaluates and returns a number.
func (_gddda Number) Eval(ctx Context, ev Evaluator) Result { return MakeNumberResult(_gddda._becb) }

var _ffe Result = MakeEmptyResult()

// YearFrac is an implementation of the Excel YEARFRAC() function.
func YearFrac(args []Result) Result {
	_fcdf := len(args)
	if (_fcdf != 2 && _fcdf != 3) || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber {
		return MakeErrorResult("Y\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006f\u0072 \u0074\u0068\u0072\u0065\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_eafa := 0
	if _fcdf == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("Y\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020ba\u0073\u0069\u0073\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074o \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_eafa = int(args[2].ValueNumber)
		if !_cfee(_eafa) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0059\u0045\u0041R\u0046\u0052\u0041\u0043")
		}
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0074\u0061\u0072\u0074\u0020\u0064\u0061t\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gafg := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043 \u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0065\u006ed\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_cgf := args[1].ValueNumber
	_fee, _bdef := _fea(_gafg, _cgf, _eafa)
	if _bdef.Type == ResultTypeError {
		return _bdef
	}
	return MakeNumberResult(_fee)
}

var _fac = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

// Amordegrc implements the Excel AMORDEGRC function.
func Amordegrc(args []Result) Result {
	_gagc, _cea := _aebc(args, "\u0041M\u004f\u0052\u0044\u0045\u0047\u0052C")
	if _cea.Type == ResultTypeError {
		return _cea
	}
	_gbeb := _gagc._gdbg
	_aagd := _gagc._ccggc
	_edfg := _gagc._aeeb
	_edca := _gagc._geca
	_dddb := _gagc._bdc
	_eceb := _gagc._fffc
	if _eceb >= 0.5 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u004d\u004f\u0052\u0044\u0045\u0047R\u0043\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u0030\u002e\u0035")
	}
	_faad := _gagc._ccdb
	_aggb := 1.0 / _eceb
	_fba := 2.5
	if _aggb < 3 {
		_fba = 1
	} else if _aggb < 5 {
		_fba = 1.5
	} else if _aggb <= 6 {
		_fba = 2
	}
	_eceb *= _fba
	_bdgc, _fdccb := _fea(_aagd, _edfg, _faad)
	if _fdccb.Type == ResultTypeError {
		return MakeErrorResult("\u0069\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0072\u0020\u0041\u004d\u004f\u0052\u0044EG\u0052\u0043")
	}
	_fcfec := _edad(_bdgc * _eceb * _gbeb)
	_gbeb -= _fcfec
	_fdab := _gbeb - _edca
	for _ecg := 0; _ecg < _dddb; _ecg++ {
		_fcfec = _edad(_eceb * _gbeb)
		_fdab -= _fcfec
		if _fdab < 0 {
			switch _dddb - _ecg {
			case 0:
			case 1:
				return MakeNumberResult(_edad(_gbeb * 0.5))
			default:
				return MakeNumberResult(0)
			}
		}
		_gbeb -= _fcfec
	}
	return MakeNumberResult(_fcfec)
}

// Arabic implements the Excel ARABIC function which parses roman numerals.  It
// accepts one numeric argument.
func Arabic(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0041\u0052\u0041\u0042I\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_ebabd := args[0]
	switch _ebabd.Type {
	case ResultTypeNumber, ResultTypeList, ResultTypeEmpty:
		return MakeErrorResult("\u0041\u0052\u0041B\u0049\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	case ResultTypeString:
		_ccfee := 0.0
		_cdbf := 0.0
		for _, _dfefd := range _ebabd.ValueString {
			_gcdc := 0.0
			switch _dfefd {
			case 'I':
				_gcdc = 1
			case 'V':
				_gcdc = 5
			case 'X':
				_gcdc = 10
			case 'L':
				_gcdc = 50
			case 'C':
				_gcdc = 100
			case 'D':
				_gcdc = 500
			case 'M':
				_gcdc = 1000
			}
			_ccfee += _gcdc
			switch {
			case _cdbf == _gcdc && (_cdbf == 5 || _cdbf == 50 || _cdbf == 500):
				return MakeErrorResult("i\u006e\u0076\u0061\u006cid\u0020A\u0052\u0041\u0042\u0049\u0043 \u0066\u006f\u0072\u006d\u0061\u0074")
			case 2*_cdbf == _gcdc:
				return MakeErrorResult("i\u006e\u0076\u0061\u006cid\u0020A\u0052\u0041\u0042\u0049\u0043 \u0066\u006f\u0072\u006d\u0061\u0074")
			}
			if _cdbf < _gcdc {
				_ccfee -= 2 * _cdbf
			}
			_cdbf = _gcdc
		}
		return MakeNumberResult(_ccfee)
	case ResultTypeError:
		return _ebabd
	default:
		return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068an\u0064\u006c\u0065\u0064\u0020\u0041\u0043\u004f\u0053H\u0028)\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _ebabd.Type))
	}
}

const _dda = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0044\u0041\u0054\u0045\u0056\u0041\u004c\u0055\u0045"

// Reference returns a string reference value to a vertical range.
func (_fabgc VerticalRange) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeVerticalRange, Value: _fabgc.verticalRangeReference()}
}

// Update updates references in the PrefixVerticalRange after removing a row/column.
func (_aedcf PrefixVerticalRange) Update(q *_cc.UpdateQuery) Expression {
	if q.UpdateType == _cc.UpdateActionRemoveColumn {
		_caaab := _aedcf
		_cafee := _aedcf._edebe.String()
		if _cafee == q.SheetToUpdate {
			_befe := q.ColumnIdx
			_caaab._bgcag = _cee(_aedcf._bgcag, _befe)
			_caaab._gadad = _cee(_aedcf._gadad, _befe)
		}
		return _caaab
	}
	return _aedcf
}

// BinaryExpr is a binary expression.
type BinaryExpr struct {
	_age, _bd Expression
	_dd       BinOpType
}

// MakeNumberResult constructs a number result.
func MakeNumberResult(v float64) Result {
	if v == _dc.Copysign(0, -1) {
		v = 0
	}
	return Result{Type: ResultTypeNumber, ValueNumber: v}
}

// Update returns the same object as updating sheet references does not affect SheetPrefixExpr.
func (_deacc SheetPrefixExpr) Update(q *_cc.UpdateQuery) Expression { return _deacc }

type Reference struct {
	Type  ReferenceType
	Value string
}

// True is an implementation of the Excel TRUE() function.  It takes no
// arguments.
func True(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0054\u0052\u0055E \u0074\u0061\u006b\u0065\u0073\u0020\u006e\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(true)
}

// Evaluator is the interface for a formula evaluator.  This is needed so we can
// pass it to the spreadsheet to let it evaluate formula cells before returning
// the results.
// NOTE: in order to implement Evaluator without cache embed noCache in it.
type Evaluator interface {
	Eval(_dbf Context, formula string) Result
	SetCache(_abc string, _adfe Result)
	GetFromCache(_cdf string) (Result, bool)
	LastEvalIsRef() bool
}

// SheetPrefixExpr is a reference to a sheet like Sheet1! (reference to sheet 'Sheet1').
type SheetPrefixExpr struct{ _edaee string }

// Date is an implementation of the Excel DATE() function.
func Date(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0041TE\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0068re\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_egee := int(args[0].ValueNumber)
	if _egee < 0 || _egee >= 10000 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074 \u0064\u0061\u0074\u0065")
	} else if _egee <= 1899 {
		_egee += 1900
	}
	_fdgc := _ce.Month(args[1].ValueNumber)
	_dccf := int(args[2].ValueNumber)
	_bdac := _gcad(_egee, _fdgc, _dccf)
	_afgf := _aeac(_ccf, _bdac) + 1
	if _afgf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074 \u0064\u0061\u0074\u0065")
	}
	return MakeNumberResult(_afgf)
}

const _bggb = 57359

// NewPrefixVerticalRange constructs a new full columns range with prefix.
func NewPrefixVerticalRange(pfx Expression, v string) Expression {
	_bdga := _ee.Split(v, "\u003a")
	if len(_bdga) != 2 {
		return nil
	}
	return PrefixVerticalRange{pfx, _bdga[0], _bdga[1]}
}

func _dabd(_gcgd, _efed, _gaeb, _gbbe, _bcbb, _gcd float64) float64 {
	var _dagf, _fdge float64
	_fgbd := 0.0
	_dgba := _dc.Ceil(_bcbb)
	_gfbb := _gcgd - _efed
	_eebeg := false
	_ebgf := 0.0
	for _gggg := 1.0; _gggg <= _dgba; _gggg++ {
		if !_eebeg {
			_dagf = _eddf(_gcgd, _efed, _gaeb, _gggg, _gcd)
			_ebgf = _gfbb / (_gaeb - _gggg + 1)
			if _ebgf > _dagf {
				_fdge = _ebgf
				_eebeg = true
			} else {
				_fdge = _dagf
				_gfbb -= _dagf
			}
		} else {
			_fdge = _ebgf
		}
		if _gggg == _dgba {
			_fdge *= _bcbb + 1 - _dgba
		}
		_fgbd += _fdge
	}
	return _fgbd
}

func _ffedd(_bfcfg yyLexer) int { return _bbbfe().Parse(_bfcfg) }

// Large implements the Excel LARGE function.
func Large(args []Result) Result { return _bceae(args, true) }

// Len is an implementation of the Excel LEN function that returns length of a string
func Len(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004c\u0045N\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_aafgc := args[0].AsString()
	if _aafgc.Type != ResultTypeString {
		return MakeErrorResult("\u004c\u0045N\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(float64(len(_aafgc.ValueString)))
}

func _ecfc(_cafb float64, _edfbb *criteriaRegex) bool {
	_dcaca, _deeg := _ff.ParseFloat(_edfbb._fffea, 64)
	if _deeg != nil {
		return false
	}
	switch _edfbb._fbffg {
	case _cgef:
		return _cafb == _dcaca
	case _cabdg:
		return _cafb <= _dcaca
	case _adcef:
		return _cafb >= _dcaca
	case _cfab:
		return _cafb < _dcaca
	case _baegf:
		return _cafb > _dcaca
	}
	return false
}

func _ggg(_eecg, _fdabb []float64, _cbfg float64) float64 {
	_edb := _cbfg + 1
	_bcae := _eecg[0]
	_bbdf := len(_eecg)
	_fcded := _fdabb[0]
	for _efac := 1; _efac < _bbdf; _efac++ {
		_bcae += _eecg[_efac] / _dc.Pow(_edb, (_fdabb[_efac]-_fcded)/365)
	}
	return _bcae
}

// DateDif is an implementation of the Excel DATEDIF() function.
func DateDif(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeString {
		return MakeErrorResult("\u0044\u0041\u0054\u0045\u0044I\u0046\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077o\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u006e\u0064\u0020\u006f\u006e\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_gbf := args[0].ValueNumber
	_ggc := args[1].ValueNumber
	if _ggc < _gbf {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0068\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0064a\u0074\u0065\u0020\u0069s\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u0065\u006e\u0064\u0020\u0064\u0061\u0074\u0065")
	}
	if _ggc == _gbf {
		return MakeNumberResult(0)
	}
	_dga := _ee.ToLower(args[2].ValueString)
	if _dga == "\u0064" {
		return MakeNumberResult(_ggc - _gbf)
	}
	_dbd := _fae(_gbf)
	_dce := _fae(_ggc)
	_bca, _ebd, _dacf := _dbd.Date()
	_ddbb, _aff, _fgg := _dce.Date()
	_ebba := int(_ebd)
	_ceca := int(_aff)
	var _agdg float64
	switch _dga {
	case "\u0079":
		_agdg = float64(_ddbb - _bca)
		if _ceca < _ebba || (_ceca == _ebba && _fgg < _dacf) {
			_agdg--
		}
	case "\u006d":
		_bbb := _ddbb - _bca
		_fcgc := _ceca - _ebba
		if _fgg < _dacf {
			_fcgc--
		}
		if _fcgc < 0 {
			_bbb--
			_fcgc += 12
		}
		_agdg = float64(_bbb*12 + _fcgc)
	case "\u006d\u0064":
		_bac := _ceca
		if _fgg < _dacf {
			_bac--
		}
		_agdg = float64(int(_ggc - _acb(_ddbb, _bac, _dacf)))
	case "\u0079\u006d":
		_agdg = float64(_ceca - _ebba)
		if _fgg < _dacf {
			_agdg--
		}
		if _agdg < 0 {
			_agdg += 12
		}
	case "\u0079\u0064":
		_daf := _ddbb
		if _ceca < _ebba || (_ceca == _ebba && _fgg < _dacf) {
			_daf--
		}
		_agdg = float64(int(_ggc - _acb(_daf, _ebba, _dacf)))
	default:
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0069\u006e\u0074e\u0072\u0076\u0061\u006c\u0020\u0076\u0061\u006c\u0075\u0065")
	}
	return MakeNumberResult(_agdg)
}

// Nper implements the Excel NPER function.
func Nper(args []Result) Result {
	_dab := len(args)
	if _dab < 3 || _dab > 5 {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067e\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u0020\u0035")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("N\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_cdge := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0070\u0061y\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aggg := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_baag := args[2].ValueNumber
	_gegdd := 0.0
	if _dab >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_gegdd = args[3].ValueNumber
	}
	_gdac := 0.0
	if _dab == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("N\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_gdac = args[4].ValueNumber
		if _gdac != 0 {
			_gdac = 1
		}
	}
	_gdba := _aggg*(1+_cdge*_gdac) - _gegdd*_cdge
	_gefa := (_baag*_cdge + _aggg*(1+_cdge*_gdac))
	return MakeNumberResult(_dc.Log(_gdba/_gefa) / _dc.Log(1+_cdge))
}

var _egeea = [...]int{-1, 1, 1, -1, -2, 0}

var _baad = map[string]Function{}

func _aebc(_dbe []Result, _ecac string) (*amorArgs, Result) {
	_abdd := len(_dbe)
	if _abdd != 6 && _abdd != 7 {
		return nil, MakeErrorResult(_ecac + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020\u006fr\u0020s\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _dbe[0].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_ecac + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0063\u006fst \u0074o \u0062\u0065\u0020\u006e\u0075\u006d\u0062er\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_deafa := _dbe[0].ValueNumber
	if _deafa < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _ecac+"\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0063\u006f\u0073\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	_bebd, _fgba := _faeb(_dbe[1], "\u0064\u0061\u0074\u0065\u0020\u0070\u0075\u0072\u0063h\u0061\u0073\u0065\u0064", _ecac)
	if _fgba.Type == ResultTypeError {
		return nil, _fgba
	}
	_gdbe, _fgba := _faeb(_dbe[2], "\u0066\u0069\u0072s\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064", _ecac)
	if _fgba.Type == ResultTypeError {
		return nil, _fgba
	}
	if _gdbe < _bebd {
		return nil, MakeErrorResultType(ErrorTypeNum, _ecac+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074 \u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020l\u0061\u0074\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061te\u0020\u0070\u0075\u0072\u0063\u0068\u0061\u0073\u0065\u0064")
	}
	if _dbe[3].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_ecac + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006cv\u0061\u0067\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fgfa := _dbe[3].ValueNumber
	if _fgfa < 0 || _fgfa > _deafa {
		return nil, MakeErrorResultType(ErrorTypeNum, _ecac+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061g\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0062\u0065\u0074\u0077\u0065e\u006e\u0020\u0030\u0020\u0061\u006e\u0064\u0020\u0074\u0068\u0065\u0020in\u0069\u0074\u0069\u0061\u006c\u0020\u0063\u006f\u0073\u0074")
	}
	if _dbe[4].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_ecac + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dbeb := int(_dbe[4].ValueNumber)
	if _dbeb < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _ecac+" \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0070\u0065\u0072\u0069o\u0064\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u002d\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if _dbe[5].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_ecac + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0064\u0065\u0070\u0072\u0065\u0063\u0069\u0061\u0074\u0069\u006f\u006e\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_gffe := _dbe[5].ValueNumber
	if _gffe < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _ecac+"\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 d\u0065\u0070\u0072\u0065\u0063\u0069\u0061\u0074\u0069\u006f\u006e\u0020\u0072\u0061t\u0065\u0020t\u006f\u0020\u0062e\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030\u0020\u0061\u006e\u0064 \u006c\u0065ss\u0020\u0074\u0068a\u006e\u0020\u0030\u002e\u0035")
	}
	_cebba := 0
	if _abdd == 7 && _dbe[6].Type != ResultTypeEmpty {
		if _dbe[6].Type != ResultTypeNumber {
			return nil, MakeErrorResult(_ecac + "\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_cebba = int(_dbe[6].ValueNumber)
		if !_cfee(_cebba) || _cebba == 2 {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020"+_ecac)
		}
	}
	return &amorArgs{_deafa, _bebd, _gdbe, _fgfa, _dbeb, _gffe, _cebba}, _ffe
}

// Update returns the same object as updating sheet references does not affect ConstArrayExpr.
func (_ecd ConstArrayExpr) Update(q *_cc.UpdateQuery) Expression { return _ecd }

// String returns a string of a range.
func (_ffgec Range) String() string {
	return _c.Sprintf("\u0025\u0073\u003a%\u0073", _ffgec._eadcf.String(), _ffgec._dfbgf.String())
}

// EmptyExpr is an empty expression.
type EmptyExpr struct{}

// Nominal implements the Excel NOMINAL function.
func Nominal(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("NO\u004d\u0049N\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u006f\u006d\u0069\u006e\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072g\u0075m\u0065\u006et")
	}
	_fgfg := args[0].ValueNumber
	if _fgfg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u004e\u004fM\u0049\u004e\u0041\u004c\u0020r\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0065\u0066\u0066\u0065\u0063\u0074\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066\u0020\u0063\u006f\u006d\u0070\u006f\u0075\u006e\u0064\u0069\u006e\u0067\u0020\u0070\u0065\u0072i\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ggac := float64(int(args[1].ValueNumber))
	if _ggac < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006eum\u0062e\u0072\u0020\u006f\u0066\u0020\u0063\u006f\u006d\u0070\u006f\u0075\u006ed\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065 \u0031\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065")
	}
	return MakeNumberResult((_dc.Pow(_fgfg+1, 1/_ggac) - 1) * _ggac)
}

// Xor is an implementation of the Excel XOR() function and takes a variable
// number of arguments. It's odd to say the least.  If any argument is numeric,
// it returns true if the number of non-zero numeric arguments is odd and false
// otherwise.  If no argument is numeric, it returns an error.
func Xor(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0058\u004f\u0052 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061t\u0020l\u0065a\u0073t\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cegc := 0
	_dgff := false
	for _, _fcbf := range args {
		switch _fcbf.Type {
		case ResultTypeList, ResultTypeArray:
			_eeee := Xor(_fcbf.ListValues())
			if _eeee.Type == ResultTypeError {
				return _eeee
			}
			if _eeee.ValueNumber != 0 {
				_cegc++
			}
			_dgff = true
		case ResultTypeNumber:
			if _fcbf.ValueNumber != 0 {
				_cegc++
			}
			_dgff = true
		case ResultTypeString:
		case ResultTypeError:
			return _fcbf
		default:
			return MakeErrorResult("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0061\u0072\u0067u\u006de\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0058\u004f\u0052")
		}
	}
	if !_dgff {
		return MakeErrorResult("\u0058\u004f\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069n\u0070\u0075\u0074")
	}
	return MakeBoolResult(_cegc%2 != 0)
}

func NewLexer() *Lexer { return &Lexer{_daeg: make(chan *node)} }

func _aabb(_eafd string) bool {
	for _, _acc := range _afd {
		_dfc := _acc.FindStringSubmatch(_eafd)
		if len(_dfc) > 1 {
			return true
		}
	}
	return false
}

// NewSheetPrefixExpr constructs a new prefix expression.
func NewSheetPrefixExpr(s string) Expression { return &SheetPrefixExpr{s} }

// TimeValue is an implementation of the Excel TIMEVALUE() function.
func TimeValue(args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0054I\u004d\u0045V\u0041\u004c\u0055\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069ng\u006c\u0065\u0020s\u0074\u0072i\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_gaf := _ee.ToLower(args[0].ValueString)
	if !_efab(_gaf) {
		_, _, _, _bcca, _def := _dfb(_gaf)
		if _def.Type == ResultTypeError {
			_def.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020f\u006f\u0072\u0020\u0054\u0049\u004d\u0045V\u0041\u004c\u0055\u0045"
			return _def
		}
		if _bcca {
			return MakeNumberResult(0)
		}
	}
	_fge, _abd, _bdb, _cdff, _, _gee := _ffge(_gaf)
	if _gee.Type == ResultTypeError {
		return _gee
	}
	_fdcc := _gdfdg(float64(_fge), float64(_abd), _bdb)
	if _cdff {
		_fdcc += 0.5
	} else if _fdcc >= 1 {
		_fdcc -= float64(int(_fdcc))
	}
	return MakeNumberResult(_fdcc)
}

const (
	_fdgfd countMode = iota
	_ecaa
	_afe
)

// MakeErrorResult constructs a #VALUE! error with a given extra error message.
// The error message is for debugging formula evaluation only and is not stored
// in the sheet.
func MakeErrorResult(msg string) Result { return MakeErrorResultType(ErrorTypeValue, msg) }

const _fcg = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002d\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u002d\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

// NamedRangeRef is a reference to a named range.
type NamedRangeRef struct{ _bdggc string }

// Decimal is an implementation of the Excel function DECIMAL() that parses a string
// in a given base and returns the numeric result.
func Decimal(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0044\u0045\u0043\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065s\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dccbc := args[0].AsString()
	if _dccbc.Type != ResultTypeString {
		return MakeErrorResult("D\u0045\u0043\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u0072\u0073t \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_gacg := args[1].AsNumber()
	if _gacg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0045\u0043\u0049\u004dA\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cbea := _dccbc.ValueString
	if len(_cbea) > 2 && (_ee.HasPrefix(_cbea, "\u0030\u0078") || _ee.HasPrefix(_cbea, "\u0030\u0058")) {
		_cbea = _cbea[2:]
	}
	_gedg, _aceb := _ff.ParseInt(_cbea, int(_gacg.ValueNumber), 64)
	if _aceb != nil {
		return MakeErrorResult("\u0044\u0045C\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0069\u006e\u0020\u0063\u006f\u006e\u0076\u0065\u0072si\u006f\u006e")
	}
	return MakeNumberResult(float64(_gedg))
}

func _efbfc(_bedf Context, _fecbc Evaluator, _gdfdf, _ffeeg string) Result {
	_gfbeg, _cbedg := _cb.ParseCellReference(_gdfdf)
	if _cbedg != nil {
		return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073e\u0020r\u0061n\u0067e\u0020\u0025\u0073\u003a\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _gdfdf, _cbedg.Error()))
	}
	_baabb, _geeba := _gfbeg.ColumnIdx, _gfbeg.RowIdx
	_cbfdc, _gdcd := _cb.ParseCellReference(_ffeeg)
	if _gdcd != nil {
		return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073e\u0020r\u0061n\u0067e\u0020\u0025\u0073\u003a\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _ffeeg, _gdcd.Error()))
	}
	_dagbc, _efdcf := _cbfdc.ColumnIdx, _cbfdc.RowIdx
	_gdbcbf := [][]Result{}
	for _baeba := _geeba; _baeba <= _efdcf; _baeba++ {
		_dgbgb := []Result{}
		for _ecege := _baabb; _ecege <= _dagbc; _ecege++ {
			_bdge := _bedf.Cell(_c.Sprintf("\u0025\u0073\u0025\u0064", _cb.IndexToColumn(_ecege), _baeba), _fecbc)
			_dgbgb = append(_dgbgb, _bdge)
		}
		_gdbcbf = append(_gdbcbf, _dgbgb)
	}
	if len(_gdbcbf) == 1 {
		if len(_gdbcbf[0]) == 1 {
			return _gdbcbf[0][0]
		}
		return MakeListResult(_gdbcbf[0])
	}
	return MakeArrayResult(_gdbcbf)
}

func _eef(_bff string, _bb *_cc.UpdateQuery) string {
	_cd, _gfa := _cb.ParseCellReference(_bff)
	if _gfa != nil {
		return "\u0023\u0052\u0045F\u0021"
	}
	if _bb.UpdateType == _cc.UpdateActionRemoveColumn {
		_dcf := _bb.ColumnIdx
		_bde := _cd.ColumnIdx
		if _bde < _dcf {
			return _bff
		} else if _bde == _dcf {
			return "\u0023\u0052\u0045F\u0021"
		} else {
			return _cd.Update(_cc.UpdateActionRemoveColumn).String()
		}
	}
	return _bff
}

func _fec(_dadgg, _afca, _aad, _cff, _feag float64, _gecc int) Result {
	_gccg, _gccd := _fea(_dadgg, _afca, _gecc)
	if _gccd.Type == ResultTypeError {
		return _gccd
	}
	_ddga, _afcd := _ggca(_dadgg, _afca, int(_feag), _gecc)
	if _afcd.Type == ResultTypeError {
		return _afcd
	}
	_dcca := 0.0
	_bfe := 0.0
	_aad *= 100 / _feag
	_cff /= _feag
	_cff++
	_bcb := _gccg*_feag - _ddga
	for _dfg := 1.0; _dfg < _ddga; _dfg++ {
		_fgge := _dfg + _bcb
		_becf := _aad / _dc.Pow(_cff, _fgge)
		_bfe += _becf
		_dcca += _fgge * _becf
	}
	_fadb := (_aad + 100) / _dc.Pow(_cff, _ddga+_bcb)
	_bfe += _fadb
	_dcca += (_ddga + _bcb) * _fadb
	_dcca /= _bfe
	_dcca /= _feag
	return MakeNumberResult(_dcca)
}

func (_bbcc *Lexer) lex(_dcgeb _e.Reader) {
	_gfecad, _bebgf, _bgba := 0, 0, 0
	_fgbff := -1
	_bdaac, _dgcb, _dbce := 0, 0, 0
	_ = _dbce
	_fadgf := 1
	_ = _fadgf
	_ddbga := make([]byte, 4096)
	_gfga := false
	for !_gfga {
		_ecff := 0
		if _bdaac > 0 {
			_ecff = _bebgf - _bdaac
		}
		_bebgf = 0
		_eeggd, _cadcd := _dcgeb.Read(_ddbga[_ecff:])
		if _eeggd == 0 || _cadcd != nil {
			_gfga = true
		}
		_bgba = _eeggd + _ecff
		if _bgba < len(_ddbga) {
			_fgbff = _bgba
		}
		{
			_gfecad = _dgbec
			_bdaac = 0
			_dgcb = 0
			_dbce = 0
		}
		{
			var _acffd int
			var _ccgd uint
			if _bebgf == _bgba {
				goto _eecd
			}
			if _gfecad == 0 {
				goto _cbed
			}
		_bbde:
			_acffd = int(_dadgd[_gfecad])
			_ccgd = uint(_cddd[_acffd])
			_acffd++
			for ; _ccgd > 0; _ccgd-- {
				_acffd++
				switch _cddd[_acffd-1] {
				case 2:
					_bdaac = _bebgf
				}
			}
			switch _gfecad {
			case 30:
				switch _ddbga[_bebgf] {
				case 34:
					goto _cagg
				case 35:
					goto _fabed
				case 36:
					goto _cfbda
				case 38:
					goto _dcgb
				case 39:
					goto _cfecb
				case 40:
					goto _face
				case 41:
					goto _gccb
				case 42:
					goto _dgebec
				case 43:
					goto _egga
				case 44:
					goto _ccecg
				case 45:
					goto _fgafd
				case 47:
					goto _fffd
				case 58:
					goto _aebf
				case 59:
					goto _bbfc
				case 60:
					goto _gbadb
				case 61:
					goto _fabgb
				case 62:
					goto _daacg
				case 63:
					goto _efaba
				case 70:
					goto _ecde
				case 84:
					goto _eeab
				case 92:
					goto _cddeb
				case 94:
					goto _acdg
				case 95:
					goto _gbfafd
				case 123:
					goto _fecb
				case 125:
					goto _fgbaf
				}
				switch {
				case _ddbga[_bebgf] < 65:
					switch {
					case _ddbga[_bebgf] > 37:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _cgcf
						}
					case _ddbga[_bebgf] >= 33:
						goto _efaba
					}
				case _ddbga[_bebgf] > 90:
					switch {
					case _ddbga[_bebgf] > 93:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _ccad
						}
					case _ddbga[_bebgf] >= 91:
						goto _efaba
					}
				default:
					goto _ecabd
				}
				goto _fede
			case 1:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 47:
					goto _cdbg
				case 123:
					goto _cdbg
				case 125:
					goto _cdbg
				}
				switch {
				case _ddbga[_bebgf] < 37:
					if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
						goto _cdbg
					}
				case _ddbga[_bebgf] > 45:
					switch {
					case _ddbga[_bebgf] > 63:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _cdbg
						}
					case _ddbga[_bebgf] >= 58:
						goto _cdbg
					}
				default:
					goto _cdbg
				}
				goto _fede
			case 0:
				goto _cbed
			case 2:
				if _ddbga[_bebgf] == 34 {
					goto _dffa
				}
				goto _cagg
			case 31:
				if _ddbga[_bebgf] == 34 {
					goto _cagg
				}
				goto _baeda
			case 3:
				switch _ddbga[_bebgf] {
				case 78:
					goto _cbfc
				case 82:
					goto _bgcf
				}
				goto _efaba
			case 4:
				switch _ddbga[_bebgf] {
				case 47:
					goto _aaed
				case 85:
					goto _efedd
				}
				goto _efaba
			case 5:
				if _ddbga[_bebgf] == 65 {
					goto _ecaec
				}
				goto _efaba
			case 6:
				switch _ddbga[_bebgf] {
				case 76:
					goto _bfff
				case 77:
					goto _fcecb
				}
				goto _efaba
			case 7:
				if _ddbga[_bebgf] == 76 {
					goto _fcecb
				}
				goto _efaba
			case 8:
				if _ddbga[_bebgf] == 33 {
					goto _ecaec
				}
				goto _efaba
			case 9:
				if _ddbga[_bebgf] == 69 {
					goto _eagg
				}
				goto _efaba
			case 10:
				if _ddbga[_bebgf] == 70 {
					goto _fged
				}
				goto _efaba
			case 11:
				if _ddbga[_bebgf] == 33 {
					goto _cdbdd
				}
				goto _efaba
			case 12:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 47:
					goto _efaba
				case 123:
					goto _efaba
				case 125:
					goto _efaba
				}
				switch {
				case _ddbga[_bebgf] < 48:
					switch {
					case _ddbga[_bebgf] > 35:
						if 37 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 45 {
							goto _efaba
						}
					case _ddbga[_bebgf] >= 34:
						goto _efaba
					}
				case _ddbga[_bebgf] > 57:
					switch {
					case _ddbga[_bebgf] < 65:
						if 58 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 63 {
							goto _efaba
						}
					case _ddbga[_bebgf] > 90:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _efaba
						}
					default:
						goto _fefaf
					}
				default:
					goto _cfcbg
				}
				goto _fede
			case 13:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 47:
					goto _efaba
				case 58:
					goto _eagdb
				case 123:
					goto _efaba
				case 125:
					goto _efaba
				}
				switch {
				case _ddbga[_bebgf] < 48:
					switch {
					case _ddbga[_bebgf] > 35:
						if 37 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 45 {
							goto _efaba
						}
					case _ddbga[_bebgf] >= 34:
						goto _efaba
					}
				case _ddbga[_bebgf] > 57:
					switch {
					case _ddbga[_bebgf] > 63:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _efaba
						}
					case _ddbga[_bebgf] >= 59:
						goto _efaba
					}
				default:
					goto _cfcbg
				}
				goto _fede
			case 14:
				if _ddbga[_bebgf] == 36 {
					goto _cdced
				}
				if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
					goto _ggace
				}
				goto _cdbg
			case 15:
				if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
					goto _ggace
				}
				goto _cdbg
			case 32:
				if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
					goto _ggace
				}
				goto _bcabb
			case 16:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 47:
					goto _efaba
				case 58:
					goto _bcbe
				case 123:
					goto _efaba
				case 125:
					goto _efaba
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 45:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _daegf
						}
					case _ddbga[_bebgf] >= 34:
						goto _efaba
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] > 90:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _efaba
						}
					case _ddbga[_bebgf] >= 65:
						goto _fefaf
					}
				default:
					goto _efaba
				}
				goto _fede
			case 17:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 47:
					goto _cdbg
				case 123:
					goto _cdbg
				case 125:
					goto _cdbg
				}
				switch {
				case _ddbga[_bebgf] < 48:
					switch {
					case _ddbga[_bebgf] > 35:
						if 37 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 45 {
							goto _cdbg
						}
					case _ddbga[_bebgf] >= 34:
						goto _cdbg
					}
				case _ddbga[_bebgf] > 57:
					switch {
					case _ddbga[_bebgf] > 63:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _cdbg
						}
					case _ddbga[_bebgf] >= 58:
						goto _cdbg
					}
				default:
					goto _daegf
				}
				goto _fede
			case 33:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 47:
					goto _agfcg
				case 123:
					goto _agfcg
				case 125:
					goto _agfcg
				}
				switch {
				case _ddbga[_bebgf] < 48:
					switch {
					case _ddbga[_bebgf] > 35:
						if 37 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 45 {
							goto _agfcg
						}
					case _ddbga[_bebgf] >= 34:
						goto _agfcg
					}
				case _ddbga[_bebgf] > 57:
					switch {
					case _ddbga[_bebgf] > 63:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _agfcg
						}
					case _ddbga[_bebgf] >= 58:
						goto _agfcg
					}
				default:
					goto _daegf
				}
				goto _fede
			case 18:
				if _ddbga[_bebgf] == 36 {
					goto _gaadg
				}
				if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
					goto _bdcb
				}
				goto _cdbg
			case 19:
				if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
					goto _bdcb
				}
				goto _cdbg
			case 34:
				if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
					goto _bdcb
				}
				goto _gcfe
			case 20:
				switch _ddbga[_bebgf] {
				case 39:
					goto _efaba
				case 42:
					goto _efaba
				case 47:
					goto _efaba
				case 58:
					goto _efaba
				case 63:
					goto _efaba
				}
				if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 93 {
					goto _efaba
				}
				goto _ceaf
			case 21:
				switch _ddbga[_bebgf] {
				case 39:
					goto _bdggd
				case 42:
					goto _efaba
				case 47:
					goto _efaba
				case 58:
					goto _efaba
				case 63:
					goto _efaba
				}
				if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 93 {
					goto _efaba
				}
				goto _ceaf
			case 22:
				if _ddbga[_bebgf] == 33 {
					goto _gabe
				}
				goto _efaba
			case 35:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _baea
				case 58:
					goto _eagdb
				case 101:
					goto _daae
				case 123:
					goto _efeb
				case 125:
					goto _efeb
				}
				switch {
				case _ddbga[_bebgf] < 48:
					switch {
					case _ddbga[_bebgf] > 35:
						if 37 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 47 {
							goto _efeb
						}
					case _ddbga[_bebgf] >= 34:
						goto _efeb
					}
				case _ddbga[_bebgf] > 57:
					switch {
					case _ddbga[_bebgf] > 63:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _efeb
						}
					case _ddbga[_bebgf] >= 59:
						goto _efeb
					}
				default:
					goto _cgcf
				}
				goto _fede
			case 36:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 47:
					goto _efeb
				case 101:
					goto _daae
				case 123:
					goto _efeb
				case 125:
					goto _efeb
				}
				switch {
				case _ddbga[_bebgf] < 48:
					switch {
					case _ddbga[_bebgf] > 35:
						if 37 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 45 {
							goto _efeb
						}
					case _ddbga[_bebgf] >= 34:
						goto _efeb
					}
				case _ddbga[_bebgf] > 57:
					switch {
					case _ddbga[_bebgf] > 63:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _efeb
						}
					case _ddbga[_bebgf] >= 58:
						goto _efeb
					}
				default:
					goto _baea
				}
				goto _fede
			case 23:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 47:
					goto _ccfd
				case 123:
					goto _ccfd
				case 125:
					goto _ccfd
				}
				switch {
				case _ddbga[_bebgf] < 48:
					switch {
					case _ddbga[_bebgf] > 35:
						if 37 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 45 {
							goto _ccfd
						}
					case _ddbga[_bebgf] >= 34:
						goto _ccfd
					}
				case _ddbga[_bebgf] > 57:
					switch {
					case _ddbga[_bebgf] > 63:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _ccfd
						}
					case _ddbga[_bebgf] >= 58:
						goto _ccfd
					}
				default:
					goto _cdbfe
				}
				goto _fede
			case 37:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 47:
					goto _efeb
				case 123:
					goto _efeb
				case 125:
					goto _efeb
				}
				switch {
				case _ddbga[_bebgf] < 48:
					switch {
					case _ddbga[_bebgf] > 35:
						if 37 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 45 {
							goto _efeb
						}
					case _ddbga[_bebgf] >= 34:
						goto _efeb
					}
				case _ddbga[_bebgf] > 57:
					switch {
					case _ddbga[_bebgf] > 63:
						if 91 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 94 {
							goto _efeb
						}
					case _ddbga[_bebgf] >= 58:
						goto _efeb
					}
				default:
					goto _cdbfe
				}
				goto _fede
			case 38:
				switch _ddbga[_bebgf] {
				case 61:
					goto _bagfc
				case 62:
					goto _edcgd
				}
				goto _bdeaa
			case 39:
				if _ddbga[_bebgf] == 61 {
					goto _egbgb
				}
				goto _gcgea
			case 24:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _efaba
				case 125:
					goto _efaba
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _efaba
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _efaba
					}
				default:
					goto _efaba
				}
				goto _fede
			case 40:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _eggg
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _eggg
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 41:
				switch _ddbga[_bebgf] {
				case 46:
					goto _fege
				case 92:
					goto _fege
				case 95:
					goto _fege
				}
				switch {
				case _ddbga[_bebgf] < 65:
					if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
						goto _fege
					}
				case _ddbga[_bebgf] > 90:
					if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
						goto _fege
					}
				default:
					goto _fege
				}
				goto _ggfe
			case 42:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 43:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _agfcg
				case 125:
					goto _agfcg
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _agfcg
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					default:
						goto _agfcg
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _eggg
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _agfcg
					}
				default:
					goto _agfcg
				}
				goto _fede
			case 44:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _cdbg
				case 125:
					goto _cdbg
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _cdbg
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _cdbg
					}
				default:
					goto _cdbg
				}
				goto _fede
			case 25:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 65:
					goto _dfgga
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _efaba
				case 125:
					goto _efaba
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _efaba
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 66 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _efaba
					}
				default:
					goto _efaba
				}
				goto _fede
			case 45:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 76:
					goto _ddad
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 46:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 83:
					goto _agabe
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 47:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 69:
					goto _dcgfb
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 26:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 79:
					goto _gbab
				case 82:
					goto _bdfgg
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _efaba
				case 125:
					goto _efaba
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _efaba
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _efaba
					}
				default:
					goto _efaba
				}
				goto _fede
			case 48:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 68:
					goto _bcfd
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 49:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 79:
					goto _adffb
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 50:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 36:
					goto _fggg
				case 40:
					goto _bbef
				case 46:
					goto _eggg
				case 58:
					goto _bcbe
				case 85:
					goto _agabe
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 59:
					switch {
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _gbcga
						}
					case _ddbga[_bebgf] >= 34:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dddfa
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 27:
				switch _ddbga[_bebgf] {
				case 46:
					goto _fege
				case 92:
					goto _fege
				case 95:
					goto _fege
				}
				switch {
				case _ddbga[_bebgf] < 65:
					if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
						goto _fege
					}
				case _ddbga[_bebgf] > 90:
					if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
						goto _fege
					}
				default:
					goto _fege
				}
				goto _efaba
			case 28:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 120:
					goto _daabef
				case 123:
					goto _efaba
				case 125:
					goto _efaba
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _efaba
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _efaba
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _efaba
					}
				default:
					goto _efaba
				}
				goto _fede
			case 51:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 108:
					goto _dbbfd
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 52:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 102:
					goto _aecfg
				case 110:
					goto _aedfg
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 53:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 110:
					goto _gccaa
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 54:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _feeea
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 55:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _dadfb
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dadfb
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 56:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 40:
					goto _ddgbf
				case 46:
					goto _dadfb
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _dadfb
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _dadfb
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 57:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 109:
					goto _gbbca
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 58:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _ebecb
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _ggfe
				case 125:
					goto _ggfe
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _ggfe
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _ggfe
					}
				default:
					goto _ggfe
				}
				goto _fede
			case 59:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _cccac
				case 123:
					goto _cdbg
				case 125:
					goto _cdbg
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _cdbg
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _cdbg
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _cccac
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _cdbg
					}
				default:
					goto _cdbg
				}
				goto _fede
			case 29:
				switch _ddbga[_bebgf] {
				case 33:
					goto _dgcgg
				case 46:
					goto _fgfc
				case 92:
					goto _fege
				case 95:
					goto _fgfc
				case 123:
					goto _efaba
				case 125:
					goto _efaba
				}
				switch {
				case _ddbga[_bebgf] < 58:
					switch {
					case _ddbga[_bebgf] < 37:
						if 34 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 35 {
							goto _efaba
						}
					case _ddbga[_bebgf] > 47:
						if 48 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 57 {
							goto _fgfc
						}
					default:
						goto _efaba
					}
				case _ddbga[_bebgf] > 63:
					switch {
					case _ddbga[_bebgf] < 91:
						if 65 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 90 {
							goto _fgfc
						}
					case _ddbga[_bebgf] > 94:
						if 97 <= _ddbga[_bebgf] && _ddbga[_bebgf] <= 122 {
							goto _fgfc
						}
					default:
						goto _efaba
					}
				default:
					goto _efaba
				}
				goto _fede
			}
		_efaba:
			_gfecad = 0
			goto _ceded
		_fede:
			_gfecad = 1
			goto _ceded
		_cagg:
			_gfecad = 2
			goto _ceded
		_fabed:
			_gfecad = 3
			goto _ceded
		_cbfc:
			_gfecad = 4
			goto _ceded
		_aaed:
			_gfecad = 5
			goto _ceded
		_efedd:
			_gfecad = 6
			goto _ceded
		_bfff:
			_gfecad = 7
			goto _ceded
		_fcecb:
			_gfecad = 8
			goto _ceded
		_bgcf:
			_gfecad = 9
			goto _ceded
		_eagg:
			_gfecad = 10
			goto _ceded
		_fged:
			_gfecad = 11
			goto _ceded
		_cfbda:
			_gfecad = 12
			goto _ceded
		_cfcbg:
			_gfecad = 13
			goto _ceded
		_eagdb:
			_gfecad = 14
			goto _ceded
		_cdced:
			_gfecad = 15
			goto _ceded
		_fefaf:
			_gfecad = 16
			goto _ceded
		_fggg:
			_gfecad = 17
			goto _ceded
		_bcbe:
			_gfecad = 18
			goto _ceded
		_gaadg:
			_gfecad = 19
			goto _ceded
		_cfecb:
			_gfecad = 20
			goto _ceded
		_ceaf:
			_gfecad = 21
			goto _ceded
		_bdggd:
			_gfecad = 22
			goto _ceded
		_daae:
			_gfecad = 23
			goto _ceded
		_ecabd:
			_gfecad = 24
			goto _ceded
		_ecde:
			_gfecad = 25
			goto _ceded
		_eeab:
			_gfecad = 26
			goto _ceded
		_cddeb:
			_gfecad = 27
			goto _ceded
		_gbfafd:
			_gfecad = 28
			goto _ceded
		_ccad:
			_gfecad = 29
			goto _ceded
		_cdbg:
			_gfecad = 30
			goto _bcag
		_dgcgg:
			_gfecad = 30
			goto _ecad
		_ecaec:
			_gfecad = 30
			goto _baaac
		_cdbdd:
			_gfecad = 30
			goto _caeede
		_gabe:
			_gfecad = 30
			goto _geddb
		_ccfd:
			_gfecad = 30
			goto _eaega
		_bbef:
			_gfecad = 30
			goto _gdbcb
		_dcgb:
			_gfecad = 30
			goto _bfeba
		_face:
			_gfecad = 30
			goto _gccgd
		_gccb:
			_gfecad = 30
			goto _cfbab
		_dgebec:
			_gfecad = 30
			goto _acbda
		_egga:
			_gfecad = 30
			goto _bafd
		_ccecg:
			_gfecad = 30
			goto _fddc
		_fgafd:
			_gfecad = 30
			goto _bfgb
		_fffd:
			_gfecad = 30
			goto _defea
		_aebf:
			_gfecad = 30
			goto _eddbc
		_bbfc:
			_gfecad = 30
			goto _cccgf
		_fabgb:
			_gfecad = 30
			goto _bdecg
		_acdg:
			_gfecad = 30
			goto _cbgdc
		_fecb:
			_gfecad = 30
			goto _fefe
		_fgbaf:
			_gfecad = 30
			goto _adee
		_baeda:
			_gfecad = 30
			goto _ffcg
		_bcabb:
			_gfecad = 30
			goto _ggcdf
		_agfcg:
			_gfecad = 30
			goto _ggbg
		_gcfe:
			_gfecad = 30
			goto _dadab
		_efeb:
			_gfecad = 30
			goto _fbab
		_bdeaa:
			_gfecad = 30
			goto _dbbab
		_bagfc:
			_gfecad = 30
			goto _gdbec
		_edcgd:
			_gfecad = 30
			goto _fcgec
		_gcgea:
			_gfecad = 30
			goto _dccc
		_egbgb:
			_gfecad = 30
			goto _fefgg
		_ggfe:
			_gfecad = 30
			goto _egegc
		_ddgbf:
			_gfecad = 30
			goto _ebdf
		_dffa:
			_gfecad = 31
			goto _dcaad
		_ggace:
			_gfecad = 32
			goto _ceded
		_daegf:
			_gfecad = 33
			goto _ggea
		_bdcb:
			_gfecad = 34
			goto _ceded
		_cgcf:
			_gfecad = 35
			goto _gfdd
		_baea:
			_gfecad = 36
			goto _gfdd
		_cdbfe:
			_gfecad = 37
			goto _gfdd
		_gbadb:
			_gfecad = 38
			goto _ceded
		_daacg:
			_gfecad = 39
			goto _ceded
		_eggg:
			_gfecad = 40
			goto _edfd
		_fege:
			_gfecad = 41
			goto _ceded
		_fgfc:
			_gfecad = 42
			goto _edfd
		_gbcga:
			_gfecad = 43
			goto _ggea
		_dddfa:
			_gfecad = 44
			goto _edfd
		_dcgfb:
			_gfecad = 44
			goto _edab
		_adffb:
			_gfecad = 44
			goto _fffca
		_dfgga:
			_gfecad = 45
			goto _edfd
		_ddad:
			_gfecad = 46
			goto _edfd
		_agabe:
			_gfecad = 47
			goto _edfd
		_gbab:
			_gfecad = 48
			goto _edfd
		_bcfd:
			_gfecad = 49
			goto _edfd
		_bdfgg:
			_gfecad = 50
			goto _edfd
		_daabef:
			_gfecad = 51
			goto _edfd
		_dbbfd:
			_gfecad = 52
			goto _edfd
		_aecfg:
			_gfecad = 53
			goto _edfd
		_gccaa:
			_gfecad = 54
			goto _edfd
		_feeea:
			_gfecad = 55
			goto _edfd
		_dadfb:
			_gfecad = 56
			goto _edfd
		_aedfg:
			_gfecad = 57
			goto _edfd
		_gbbca:
			_gfecad = 58
			goto _edfd
		_ebecb:
			_gfecad = 59
			goto _edfd
		_cccac:
			_gfecad = 59
			goto _cfga
		_baaac:
			_acffd = 3
			goto _gcgdf
		_caeede:
			_acffd = 5
			goto _gcgdf
		_ecad:
			_acffd = 7
			goto _gcgdf
		_geddb:
			_acffd = 9
			goto _gcgdf
		_gdbcb:
			_acffd = 11
			goto _gcgdf
		_ebdf:
			_acffd = 13
			goto _gcgdf
		_bfeba:
			_acffd = 15
			goto _gcgdf
		_fefe:
			_acffd = 17
			goto _gcgdf
		_adee:
			_acffd = 19
			goto _gcgdf
		_gccgd:
			_acffd = 21
			goto _gcgdf
		_cfbab:
			_acffd = 23
			goto _gcgdf
		_bafd:
			_acffd = 25
			goto _gcgdf
		_bfgb:
			_acffd = 27
			goto _gcgdf
		_acbda:
			_acffd = 29
			goto _gcgdf
		_defea:
			_acffd = 31
			goto _gcgdf
		_cbgdc:
			_acffd = 33
			goto _gcgdf
		_bdecg:
			_acffd = 35
			goto _gcgdf
		_gdbec:
			_acffd = 37
			goto _gcgdf
		_fefgg:
			_acffd = 39
			goto _gcgdf
		_fcgec:
			_acffd = 41
			goto _gcgdf
		_eddbc:
			_acffd = 43
			goto _gcgdf
		_cccgf:
			_acffd = 45
			goto _gcgdf
		_fddc:
			_acffd = 47
			goto _gcgdf
		_fbab:
			_acffd = 49
			goto _gcgdf
		_ggbg:
			_acffd = 51
			goto _gcgdf
		_ggcdf:
			_acffd = 53
			goto _gcgdf
		_dadab:
			_acffd = 55
			goto _gcgdf
		_egegc:
			_acffd = 57
			goto _gcgdf
		_ffcg:
			_acffd = 59
			goto _gcgdf
		_dbbab:
			_acffd = 61
			goto _gcgdf
		_dccc:
			_acffd = 63
			goto _gcgdf
		_eaega:
			_acffd = 65
			goto _gcgdf
		_bcag:
			_acffd = 67
			goto _gcgdf
		_edab:
			_acffd = 72
			goto _gcgdf
		_gfdd:
			_acffd = 75
			goto _gcgdf
		_ggea:
			_acffd = 78
			goto _gcgdf
		_fffca:
			_acffd = 81
			goto _gcgdf
		_cfga:
			_acffd = 84
			goto _gcgdf
		_edfd:
			_acffd = 87
			goto _gcgdf
		_dcaad:
			_acffd = 90
			goto _gcgdf
		_gcgdf:
			_ccgd = uint(_cddd[_acffd])
			_acffd++
			for ; _ccgd > 0; _ccgd-- {
				_acffd++
				switch _cddd[_acffd-1] {
				case 3:
					_dgcb = _bebgf + 1
				case 4:
					_dbce = 1
				case 5:
					_dbce = 2
				case 6:
					_dbce = 3
				case 7:
					_dbce = 4
				case 8:
					_dbce = 11
				case 9:
					_dbce = 14
				case 10:
					_dbce = 15
				case 11:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_egebg, _ddbga[_bdaac:_dgcb])
					}
				case 12:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_gaafa, _ddbga[_bdaac:_dgcb])
					}
				case 13:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_deecg, _ddbga[_bdaac:_dgcb-1])
					}
				case 14:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_deecg, _ddbga[_bdaac+1:_dgcb-2])
					}
				case 15:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_bggb, _ddbga[_bdaac:_dgcb-1])
					}
				case 16:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_bggb, _ddbga[_bdaac:_dgcb-1])
					}
				case 17:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_bacdbf, _ddbga[_bdaac:_dgcb])
					}
				case 18:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_bcgd, _ddbga[_bdaac:_dgcb])
					}
				case 19:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_efdc, _ddbga[_bdaac:_dgcb])
					}
				case 20:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_bgfd, _ddbga[_bdaac:_dgcb])
					}
				case 21:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_faggb, _ddbga[_bdaac:_dgcb])
					}
				case 22:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_cecbb, _ddbga[_bdaac:_dgcb])
					}
				case 23:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_fgbdf, _ddbga[_bdaac:_dgcb])
					}
				case 24:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_bfaa, _ddbga[_bdaac:_dgcb])
					}
				case 25:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_aedd, _ddbga[_bdaac:_dgcb])
					}
				case 26:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_gfdec, _ddbga[_bdaac:_dgcb])
					}
				case 27:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_gfdb, _ddbga[_bdaac:_dgcb])
					}
				case 28:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_gggbg, _ddbga[_bdaac:_dgcb])
					}
				case 29:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_gebb, _ddbga[_bdaac:_dgcb])
					}
				case 30:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_dfedd, _ddbga[_bdaac:_dgcb])
					}
				case 31:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_fbg, _ddbga[_bdaac:_dgcb])
					}
				case 32:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_cfcb, _ddbga[_bdaac:_dgcb])
					}
				case 33:
					_dgcb = _bebgf + 1
					{
						_bbcc.emit(_cfaagc, _ddbga[_bdaac:_dgcb])
					}
				case 34:
					_dgcb = _bebgf
					_bebgf--
					{
						_bbcc.emit(_gefbd, _ddbga[_bdaac:_dgcb])
					}
				case 35:
					_dgcb = _bebgf
					_bebgf--
					{
						_bbcc.emit(_gdccc, _ddbga[_bdaac:_dgcb])
					}
				case 36:
					_dgcb = _bebgf
					_bebgf--
					{
						_bbcc.emit(_deaca, _ddbga[_bdaac:_dgcb])
					}
				case 37:
					_dgcb = _bebgf
					_bebgf--
					{
						_bbcc.emit(_gfcc, _ddbga[_bdaac:_dgcb])
					}
				case 38:
					_dgcb = _bebgf
					_bebgf--
					{
						_bbcc.emit(_cdded, _ddbga[_bdaac:_dgcb])
					}
				case 39:
					_dgcb = _bebgf
					_bebgf--
					{
						_bbcc.emit(_gefcf, _ddbga[_bdaac+1:_dgcb-1])
					}
				case 40:
					_dgcb = _bebgf
					_bebgf--
					{
						_bbcc.emit(_acaag, _ddbga[_bdaac:_dgcb])
					}
				case 41:
					_dgcb = _bebgf
					_bebgf--
					{
						_bbcc.emit(_cdaba, _ddbga[_bdaac:_dgcb])
					}
				case 42:
					_bebgf = (_dgcb) - 1
					{
						_bbcc.emit(_gefbd, _ddbga[_bdaac:_dgcb])
					}
				case 43:
					switch _dbce {
					case 0:
						{
							_gfecad = 0
							goto _ceded
						}
					case 1:
						{
							_bebgf = (_dgcb) - 1
							_bbcc.emit(_afcdb, _ddbga[_bdaac:_dgcb])
						}
					case 2:
						{
							_bebgf = (_dgcb) - 1
							_bbcc.emit(_gefbd, _ddbga[_bdaac:_dgcb])
						}
					case 3:
						{
							_bebgf = (_dgcb) - 1
							_bbcc.emit(_gdccc, _ddbga[_bdaac:_dgcb])
						}
					case 4:
						{
							_bebgf = (_dgcb) - 1
							_bbcc.emit(_gdbgc, _ddbga[_bdaac:_dgcb])
						}
					case 11:
						{
							_bebgf = (_dgcb) - 1
							_bbcc.emit(_gbaf, _ddbga[_bdaac:_dgcb])
						}
					case 14:
						{
							_bebgf = (_dgcb) - 1
							_bbcc.emit(_cdded, _ddbga[_bdaac:_dgcb])
						}
					case 15:
						{
							_bebgf = (_dgcb) - 1
							_bbcc.emit(_gefcf, _ddbga[_bdaac+1:_dgcb-1])
						}
					}
				}
			}
			goto _ceded
		_ceded:
			_acffd = int(_egbcg[_gfecad])
			_ccgd = uint(_cddd[_acffd])
			_acffd++
			for ; _ccgd > 0; _ccgd-- {
				_acffd++
				switch _cddd[_acffd-1] {
				case 0:
					_bdaac = 0
				case 1:
					_dbce = 0
				}
			}
			if _gfecad == 0 {
				goto _cbed
			}
			if _bebgf++; _bebgf != _bgba {
				goto _bbde
			}
		_eecd:
			{
			}
			if _bebgf == _fgbff {
				switch _gfecad {
				case 1:
					goto _cdbg
				case 2:
					goto _cdbg
				case 31:
					goto _baeda
				case 14:
					goto _cdbg
				case 15:
					goto _cdbg
				case 32:
					goto _bcabb
				case 17:
					goto _cdbg
				case 33:
					goto _agfcg
				case 18:
					goto _cdbg
				case 19:
					goto _cdbg
				case 34:
					goto _gcfe
				case 35:
					goto _efeb
				case 36:
					goto _efeb
				case 23:
					goto _ccfd
				case 37:
					goto _efeb
				case 38:
					goto _bdeaa
				case 39:
					goto _gcgea
				case 40:
					goto _ggfe
				case 41:
					goto _ggfe
				case 42:
					goto _ggfe
				case 43:
					goto _agfcg
				case 44:
					goto _cdbg
				case 45:
					goto _ggfe
				case 46:
					goto _ggfe
				case 47:
					goto _ggfe
				case 48:
					goto _ggfe
				case 49:
					goto _ggfe
				case 50:
					goto _ggfe
				case 51:
					goto _ggfe
				case 52:
					goto _ggfe
				case 53:
					goto _ggfe
				case 54:
					goto _ggfe
				case 55:
					goto _ggfe
				case 56:
					goto _ggfe
				case 57:
					goto _ggfe
				case 58:
					goto _ggfe
				case 59:
					goto _cdbg
				}
			}
		_cbed:
			{
			}
		}
		if _bdaac > 0 {
			copy(_ddbga[0:], _ddbga[_bdaac:])
		}
	}
	_ = _fgbff
	if _gfecad == _acabf {
		_bbcc.emit(_bcab, nil)
	}
	close(_bbcc._daeg)
}

// Eval evaluates and returns the result of a sheet expression.
func (_agbbf SheetPrefixExpr) Eval(ctx Context, ev Evaluator) Result {
	return MakeErrorResult("\u0073\u0068\u0065\u0065\u0074\u0020\u0070\u0072\u0065\u0066\u0069\u0078\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065r\u0020\u0062\u0065\u0020\u0065v\u0061\u006cu\u0061\u0074\u0065\u0064")
}

// MakeListResult constructs a list result.
func MakeListResult(list []Result) Result { return Result{Type: ResultTypeList, ValueList: list} }

// String returns a string representation of a horizontal range.
func (_acecd HorizontalRange) String() string { return _acecd.horizontalRangeReference() }

func _gdgf(_fgffd, _dgde Result, _bed, _bfdce bool) cmpResult {
	_fgffd = _fgffd.AsNumber()
	_dgde = _dgde.AsNumber()
	if _fgffd.Type != _dgde.Type {
		return _deecf
	}
	if _fgffd.Type == ResultTypeNumber {
		if _fgffd.ValueNumber == _dgde.ValueNumber {
			return _aafg
		}
		if _fgffd.ValueNumber < _dgde.ValueNumber {
			return _bcea
		}
		return _cdad
	}
	if _fgffd.Type == ResultTypeString {
		_aafc := _fgffd.ValueString
		_eegab := _dgde.ValueString
		if !_bed {
			_aafc = _ee.ToLower(_aafc)
			_eegab = _ee.ToLower(_eegab)
		}
		if _bfdce {
			_adgbc := _ag.Match(_eegab, _aafc)
			if _adgbc {
				return _aafg
			} else {
				return _cdad
			}
		}
		return cmpResult(_ee.Compare(_aafc, _eegab))
	}
	if _fgffd.Type == ResultTypeEmpty {
		return _aafg
	}
	if _fgffd.Type == ResultTypeList {
		if len(_fgffd.ValueList) < len(_dgde.ValueList) {
			return _bcea
		}
		if len(_fgffd.ValueList) > len(_dgde.ValueList) {
			return _cdad
		}
		for _ddbde := range _fgffd.ValueList {
			_ecfag := _gdgf(_fgffd.ValueList[_ddbde], _dgde.ValueList[_ddbde], _bed, _bfdce)
			if _ecfag != _aafg {
				return _ecfag
			}
		}
		return _aafg
	}
	if _fgffd.Type == ResultTypeList {
		if len(_fgffd.ValueArray) < len(_dgde.ValueArray) {
			return _bcea
		}
		if len(_fgffd.ValueArray) > len(_dgde.ValueArray) {
			return _cdad
		}
		for _begab := range _fgffd.ValueArray {
			_ceega := _fgffd.ValueArray[_begab]
			_afafc := _fgffd.ValueArray[_begab]
			if len(_ceega) < len(_afafc) {
				return _bcea
			}
			if len(_ceega) > len(_afafc) {
				return _cdad
			}
			for _abbc := range _ceega {
				_fbdd := _gdgf(_ceega[_abbc], _afafc[_abbc], _bed, _bfdce)
				if _fbdd != _aafg {
					return _fbdd
				}
			}
		}
		return _aafg
	}
	return _deecf
}

// CellRef is a reference to a single cell
type CellRef struct{ _bda string }

// Update updates the horizontal range references after removing a row/column.
func (_adcd HorizontalRange) Update(q *_cc.UpdateQuery) Expression { return _adcd }

var _ddddbe = [...]struct {
	_fafgc int
	_bgfbg int
	_dbagf string
}{}

// Coupdaysnc implements the Excel COUPDAYSNC function.
func Coupdaysnc(args []Result) Result {
	_deb, _bdfg := _dccda(args, "\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053\u004e\u0043")
	if _bdfg.Type == ResultTypeError {
		return _bdfg
	}
	return MakeNumberResult(_agg(_deb._ggbd, _deb._eedd, _deb._ecf, _deb._deagf))
}

func _ggca(_abag, _bee float64, _bfca, _gbade int) (float64, Result) {
	_acdb, _baae := _fae(_abag), _fae(_bee)
	if _baae.After(_acdb) {
		_ffbb := _dfcf(_acdb, _baae, _bfca, _gbade)
		_gdaa := (_baae.Year()-_ffbb.Year())*12 + int(_baae.Month()) - int(_ffbb.Month())
		return float64(_gdaa*_bfca) / 12.0, _ffe
	}
	return 0, MakeErrorResultType(ErrorTypeNum, "\u0053\u0065t\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065")
}

func (_eccd *evCache) GetFromCache(key string) (Result, bool) {
	_eccd._deag.Lock()
	_ac, _fdg := _eccd._cda[key]
	_eccd._deag.Unlock()
	return _ac, _fdg
}

// Update returns the same object as updating sheet references does not affect EmptyExpr.
func (_cec EmptyExpr) Update(q *_cc.UpdateQuery) Expression { return _cec }

const _gfcc = 57347

// Power is an implementation of the Excel POWER function that raises a number
// to a power. It requires two numeric arguments.
func Power(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_acafc := args[0].AsNumber()
	if _acafc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ecgc := args[1].AsNumber()
	if _ecgc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	return MakeNumberResult(_dc.Pow(_acafc.ValueNumber, _ecgc.ValueNumber))
}

type evCache struct {
	_cda  map[string]Result
	_deag *_f.Mutex
}

// ResultType is the type of the result
//go:generate stringer -type=ResultType
type ResultType byte

func (_cbad VerticalRange) verticalRangeReference() string {
	return _c.Sprintf("\u0025\u0073\u003a%\u0073", _cbad._efdad, _cbad._ddbe)
}

// Reference returns a string reference value to a range with prefix.
func (_adcf PrefixRangeExpr) Reference(ctx Context, ev Evaluator) Reference {
	_dcbe := _adcf._cgegf.Reference(ctx, ev)
	_fcfff := _adcf._gaga.Reference(ctx, ev)
	_fdgb := _adcf._dbaf.Reference(ctx, ev)
	if _dcbe.Type == ReferenceTypeSheet && _fcfff.Type == ReferenceTypeCell && _fdgb.Type == ReferenceTypeCell {
		return MakeRangeReference(_agbd(_dcbe, _fcfff, _fdgb))
	}
	return ReferenceInvalid
}

func _adcg() {
	_cgfd = _gf.MustCompile("\u005e\u0030\u002b\u0024")
	_ebe = _gf.MustCompile("\u005e\u0028\u0028\u0023|0\u0029\u002b\u002c\u0029\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u0028\u003b\u007c$\u0029")
	_gefgf = _gf.MustCompile("\u005e\u0028\u0023\u007c\u0030\u007c\u002c\u0029\u002a\u005f\u005c\u0029\u003b")
	_bfebg = _gf.MustCompile("\u005e\u0030\u002b\u005c\u002e\u0028\u0030\u002b\u0029\u0024")
	_caeed = _gf.MustCompile("\u005e\u0028\u0028\u0023\u007c\u0030\u0029\u002b\u002c\u0029+\u0028\u0023\u007c\u0030\u0029\u002b\u005c.\u0028\u0030\u002b\u0029\u002e\u002a\u0028\u003b\u007c\u0024\u0029")
	_dcfcfc = _gf.MustCompile("^\u0028\u005f\u007c\u002d\u007c\u0020)\u002b\u005c\u002a\u0020\u0023\u002b\u002c\u0023\u002b0\u005c\u002e\u00280\u002b)\u002e\u002a\u003b")
	_cgec = _gf.MustCompile("\u005e\u0028\u0028\u0023\u007c\u0030)\u002b\u002c\u0029\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u005c\u002e\u0028(\u0023\u007c\u0030\u0029\u002b\u0029\u005f\\\u0029\u002e\u002a\u003b")
	_decb = _gf.MustCompile("\u005e\u0028\u0023\u007c0)\u002b\u005c\u002e\u0028\u0028\u0023\u007c\u0030\u0029\u002b\u0029\u0025\u0024")
	_ffee = _gf.MustCompile("\u005c\u005b\u005c$\u005c\u0024\u002d\u002e+\u005c\u005d\u0028\u005c\u002a\u0020\u0029?\u0028\u0023\u007c\u0030\u0029\u002b\u002c\u0028\u0023\u007c\u0030\u0029\u002b\u003b")
	_ecbd = _gf.MustCompile("\u005c[\u005c\u0024\\\u0024\u002d\u002e+\u005c\u005d\u0028\u005c\u002a\u0020\u0029?\u0028\u0023\u007c\u0030\u0029\u002b,\u0028\u0023\u007c\u0030\u0029\u002b\u005c\u002e\u0028\u0028\u0023|\u0030\u007c\u002d\u0029\u002b\u0029\u002e\u002a\u003b")
	_gfcaf = _gf.MustCompile("\u005e(\u0028\u0023|\u0030\u0029\u002b,\u0029\u002b\u0028\u0023\u007c\u0030\u0029+\u0028\u005c\u002e\u0028\u0028\u0023|\u0030\u007c\u002d\u0029\u002b\u0029\u0029\u003f\u002e\u002b\u005c[\u005c\u0024\u002e\u002b\u005c\u005d\u002e\u002a\u003b")
	_acec = _gf.MustCompile("\u005e\u004d\u002b(\u002f\u007c\u0020\u007c\u002c\u007c\u0022\u007c" + _cdcea + _cdcea + "\u0029\u002b\u0044\u002b\u0028\u002f\u007c\u0020\u007c\u002c\u007c\u0022\u007c" + _cdcea + _cdcea + "\u0029\u002b\u0059+\u0024")
	_bdbf = _gf.MustCompile("\u005e\u0044\u002b\u0028\u002f\u007c\u0020\u007c\u005c\u002e\u007c\u0022\u007c" + _cdcea + _cdcea + "\u0029\u002b\u004d\u002b\u0028\u002f\u007c\u0020\u007c\\\u002e\u007c\u0022\u007c" + _cdcea + _cdcea + "\u0029\u002b\u0059+\u0024")
	_aegf = _gf.MustCompile("\u005e\u0028\u0023|\u0030\u0029\u002b\u005c.\u0028\u0028\u0023\u007c\u0030\u0029\u002a)\u0045\u005c\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u0028\u003b\u007c\u0024\u0029")
	_ffef = _gf.MustCompile("\u005e.\u002a\u005f\u005c\u0029\u002e\u002a;")
}

// Mduration implements the Excel MDURATION function.
func Mduration(args []Result) Result {
	_geebc, _befa := _cfag(args, "\u004dD\u0055\u0052\u0041\u0054\u0049\u004fN")
	if _befa.Type == ResultTypeError {
		return _befa
	}
	_cddc := _geebc._aedc
	_cgbb := _geebc._cfa
	_egbg := _geebc._dcfg
	_beac := _geebc._deec
	_dbfa := _geebc._bfgg
	_gbbc := _geebc._cadg
	_adff := _fec(_cddc, _cgbb, _egbg, _beac, _dbfa, _gbbc)
	if _adff.Type == ResultTypeError {
		return _adff
	}
	_eefdg := _adff.ValueNumber / (1.0 + _beac/_dbfa)
	return MakeNumberResult(_eefdg)
}

func (_dbbg *ivr) Sheet(name string) Context { return _dbbg }

func _cegca(_acaeb [][]Result, _eadag int) [][]Result {
	_ceea := [][]Result{}
	for _aggc := range _acaeb {
		if _aggc == 0 {
			continue
		}
		_cgdf := []Result{}
		for _feed := range _acaeb {
			if _feed == _eadag {
				continue
			}
			_cgdf = append(_cgdf, _acaeb[_aggc][_feed])
		}
		_ceea = append(_ceea, _cgdf)
	}
	return _ceea
}

const _gdccc = 57358

// Fvschedule implements the Excel FVSCHEDULE function.
func Fvschedule(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045D\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048E\u0044\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0070\u0072\u0069\u006e\u0063\u0069\u0070\u0061\u006c\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_eaae := args[0].ValueNumber
	switch args[1].Type {
	case ResultTypeNumber:
		return MakeNumberResult(_eaae * (args[1].ValueNumber + 1))
	case ResultTypeList, ResultTypeArray:
		_egec := _cdafd(args[1])
		for _, _gcg := range _egec {
			for _, _caac := range _gcg {
				if _caac.Type != ResultTypeNumber || _caac.IsBoolean {
					return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0073")
				}
				_eaae *= 1.0 + _caac.ValueNumber
			}
		}
		return MakeNumberResult(_eaae)
	default:
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0063\u0068\u0065\u0064\u0075\u006c\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0072\u0020\u0061\u0072\u0072a\u0079\u0020\u0074y\u0070\u0065")
	}
}

// CeilingMath implements _xlfn.CEILING.MATH which rounds numbers to the nearest
// multiple of the second argument, toward or away from zero as specified by the
// third argument.
func CeilingMath(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043E\u0049\u004cI\u004e\u0047\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006ee\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0043E\u0049\u004cI\u004e\u0047\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u0061l\u006c\u006f\u0077\u0073\u0020\u0061t\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_ecge := args[0].AsNumber()
	if _ecge.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u004dA\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061 \u006eu\u006d\u0062\u0065\u0072")
	}
	_ceeb := float64(1)
	if _ecge.ValueNumber < 0 {
		_ceeb = -1
	}
	if len(args) > 1 {
		_bdgcc := args[1].AsNumber()
		if _bdgcc.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0043\u0045\u0049\u004c\u0049\u004e\u0047.\u004d\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_ceeb = _bdgcc.ValueNumber
	}
	_dfbge := float64(1)
	if len(args) > 2 {
		_bfdga := args[2].AsNumber()
		if _bfdga.Type != ResultTypeNumber {
			return MakeErrorResult("\u0074\u0068\u0069\u0072\u0064\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u004dA\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061 \u006eu\u006d\u0062\u0065\u0072")
		}
		_dfbge = _bfdga.ValueNumber
	}
	if len(args) == 1 {
		return MakeNumberResult(_dc.Ceil(_ecge.ValueNumber))
	}
	_fgag := _ecge.ValueNumber
	_fgag, _abddf := _dc.Modf(_fgag / _ceeb)
	if _abddf != 0 {
		if _ecge.ValueNumber > 0 {
			_fgag++
		} else if _dfbge < 0 {
			_fgag--
		}
	}
	return MakeNumberResult(_fgag * _ceeb)
}

// Eval evaluates and returns the result of a formula.
func (_ddc *defEval) Eval(ctx Context, formula string) Result {
	_egg := ParseString(formula)
	if _egg != nil {
		_ddc.checkLastEvalIsRef(ctx, _egg)
		_ced := _egg.Eval(ctx, _ddc)
		return _ced
	}
	return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070a\u0072\u0073\u0065\u0020\u0066\u006f\u0072\u006d\u0075\u006ca\u0020\u0025\u0073", formula))
}

func _ebcfc(_cbdbg []Result, _dadf rmode) Result {
	if len(_cbdbg) != 2 {
		return MakeErrorResult("\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_abgae := _cbdbg[0].AsNumber()
	if _abgae.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ecga := _cbdbg[1].AsNumber()
	if _ecga.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_bgad := _ecga.ValueNumber
	_ddgc := _abgae.ValueNumber
	_beae := 1.0
	if _bgad > 0 {
		_beae = _dc.Pow(1/10.0, _bgad)
	} else {
		_beae = _dc.Pow(10.0, -_bgad)
	}
	_ddgc, _fcbb := _dc.Modf(_ddgc / _beae)
	switch _dadf {
	case _aabe:
		const _gead = 0.499999999
		if _fcbb >= _gead {
			_ddgc++
		} else if _fcbb <= -_gead {
			_ddgc--
		}
	case _eecgb:
	case _agcbg:
		if _fcbb > 0 {
			_ddgc++
		} else if _fcbb < 0 {
			_ddgc--
		}
	}
	return MakeNumberResult(_ddgc * _beae)
}

func _bccga(_fgee float64) bool { return _fgee == 1 || _fgee == 2 || _fgee == 4 }

func (_baedb HorizontalRange) horizontalRangeReference() string {
	return _c.Sprintf("\u0025\u0064\u003a%\u0064", _baedb._ddgg, _baedb._aabf)
}

const _cfaagc = 57376

// GetEpoch returns a null time object for the invalid reference context.
func (_baefd *ivr) GetEpoch() _ce.Time { return _ce.Time{} }
