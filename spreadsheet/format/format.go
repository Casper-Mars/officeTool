//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format

import (
	_f "bytes"
	_d "fmt"
	_a "github.com/Casper-Mars/officeTool"
	_dg "io"
	_df "math"
	_e "strconv"
	_be "strings"
	_g "time"
)

const _dbc int = 34

const (
	FmtTypeLiteral FmtType = iota
	FmtTypeDigit
	FmtTypeDigitOpt
	FmtTypeComma
	FmtTypeDecimal
	FmtTypePercent
	FmtTypeDollar
	FmtTypeDigitOptThousands
	FmtTypeUnderscore
	FmtTypeDate
	FmtTypeTime
	FmtTypeFraction
	FmtTypeText
)

func _ecad(_bafa _g.Time) _g.Time {
	_bafa = _bafa.UTC()
	return _g.Date(_bafa.Year(), _bafa.Month(), _bafa.Day(), _bafa.Hour(), _bafa.Minute(), _bafa.Second(), _bafa.Nanosecond(), _g.Local)
}

const _faf int = 34

const _ag = 1e11

func (_fe FmtType) String() string {
	if _fe >= FmtType(len(_c)-1) {
		return _d.Sprintf("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029", _fe)
	}
	return _ec[_c[_fe]:_c[_fe+1]]
}

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String(v string, f string) string {
	_bbe := Parse(f)
	var _bbb Format
	if len(_bbe) == 1 {
		_bbb = _bbe[0]
	} else if len(_bbe) == 4 {
		_bbb = _bbe[3]
	}
	_bebd := false
	for _, _fa := range _bbb.Whole {
		if _fa.Type == FmtTypeText {
			_bebd = true
		}
	}
	if !_bebd {
		return v
	}
	_fbf := _f.Buffer{}
	for _, _ee := range _bbb.Whole {
		switch _ee.Type {
		case FmtTypeLiteral:
			_fbf.WriteByte(_ee.Literal)
		case FmtTypeText:
			_fbf.WriteString(v)
		}
	}
	return _fbf.String()
}

func _gedf(_gbd float64) string {
	_dcc := _e.FormatFloat(_gbd, 'E', -1, 64)
	_fac := _e.FormatFloat(_gbd, 'E', 5, 64)
	if len(_dcc) < len(_fac) {
		return _e.FormatFloat(_gbd, 'E', 2, 64)
	}
	return _fac
}

func _gedd(_cfd, _adf float64, _cb Format) []byte {
	if len(_cb.Whole) == 0 {
		return nil
	}
	_dgdg := _g.Date(1899, 12, 30, 0, 0, 0, 0, _g.UTC)
	_gcf := _dgdg.Add(_g.Duration(_adf * float64(24*_g.Hour)))
	_gcf = _ecad(_gcf)
	_cfg := _e.AppendFloat(nil, _cfd, 'f', -1, 64)
	_baf := make([]byte, 0, len(_cfg))
	_abda := 0
	_deb := 1
_cff:
	for _cg := len(_cb.Whole) - 1; _cg >= 0; _cg-- {
		_ccb := len(_cfg) - 1 - _abda
		_gaf := _cb.Whole[_cg]
		switch _gaf.Type {
		case FmtTypeDigit:
			if _ccb >= 0 {
				_baf = append(_baf, _cfg[_ccb])
				_abda++
				_deb = _cg
			} else {
				_baf = append(_baf, '0')
			}
		case FmtTypeDigitOpt:
			if _ccb >= 0 {
				_baf = append(_baf, _cfg[_ccb])
				_abda++
				_deb = _cg
			} else {
				for _bdad := _cg; _bdad >= 0; _bdad-- {
					_eg := _cb.Whole[_bdad]
					if _eg.Type == FmtTypeLiteral {
						_baf = append(_baf, _eg.Literal)
					}
				}
				break _cff
			}
		case FmtTypeDollar:
			for _aa := _abda; _aa < len(_cfg); _aa++ {
				_baf = append(_baf, _cfg[len(_cfg)-1-_aa])
				_abda++
			}
			_baf = append(_baf, '$')
		case FmtTypeComma:
			if !_cb._ab {
				_baf = append(_baf, ',')
			}
		case FmtTypeLiteral:
			_baf = append(_baf, _gaf.Literal)
		case FmtTypeDate:
			_baf = append(_baf, _ef(_adfc(_gcf, _gaf.DateTime))...)
		case FmtTypeTime:
			_baf = append(_baf, _ef(_gcab(_gcf, _adf, _gaf.DateTime))...)
		default:
			_a.Log("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076", _gaf)
		}
	}
	_baa := _ef(_baf)
	if _abda < len(_cfg) && (_abda != 0 || _cb._cf) {
		_cbc := len(_cfg) - _abda
		_bde := make([]byte, len(_baa)+_cbc)
		copy(_bde, _baa[0:_deb])
		copy(_bde[_deb:], _cfg[0:])
		copy(_bde[_deb+_cbc:], _baa[_deb:])
		_baa = _bde
	}
	if _cb._ab {
		_baff := _f.Buffer{}
		_eeg := 0
		for _efg := len(_baa) - 1; _efg >= 0; _efg-- {
			if !(_baa[_efg] >= '0' && _baa[_efg] <= '9') {
				_eeg++
			} else {
				break
			}
		}
		for _ea := 0; _ea < len(_baa); _ea++ {
			_dag := (len(_baa) - _ea - _eeg)
			if _dag%3 == 0 && _dag != 0 && _ea != 0 {
				_baff.WriteByte(',')
			}
			_baff.WriteByte(_baa[_ea])
		}
		_baa = _baff.Bytes()
	}
	return _baa
}

// Token is a format token in the Excel format string.
type Token struct {
	Type     FmtType
	Literal  byte
	DateTime string
}

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value(v string, f string) string {
	if IsNumber(v) {
		_ga, _ := _e.ParseFloat(v, 64)
		return Number(_ga, f)
	}
	return String(v, f)
}

const _dce int = 34

func _bcd(_bebg int64, _gea Format) []byte {
	if !_gea.IsExponential || len(_gea.Exponent) == 0 {
		return nil
	}
	_gbg := _e.AppendInt(nil, _fc(_bebg), 10)
	_eeb := make([]byte, 0, len(_gbg)+2)
	_eeb = append(_eeb, 'E')
	if _bebg >= 0 {
		_eeb = append(_eeb, '+')
	} else {
		_eeb = append(_eeb, '-')
		_bebg *= -1
	}
	_gfe := 0
_cab:
	for _gfa := len(_gea.Exponent) - 1; _gfa >= 0; _gfa-- {
		_gfaf := len(_gbg) - 1 - _gfe
		_dc := _gea.Exponent[_gfa]
		switch _dc.Type {
		case FmtTypeDigit:
			if _gfaf >= 0 {
				_eeb = append(_eeb, _gbg[_gfaf])
				_gfe++
			} else {
				_eeb = append(_eeb, '0')
			}
		case FmtTypeDigitOpt:
			if _gfaf >= 0 {
				_eeb = append(_eeb, _gbg[_gfaf])
				_gfe++
			} else {
				for _cbb := _gfa; _cbb >= 0; _cbb-- {
					_cfc := _gea.Exponent[_cbb]
					if _cfc.Type == FmtTypeLiteral {
						_eeb = append(_eeb, _cfc.Literal)
					}
				}
				break _cab
			}
		case FmtTypeLiteral:
			_eeb = append(_eeb, _dc.Literal)
		default:
			_a.Log("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076", _dc)
		}
	}
	if _gfe < len(_gbg) {
		_eeb = append(_eeb, _gbg[len(_gbg)-_gfe-1:_gfe-1]...)
	}
	_ef(_eeb[2:])
	return _eeb
}

const _aea int = -1

func _gd(_bfd []byte) []byte {
	for _ce := len(_bfd) - 1; _ce > 0; _ce-- {
		if _bfd[_ce] == '9'+1 {
			_bfd[_ce] = '0'
			if _bfd[_ce-1] == '.' {
				_ce--
			}
			_bfd[_ce-1]++
		}
	}
	if _bfd[0] == '9'+1 {
		_bfd[0] = '0'
		copy(_bfd[1:], _bfd[0:])
		_bfd[0] = '1'
	}
	return _bfd
}

func _ge(_gb float64, _dgd Format, _dd bool) string {
	if _dgd._bb {
		return NumberGeneric(_gb)
	}
	_ged := make([]byte, 0, 20)
	_fg := _df.Signbit(_gb)
	_eec := _df.Abs(_gb)
	_fdc := int64(0)
	_bd := int64(0)
	if _dgd.IsExponential {
		for _eec >= 10 {
			_bd++
			_eec /= 10
		}
		for _eec < 1 {
			_bd--
			_eec *= 10
		}
	} else if _dgd._ca {
		_eec *= 100
	} else if _dgd._cc {
		if _dgd._af == 0 {
			_bc := _df.Pow(10, float64(_dgd._ad))
			_bdb, _dff := 1.0, 1.0
			_ = _bdb
			for _ecd := 1.0; _ecd < _bc; _ecd++ {
				_, _gc := _df.Modf(_eec * float64(_ecd))
				if _gc < _dff {
					_dff = _gc
					_bdb = _ecd
					if _gc == 0 {
						break
					}
				}
			}
			_dgd._af = int64(_bdb)
		}
		_fdc = int64(_eec*float64(_dgd._af) + 0.5)
		if len(_dgd.Whole) > 0 && _fdc > _dgd._af {
			_fdc = int64(_eec*float64(_dgd._af)) % _dgd._af
			_eec -= float64(_fdc) / float64(_dgd._af)
		} else {
			_eec -= float64(_fdc) / float64(_dgd._af)
			if _df.Abs(_eec) < 1 {
				_bda := true
				for _, _cca := range _dgd.Whole {
					if _cca.Type == FmtTypeDigitOpt {
						continue
					}
					if _cca.Type == FmtTypeLiteral && _cca.Literal == ' ' {
						continue
					}
					_bda = false
				}
				if _bda {
					_dgd.Whole = nil
				}
			}
		}
	}
	_fbe := 1
	for _, _dab := range _dgd.Fractional {
		if _dab.Type == FmtTypeDigit || _dab.Type == FmtTypeDigitOpt {
			_fbe++
		}
	}
	_eec += 5 * _df.Pow10(-_fbe)
	_ae, _bfe := _df.Modf(_eec)
	_ged = append(_ged, _gedd(_ae, _gb, _dgd)...)
	_ged = append(_ged, _gf(_bfe, _gb, _dgd)...)
	_ged = append(_ged, _bcd(_bd, _dgd)...)
	if _dgd._cc {
		_ged = _e.AppendInt(_ged, _fdc, 10)
		_ged = append(_ged, '/')
		_ged = _e.AppendInt(_ged, _dgd._af, 10)
	}
	if !_dd && _fg {
		return "\u002d" + string(_ged)
	}
	return string(_ged)
}

func _gf(_ff, _ggg float64, _fab Format) []byte {
	if len(_fab.Fractional) == 0 {
		return nil
	}
	_feb := _e.AppendFloat(nil, _ff, 'f', -1, 64)
	if len(_feb) > 2 {
		_feb = _feb[2:]
	} else {
		_feb = nil
	}
	_edd := make([]byte, 0, len(_feb))
	_edd = append(_edd, '.')
	_bcb := 0
_ccbe:
	for _eb := 0; _eb < len(_fab.Fractional); _eb++ {
		_fbg := _eb
		_cga := _fab.Fractional[_eb]
		switch _cga.Type {
		case FmtTypeDigit:
			if _fbg < len(_feb) {
				_edd = append(_edd, _feb[_fbg])
				_bcb++
			} else {
				_edd = append(_edd, '0')
			}
		case FmtTypeDigitOpt:
			if _fbg >= 0 {
				_edd = append(_edd, _feb[_fbg])
				_bcb++
			} else {
				break _ccbe
			}
		case FmtTypeLiteral:
			_edd = append(_edd, _cga.Literal)
		default:
			_a.Log("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076", _cga)
		}
	}
	return _edd
}

func _gcab(_dabg _g.Time, _gfb float64, _fgf string) []byte {
	_dga := []byte{}
	_fec := 0
	for _dbd := 0; _dbd < len(_fgf); _dbd++ {
		var _bad string
		if _fgf[_dbd] == ':' {
			_bad = string(_fgf[_fec:_dbd])
			_fec = _dbd + 1
		} else if _dbd == len(_fgf)-1 {
			_bad = string(_fgf[_fec : _dbd+1])
		} else {
			continue
		}
		switch _bad {
		case "\u0064":
			_dga = _dabg.AppendFormat(_dga, "\u0032")
		case "\u0068":
			_dga = _dabg.AppendFormat(_dga, "\u0033")
		case "\u0068\u0068":
			_dga = _dabg.AppendFormat(_dga, "\u0031\u0035")
		case "\u006d":
			_dga = _dabg.AppendFormat(_dga, "\u0034")
		case "\u006d\u006d":
			_dga = _dabg.AppendFormat(_dga, "\u0030\u0034")
		case "\u0073":
			_dga = _dabg.Round(_g.Second).AppendFormat(_dga, "\u0035")
		case "\u0073\u002e\u0030":
			_dga = _dabg.Round(_g.Second/10).AppendFormat(_dga, "\u0035\u002e\u0030")
		case "\u0073\u002e\u0030\u0030":
			_dga = _dabg.Round(_g.Second/100).AppendFormat(_dga, "\u0035\u002e\u0030\u0030")
		case "\u0073\u002e\u00300\u0030":
			_dga = _dabg.Round(_g.Second/1000).AppendFormat(_dga, "\u0035\u002e\u00300\u0030")
		case "\u0073\u0073":
			_dga = _dabg.Round(_g.Second).AppendFormat(_dga, "\u0030\u0035")
		case "\u0073\u0073\u002e\u0030":
			_dga = _dabg.Round(_g.Second/10).AppendFormat(_dga, "\u0030\u0035\u002e\u0030")
		case "\u0073\u0073\u002e0\u0030":
			_dga = _dabg.Round(_g.Second/100).AppendFormat(_dga, "\u0030\u0035\u002e0\u0030")
		case "\u0073\u0073\u002e\u0030\u0030\u0030":
			_dga = _dabg.Round(_g.Second/1000).AppendFormat(_dga, "\u0030\u0035\u002e\u0030\u0030\u0030")
		case "\u0041\u004d\u002fP\u004d":
			_dga = _dabg.AppendFormat(_dga, "\u0050\u004d")
		case "\u005b\u0068\u005d":
			_dga = _e.AppendInt(_dga, int64(_gfb*24), 10)
		case "\u005b\u006d\u005d":
			_dga = _e.AppendInt(_dga, int64(_gfb*24*60), 10)
		case "\u005b\u0073\u005d":
			_dga = _e.AppendInt(_dga, int64(_gfb*24*60*60), 10)
		case "":
		default:
			_a.Log("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073", _bad)
		}
		if _fgf[_dbd] == ':' {
			_dga = append(_dga, ':')
		}
	}
	return _dga
}

type Lexer struct {
	_gefd Format
	_ddeb []Format
}

func _fc(_cfb int64) int64 {
	if _cfb < 0 {
		return -_cfb
	}
	return _cfb
}

const _dbdb int = -1

const _gfea int = 0

const _ec = "\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074"

func _ef(_bf []byte) []byte {
	for _bfc := 0; _bfc < len(_bf)/2; _bfc++ {
		_ed := len(_bf) - 1 - _bfc
		_bf[_bfc], _bf[_ed] = _bf[_ed], _bf[_bfc]
	}
	return _bf
}

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number(v float64, f string) string {
	if f == "" || f == "\u0047e\u006e\u0065\u0072\u0061\u006c" || f == "\u0040" {
		return NumberGeneric(v)
	}
	_fd := Parse(f)
	if len(_fd) == 1 {
		return _ge(v, _fd[0], false)
	} else if len(_fd) > 1 && v < 0 {
		return _ge(v, _fd[1], true)
	} else if len(_fd) > 2 && v == 0 {
		return _ge(v, _fd[2], false)
	}
	return _ge(v, _fd[0], false)
}

func _fed(_cd []byte) []byte {
	_fcd := len(_cd)
	_dfc := false
	_bg := false
	for _gggg := len(_cd) - 1; _gggg >= 0; _gggg-- {
		if _cd[_gggg] == '0' && !_bg && !_dfc {
			_fcd = _gggg
		} else if _cd[_gggg] == '.' {
			_dfc = true
		} else {
			_bg = true
		}
	}
	if _dfc && _bg {
		if _cd[_fcd-1] == '.' {
			_fcd--
		}
		return _cd[0:_fcd]
	}
	return _cd
}

func (_dade *Lexer) nextFmt() {
	_dade._ddeb = append(_dade._ddeb, _dade._gefd)
	_dade._gefd = Format{}
}

func Parse(s string) []Format {
	_aga := Lexer{}
	_aga.Lex(_be.NewReader(s))
	_aga._ddeb = append(_aga._ddeb, _aga._gefd)
	return _aga._ddeb
}

func (_edf *Lexer) Lex(r _dg.Reader) {
	_fbga, _agf, _ggga := 0, 0, 0
	_bcc := -1
	_ffb, _gbgb, _dfb := 0, 0, 0
	_ = _gbgb
	_ = _dfb
	_ade := 1
	_ = _ade
	_eebe := make([]byte, 4096)
	_faa := false
	for !_faa {
		_bbad := 0
		if _ffb > 0 {
			_bbad = _agf - _ffb
		}
		_agf = 0
		_aae, _egg := r.Read(_eebe[_bbad:])
		if _aae == 0 || _egg != nil {
			_faa = true
		}
		_ggga = _aae + _bbad
		if _ggga < len(_eebe) {
			_bcc = _ggga
		}
		{
			_fbga = _dce
			_ffb = 0
			_gbgb = 0
			_dfb = 0
		}
		{
			if _agf == _ggga {
				goto _abdg
			}
			switch _fbga {
			case 34:
				goto _ccd
			case 35:
				goto _abf
			case 0:
				goto _fbgf
			case 36:
				goto _ccdg
			case 37:
				goto _bgg
			case 1:
				goto _ace
			case 2:
				goto _bdab
			case 38:
				goto _dbba
			case 3:
				goto _ggb
			case 4:
				goto _daa
			case 39:
				goto _gggf
			case 5:
				goto _gbgfc
			case 6:
				goto _dagg
			case 7:
				goto _fefb
			case 8:
				goto _cfce
			case 40:
				goto _bgc
			case 9:
				goto _dda
			case 41:
				goto _gcacg
			case 10:
				goto _bagb
			case 42:
				goto _fca
			case 11:
				goto _ece
			case 43:
				goto _ebg
			case 44:
				goto _ceb
			case 45:
				goto _gfbd
			case 12:
				goto _dgb
			case 46:
				goto _fdg
			case 13:
				goto _abb
			case 14:
				goto _fbgd
			case 15:
				goto _fdga
			case 16:
				goto _gcd
			case 47:
				goto _ced
			case 17:
				goto _bbbd
			case 48:
				goto _agg
			case 18:
				goto _eee
			case 19:
				goto _gaa
			case 20:
				goto _fecd
			case 49:
				goto _bdf
			case 50:
				goto _dfad
			case 21:
				goto _aab
			case 22:
				goto _dbbb
			case 23:
				goto _ebeb
			case 24:
				goto _efdb
			case 25:
				goto _dae
			case 51:
				goto _fdd
			case 26:
				goto _fbee
			case 52:
				goto _ceec
			case 53:
				goto _aggb
			case 54:
				goto _eeed
			case 55:
				goto _agc
			case 56:
				goto _gbdf
			case 57:
				goto _gbee
			case 27:
				goto _ceg
			case 28:
				goto _eba
			case 29:
				goto _gaea
			case 30:
				goto _gdf
			case 31:
				goto _dcaa
			case 58:
				goto _dgdf
			case 32:
				goto _cdde
			case 59:
				goto _eca
			case 33:
				goto _fcc
			case 60:
				goto _gfc
			case 61:
				goto _cdf
			case 62:
				goto _gcdf
			}
			goto _bfb
		_dfd:
			switch _dfb {
			case 2:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypeDigit, nil)
				}
			case 3:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypeDigitOpt, nil)
				}
			case 5:
				{
					_agf = (_gbgb) - 1
				}
			case 8:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypePercent, nil)
				}
			case 13:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypeFraction, _eebe[_ffb:_gbgb])
				}
			case 14:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypeDate, _eebe[_ffb:_gbgb])
				}
			case 15:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypeTime, _eebe[_ffb:_gbgb])
				}
			case 16:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypeTime, _eebe[_ffb:_gbgb])
				}
			case 18:
				{
					_agf = (_gbgb) - 1
				}
			case 20:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypeLiteral, _eebe[_ffb:_gbgb])
				}
			case 21:
				{
					_agf = (_gbgb) - 1
					_edf._gefd.AddToken(FmtTypeLiteral, _eebe[_ffb+1:_gbgb-1])
				}
			}
			goto _gafg
		_bab:
			_agf = (_gbgb) - 1
			{
				_edf._gefd.AddToken(FmtTypeFraction, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_aagb:
			_agf = (_gbgb) - 1
			{
				_edf._gefd.AddToken(FmtTypeDigitOpt, nil)
			}
			goto _gafg
		_adc:
			_gbgb = _agf + 1
			{
				_edf._gefd.AddToken(FmtTypeDigitOptThousands, nil)
			}
			goto _gafg
		_cgef:
			_agf = (_gbgb) - 1
			{
				_edf._gefd.AddToken(FmtTypePercent, nil)
			}
			goto _gafg
		_cde:
			_agf = (_gbgb) - 1
			{
				_edf._gefd.AddToken(FmtTypeDate, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_gdd:
			_agf = (_gbgb) - 1
			{
				_edf._gefd.AddToken(FmtTypeDigit, nil)
			}
			goto _gafg
		_eggf:
			_agf = (_gbgb) - 1
			{
				_edf._gefd.AddToken(FmtTypeTime, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_fdb:
			_agf = (_gbgb) - 1
			{
				_edf._gefd.AddToken(FmtTypeLiteral, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_dadg:
			_gbgb = _agf + 1
			{
				_edf._gefd._bb = true
			}
			goto _gafg
		_dca:
			_gbgb = _agf + 1
			{
				_edf._gefd.AddToken(FmtTypeLiteral, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_fga:
			_gbgb = _agf + 1
			{
				_edf._gefd.AddToken(FmtTypeDollar, nil)
			}
			goto _gafg
		_dbb:
			_gbgb = _agf + 1
			{
				_edf._gefd.AddToken(FmtTypeComma, nil)
			}
			goto _gafg
		_cee:
			_gbgb = _agf + 1
			{
				_edf._gefd.AddToken(FmtTypeDecimal, nil)
			}
			goto _gafg
		_gad:
			_gbgb = _agf + 1
			{
				_edf.nextFmt()
			}
			goto _gafg
		_fce:
			_gbgb = _agf + 1
			{
				_edf._gefd.AddToken(FmtTypeText, nil)
			}
			goto _gafg
		_caea:
			_gbgb = _agf + 1
			{
				_edf._gefd.AddToken(FmtTypeUnderscore, nil)
			}
			goto _gafg
		_ebd:
			_gbgb = _agf
			_agf--
			{
				_edf._gefd.AddToken(FmtTypeLiteral, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_bdef:
			_gbgb = _agf
			_agf--
			{
				_edf._gefd.AddToken(FmtTypeLiteral, _eebe[_ffb+1:_gbgb-1])
			}
			goto _gafg
		_agef:
			_gbgb = _agf
			_agf--
			{
				_edf._gefd.AddToken(FmtTypeDigitOpt, nil)
			}
			goto _gafg
		_bgd:
			_gbgb = _agf
			_agf--
			{
				_edf._gefd.AddToken(FmtTypeFraction, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_bbca:
			_gbgb = _agf
			_agf--
			{
				_edf._gefd.AddToken(FmtTypePercent, nil)
			}
			goto _gafg
		_aad:
			_gbgb = _agf
			_agf--
			{
				_edf._gefd.AddToken(FmtTypeDate, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_ddd:
			_gbgb = _agf
			_agf--
			{
				_edf._gefd.AddToken(FmtTypeDigit, nil)
			}
			goto _gafg
		_dcca:
			_gbgb = _agf
			_agf--
			{
				_edf._gefd.AddToken(FmtTypeTime, _eebe[_ffb:_gbgb])
			}
			goto _gafg
		_edca:
			_gbgb = _agf
			_agf--
			{
			}
			goto _gafg
		_dece:
			_gbgb = _agf + 1
			{
				_edf._gefd.IsExponential = true
			}
			goto _gafg
		_gcac:
			_gbgb = _agf + 1
			{
				_edf._gefd.AddToken(FmtTypeLiteral, _eebe[_ffb+1:_gbgb])
			}
			goto _gafg
		_gafg:
			_ffb = 0
			if _agf++; _agf == _ggga {
				goto _ggd
			}
		_ccd:
			_ffb = _agf
			switch _eebe[_agf] {
			case 34:
				goto _gdb
			case 35:
				goto _egf
			case 36:
				goto _fga
			case 37:
				goto _gcbd
			case 44:
				goto _dbb
			case 46:
				goto _cee
			case 47:
				goto _ebde
			case 48:
				goto _bebgg
			case 58:
				goto _fgfe
			case 59:
				goto _gad
			case 63:
				goto _ecbc
			case 64:
				goto _fce
			case 65:
				goto _cebf
			case 69:
				goto _beba
			case 71:
				goto _aeg
			case 91:
				goto _abg
			case 92:
				goto _abfe
			case 95:
				goto _caea
			case 100:
				goto _ebde
			case 104:
				goto _fgfe
			case 109:
				goto _ecc
			case 115:
				goto _fcda
			case 121:
				goto _aegf
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _fda
			}
			goto _dca
		_gdb:
			_gbgb = _agf + 1
			_dfb = 20
			goto _eff
		_eff:
			if _agf++; _agf == _ggga {
				goto _cffb
			}
		_abf:
			if _eebe[_agf] == 34 {
				goto _aeag
			}
			goto _cgf
		_cgf:
			if _agf++; _agf == _ggga {
				goto _aba
			}
		_fbgf:
			if _eebe[_agf] == 34 {
				goto _aeag
			}
			goto _cgf
		_aeag:
			_gbgb = _agf + 1
			_dfb = 21
			goto _cbe
		_cbe:
			if _agf++; _agf == _ggga {
				goto _dbf
			}
		_ccdg:
			if _eebe[_agf] == 34 {
				goto _cgf
			}
			goto _bdef
		_egf:
			_gbgb = _agf + 1
			_dfb = 3
			goto _ege
		_ege:
			if _agf++; _agf == _ggga {
				goto _bgdg
			}
		_bgg:
			switch _eebe[_agf] {
			case 35:
				goto _fgg
			case 37:
				goto _fgg
			case 44:
				goto _ccg
			case 47:
				goto _bag
			case 48:
				goto _fgg
			case 63:
				goto _fgg
			}
			goto _agef
		_fgg:
			if _agf++; _agf == _ggga {
				goto _dabf
			}
		_ace:
			switch _eebe[_agf] {
			case 35:
				goto _fgg
			case 37:
				goto _fgg
			case 47:
				goto _bag
			case 48:
				goto _fgg
			case 63:
				goto _fgg
			}
			goto _dfd
		_bag:
			if _agf++; _agf == _ggga {
				goto _ega
			}
		_bdab:
			switch _eebe[_agf] {
			case 35:
				goto _afc
			case 37:
				goto _agda
			case 48:
				goto _bbbg
			case 63:
				goto _afc
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _afd
			}
			goto _dfd
		_afc:
			_gbgb = _agf + 1
			goto _fef
		_fef:
			if _agf++; _agf == _ggga {
				goto _aaea
			}
		_dbba:
			switch _eebe[_agf] {
			case 35:
				goto _afc
			case 37:
				goto _afc
			case 44:
				goto _afc
			case 46:
				goto _afc
			case 48:
				goto _afc
			case 63:
				goto _afc
			case 65:
				goto _agaa
			}
			goto _bgd
		_agaa:
			if _agf++; _agf == _ggga {
				goto _fedb
			}
		_ggb:
			switch _eebe[_agf] {
			case 47:
				goto _dee
			case 77:
				goto _efc
			}
			goto _bab
		_dee:
			if _agf++; _agf == _ggga {
				goto _fdff
			}
		_daa:
			if _eebe[_agf] == 80 {
				goto _acb
			}
			goto _bab
		_acb:
			_gbgb = _agf + 1
			goto _ffc
		_ffc:
			if _agf++; _agf == _ggga {
				goto _fbbb
			}
		_gggf:
			if _eebe[_agf] == 65 {
				goto _agaa
			}
			goto _bgd
		_efc:
			if _agf++; _agf == _ggga {
				goto _adcf
			}
		_gbgfc:
			if _eebe[_agf] == 47 {
				goto _dfbe
			}
			goto _bab
		_dfbe:
			if _agf++; _agf == _ggga {
				goto _cddg
			}
		_dagg:
			if _eebe[_agf] == 80 {
				goto _fdf
			}
			goto _bab
		_fdf:
			if _agf++; _agf == _ggga {
				goto _ccba
			}
		_fefb:
			if _eebe[_agf] == 77 {
				goto _acb
			}
			goto _bab
		_agda:
			if _agf++; _agf == _ggga {
				goto _gbf
			}
		_cfce:
			switch _eebe[_agf] {
			case 35:
				goto _bae
			case 37:
				goto _acg
			case 63:
				goto _bae
			}
			if 48 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _efb
			}
			goto _dfd
		_bae:
			_gbgb = _agf + 1
			goto _dadc
		_dadc:
			if _agf++; _agf == _ggga {
				goto _cffd
			}
		_bgc:
			switch _eebe[_agf] {
			case 35:
				goto _afc
			case 37:
				goto _abc
			case 44:
				goto _afc
			case 46:
				goto _afc
			case 48:
				goto _afc
			case 63:
				goto _afc
			case 65:
				goto _agaa
			}
			goto _bgd
		_abc:
			if _agf++; _agf == _ggga {
				goto _bdag
			}
		_dda:
			switch _eebe[_agf] {
			case 35:
				goto _aeb
			case 44:
				goto _aeb
			case 46:
				goto _aeb
			case 48:
				goto _aeb
			case 63:
				goto _aeb
			}
			goto _bab
		_aeb:
			_gbgb = _agf + 1
			goto _dcfd
		_dcfd:
			if _agf++; _agf == _ggga {
				goto _gdgb
			}
		_gcacg:
			switch _eebe[_agf] {
			case 35:
				goto _aeb
			case 44:
				goto _aeb
			case 46:
				goto _aeb
			case 48:
				goto _aeb
			case 63:
				goto _aeb
			case 65:
				goto _agaa
			}
			goto _bgd
		_acg:
			if _agf++; _agf == _ggga {
				goto _acce
			}
		_bagb:
			if _eebe[_agf] == 37 {
				goto _acg
			}
			if 48 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _efb
			}
			goto _dfd
		_efb:
			_gbgb = _agf + 1
			_dfb = 13
			goto _daag
		_daag:
			if _agf++; _agf == _ggga {
				goto _bggb
			}
		_fca:
			switch _eebe[_agf] {
			case 35:
				goto _afc
			case 37:
				goto _cfcb
			case 44:
				goto _afc
			case 46:
				goto _afc
			case 48:
				goto _ffa
			case 63:
				goto _afc
			case 65:
				goto _agaa
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _efb
			}
			goto _bgd
		_cfcb:
			if _agf++; _agf == _ggga {
				goto _fafac
			}
		_ece:
			switch _eebe[_agf] {
			case 35:
				goto _aeb
			case 37:
				goto _acg
			case 44:
				goto _aeb
			case 46:
				goto _aeb
			case 63:
				goto _aeb
			}
			if 48 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _efb
			}
			goto _bab
		_ffa:
			_gbgb = _agf + 1
			goto _aagg
		_aagg:
			if _agf++; _agf == _ggga {
				goto _cbcd
			}
		_ebg:
			switch _eebe[_agf] {
			case 35:
				goto _afc
			case 37:
				goto _ffa
			case 44:
				goto _afc
			case 46:
				goto _afc
			case 48:
				goto _ffa
			case 63:
				goto _afc
			case 65:
				goto _agaa
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _efb
			}
			goto _bgd
		_bbbg:
			_gbgb = _agf + 1
			goto _aca
		_aca:
			if _agf++; _agf == _ggga {
				goto _bdbb
			}
		_ceb:
			switch _eebe[_agf] {
			case 35:
				goto _afc
			case 37:
				goto _ffa
			case 44:
				goto _afc
			case 46:
				goto _afc
			case 48:
				goto _bbbg
			case 63:
				goto _afc
			case 65:
				goto _agaa
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _afd
			}
			goto _bgd
		_afd:
			_gbgb = _agf + 1
			goto _fabe
		_fabe:
			if _agf++; _agf == _ggga {
				goto _efcg
			}
		_gfbd:
			switch _eebe[_agf] {
			case 35:
				goto _afc
			case 37:
				goto _efb
			case 44:
				goto _afc
			case 46:
				goto _afc
			case 48:
				goto _bbbg
			case 63:
				goto _afc
			case 65:
				goto _agaa
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _afd
			}
			goto _bgd
		_ccg:
			if _agf++; _agf == _ggga {
				goto _bce
			}
		_dgb:
			if _eebe[_agf] == 35 {
				goto _adc
			}
			goto _aagb
		_gcbd:
			_gbgb = _agf + 1
			_dfb = 8
			goto _add
		_add:
			if _agf++; _agf == _ggga {
				goto _bbea
			}
		_fdg:
			switch _eebe[_agf] {
			case 35:
				goto _beeb
			case 37:
				goto _fgb
			case 48:
				goto _dggd
			case 63:
				goto _beeb
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _fba
			}
			goto _bbca
		_beeb:
			if _agf++; _agf == _ggga {
				goto _gcfa
			}
		_abb:
			switch _eebe[_agf] {
			case 35:
				goto _beeb
			case 47:
				goto _bag
			case 48:
				goto _beeb
			case 63:
				goto _beeb
			}
			goto _cgef
		_fgb:
			if _agf++; _agf == _ggga {
				goto _cbca
			}
		_fbgd:
			if _eebe[_agf] == 37 {
				goto _fgb
			}
			if 48 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _fba
			}
			goto _dfd
		_fba:
			if _agf++; _agf == _ggga {
				goto _dgae
			}
		_fdga:
			switch _eebe[_agf] {
			case 37:
				goto _fgb
			case 47:
				goto _bag
			}
			if 48 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _fba
			}
			goto _dfd
		_dggd:
			if _agf++; _agf == _ggga {
				goto _bbeb
			}
		_gcd:
			switch _eebe[_agf] {
			case 35:
				goto _beeb
			case 37:
				goto _fgb
			case 47:
				goto _bag
			case 48:
				goto _dggd
			case 63:
				goto _beeb
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _fba
			}
			goto _cgef
		_ebde:
			_gbgb = _agf + 1
			goto _agde
		_agde:
			if _agf++; _agf == _ggga {
				goto _eea
			}
		_ced:
			switch _eebe[_agf] {
			case 47:
				goto _ebde
			case 100:
				goto _ebde
			case 109:
				goto _ebde
			case 121:
				goto _aaa
			}
			goto _aad
		_aaa:
			if _agf++; _agf == _ggga {
				goto _bcg
			}
		_bbbd:
			if _eebe[_agf] == 121 {
				goto _ebde
			}
			goto _cde
		_bebgg:
			_gbgb = _agf + 1
			_dfb = 2
			goto _dbe
		_dbe:
			if _agf++; _agf == _ggga {
				goto _gbfe
			}
		_agg:
			switch _eebe[_agf] {
			case 35:
				goto _fgg
			case 37:
				goto _eae
			case 47:
				goto _bag
			case 48:
				goto _adb
			case 63:
				goto _fgg
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _edeg
			}
			goto _ddd
		_eae:
			if _agf++; _agf == _ggga {
				goto _bdc
			}
		_eee:
			switch _eebe[_agf] {
			case 35:
				goto _fgg
			case 37:
				goto _eae
			case 47:
				goto _bag
			case 48:
				goto _eae
			case 63:
				goto _fgg
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _fba
			}
			goto _gdd
		_adb:
			if _agf++; _agf == _ggga {
				goto _gaff
			}
		_gaa:
			switch _eebe[_agf] {
			case 35:
				goto _fgg
			case 37:
				goto _eae
			case 47:
				goto _bag
			case 48:
				goto _adb
			case 63:
				goto _fgg
			}
			if 49 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _edeg
			}
			goto _gdd
		_edeg:
			if _agf++; _agf == _ggga {
				goto _efda
			}
		_fecd:
			switch _eebe[_agf] {
			case 37:
				goto _fba
			case 47:
				goto _bag
			}
			if 48 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _edeg
			}
			goto _dfd
		_fda:
			_gbgb = _agf + 1
			_dfb = 20
			goto _dbg
		_dbg:
			if _agf++; _agf == _ggga {
				goto _bed
			}
		_bdf:
			switch _eebe[_agf] {
			case 37:
				goto _fba
			case 47:
				goto _bag
			}
			if 48 <= _eebe[_agf] && _eebe[_agf] <= 57 {
				goto _edeg
			}
			goto _ebd
		_fgfe:
			_gbgb = _agf + 1
			_dfb = 15
			goto _abcb
		_abcb:
			if _agf++; _agf == _ggga {
				goto _bccb
			}
		_dfad:
			switch _eebe[_agf] {
			case 58:
				goto _fgfe
			case 65:
				goto _dffg
			case 104:
				goto _fgfe
			case 109:
				goto _fgfe
			case 115:
				goto _fcda
			}
			goto _dcca
		_dffg:
			if _agf++; _agf == _ggga {
				goto _eabf
			}
		_aab:
			switch _eebe[_agf] {
			case 47:
				goto _gefe
			case 77:
				goto _agdg
			}
			goto _dfd
		_gefe:
			if _agf++; _agf == _ggga {
				goto _fea
			}
		_dbbb:
			if _eebe[_agf] == 80 {
				goto _fgfe
			}
			goto _dfd
		_agdg:
			if _agf++; _agf == _ggga {
				goto _gff
			}
		_ebeb:
			if _eebe[_agf] == 47 {
				goto _baba
			}
			goto _dfd
		_baba:
			if _agf++; _agf == _ggga {
				goto _afe
			}
		_efdb:
			if _eebe[_agf] == 80 {
				goto _dfdb
			}
			goto _dfd
		_dfdb:
			if _agf++; _agf == _ggga {
				goto _dabd
			}
		_dae:
			if _eebe[_agf] == 77 {
				goto _fgfe
			}
			goto _dfd
		_fcda:
			_gbgb = _agf + 1
			_dfb = 15
			goto _fcf
		_fcf:
			if _agf++; _agf == _ggga {
				goto _acgg
			}
		_fdd:
			switch _eebe[_agf] {
			case 46:
				goto _cda
			case 58:
				goto _fgfe
			case 65:
				goto _dffg
			case 104:
				goto _fgfe
			case 109:
				goto _fgfe
			case 115:
				goto _fcda
			}
			goto _dcca
		_cda:
			if _agf++; _agf == _ggga {
				goto _eeaf
			}
		_fbee:
			if _eebe[_agf] == 48 {
				goto _ddff
			}
			goto _eggf
		_ddff:
			_gbgb = _agf + 1
			_dfb = 15
			goto _dfg
		_dfg:
			if _agf++; _agf == _ggga {
				goto _fgd
			}
		_ceec:
			switch _eebe[_agf] {
			case 48:
				goto _cea
			case 58:
				goto _fgfe
			case 65:
				goto _dffg
			case 104:
				goto _fgfe
			case 109:
				goto _fgfe
			case 115:
				goto _fcda
			}
			goto _dcca
		_cea:
			_gbgb = _agf + 1
			_dfb = 15
			goto _efgf
		_efgf:
			if _agf++; _agf == _ggga {
				goto _afg
			}
		_aggb:
			switch _eebe[_agf] {
			case 48:
				goto _fgfe
			case 58:
				goto _fgfe
			case 65:
				goto _dffg
			case 104:
				goto _fgfe
			case 109:
				goto _fgfe
			case 115:
				goto _fcda
			}
			goto _dcca
		_ecbc:
			_gbgb = _agf + 1
			_dfb = 5
			goto _gfae
		_gfae:
			if _agf++; _agf == _ggga {
				goto _cdgf
			}
		_eeed:
			switch _eebe[_agf] {
			case 35:
				goto _fgg
			case 37:
				goto _fgg
			case 47:
				goto _bag
			case 48:
				goto _fgg
			case 63:
				goto _fgg
			}
			goto _edca
		_cebf:
			_gbgb = _agf + 1
			_dfb = 20
			goto _aead
		_aead:
			if _agf++; _agf == _ggga {
				goto _ead
			}
		_agc:
			switch _eebe[_agf] {
			case 47:
				goto _gefe
			case 77:
				goto _agdg
			}
			goto _ebd
		_beba:
			if _agf++; _agf == _ggga {
				goto _agfa
			}
		_gbdf:
			switch _eebe[_agf] {
			case 43:
				goto _dece
			case 45:
				goto _dece
			}
			goto _ebd
		_aeg:
			_gbgb = _agf + 1
			goto _gae
		_gae:
			if _agf++; _agf == _ggga {
				goto _feac
			}
		_gbee:
			if _eebe[_agf] == 101 {
				goto _caa
			}
			goto _ebd
		_caa:
			if _agf++; _agf == _ggga {
				goto _cgcf
			}
		_ceg:
			if _eebe[_agf] == 110 {
				goto _dba
			}
			goto _fdb
		_dba:
			if _agf++; _agf == _ggga {
				goto _dcg
			}
		_eba:
			if _eebe[_agf] == 101 {
				goto _cegc
			}
			goto _fdb
		_cegc:
			if _agf++; _agf == _ggga {
				goto _edda
			}
		_gaea:
			if _eebe[_agf] == 114 {
				goto _gede
			}
			goto _fdb
		_gede:
			if _agf++; _agf == _ggga {
				goto _bfdc
			}
		_gdf:
			if _eebe[_agf] == 97 {
				goto _fdaa
			}
			goto _fdb
		_fdaa:
			if _agf++; _agf == _ggga {
				goto _gfg
			}
		_dcaa:
			if _eebe[_agf] == 108 {
				goto _dadg
			}
			goto _fdb
		_abg:
			_gbgb = _agf + 1
			_dfb = 20
			goto _cdd
		_cdd:
			if _agf++; _agf == _ggga {
				goto _bdd
			}
		_dgdf:
			switch _eebe[_agf] {
			case 104:
				goto _cbbg
			case 109:
				goto _cbbg
			case 115:
				goto _cbbg
			}
			goto _aade
		_aade:
			if _agf++; _agf == _ggga {
				goto _gedef
			}
		_cdde:
			if _eebe[_agf] == 93 {
				goto _abcbe
			}
			goto _aade
		_abcbe:
			_gbgb = _agf + 1
			_dfb = 18
			goto _fae
		_cagc:
			_gbgb = _agf + 1
			_dfb = 16
			goto _fae
		_fae:
			if _agf++; _agf == _ggga {
				goto _bade
			}
		_eca:
			if _eebe[_agf] == 93 {
				goto _abcbe
			}
			goto _aade
		_cbbg:
			if _agf++; _agf == _ggga {
				goto _ceed
			}
		_fcc:
			if _eebe[_agf] == 93 {
				goto _cagc
			}
			goto _aade
		_abfe:
			if _agf++; _agf == _ggga {
				goto _bfbc
			}
		_gfc:
			goto _gcac
		_ecc:
			_gbgb = _agf + 1
			_dfb = 14
			goto _fafa
		_fafa:
			if _agf++; _agf == _ggga {
				goto _gcad
			}
		_cdf:
			switch _eebe[_agf] {
			case 47:
				goto _ebde
			case 58:
				goto _fgfe
			case 65:
				goto _dffg
			case 100:
				goto _ebde
			case 104:
				goto _fgfe
			case 109:
				goto _ecc
			case 115:
				goto _fcda
			case 121:
				goto _aaa
			}
			goto _aad
		_aegf:
			if _agf++; _agf == _ggga {
				goto _bga
			}
		_gcdf:
			if _eebe[_agf] == 121 {
				goto _ebde
			}
			goto _ebd
		_bfb:
		_ggd:
			_fbga = 34
			goto _abdg
		_cffb:
			_fbga = 35
			goto _abdg
		_aba:
			_fbga = 0
			goto _abdg
		_dbf:
			_fbga = 36
			goto _abdg
		_bgdg:
			_fbga = 37
			goto _abdg
		_dabf:
			_fbga = 1
			goto _abdg
		_ega:
			_fbga = 2
			goto _abdg
		_aaea:
			_fbga = 38
			goto _abdg
		_fedb:
			_fbga = 3
			goto _abdg
		_fdff:
			_fbga = 4
			goto _abdg
		_fbbb:
			_fbga = 39
			goto _abdg
		_adcf:
			_fbga = 5
			goto _abdg
		_cddg:
			_fbga = 6
			goto _abdg
		_ccba:
			_fbga = 7
			goto _abdg
		_gbf:
			_fbga = 8
			goto _abdg
		_cffd:
			_fbga = 40
			goto _abdg
		_bdag:
			_fbga = 9
			goto _abdg
		_gdgb:
			_fbga = 41
			goto _abdg
		_acce:
			_fbga = 10
			goto _abdg
		_bggb:
			_fbga = 42
			goto _abdg
		_fafac:
			_fbga = 11
			goto _abdg
		_cbcd:
			_fbga = 43
			goto _abdg
		_bdbb:
			_fbga = 44
			goto _abdg
		_efcg:
			_fbga = 45
			goto _abdg
		_bce:
			_fbga = 12
			goto _abdg
		_bbea:
			_fbga = 46
			goto _abdg
		_gcfa:
			_fbga = 13
			goto _abdg
		_cbca:
			_fbga = 14
			goto _abdg
		_dgae:
			_fbga = 15
			goto _abdg
		_bbeb:
			_fbga = 16
			goto _abdg
		_eea:
			_fbga = 47
			goto _abdg
		_bcg:
			_fbga = 17
			goto _abdg
		_gbfe:
			_fbga = 48
			goto _abdg
		_bdc:
			_fbga = 18
			goto _abdg
		_gaff:
			_fbga = 19
			goto _abdg
		_efda:
			_fbga = 20
			goto _abdg
		_bed:
			_fbga = 49
			goto _abdg
		_bccb:
			_fbga = 50
			goto _abdg
		_eabf:
			_fbga = 21
			goto _abdg
		_fea:
			_fbga = 22
			goto _abdg
		_gff:
			_fbga = 23
			goto _abdg
		_afe:
			_fbga = 24
			goto _abdg
		_dabd:
			_fbga = 25
			goto _abdg
		_acgg:
			_fbga = 51
			goto _abdg
		_eeaf:
			_fbga = 26
			goto _abdg
		_fgd:
			_fbga = 52
			goto _abdg
		_afg:
			_fbga = 53
			goto _abdg
		_cdgf:
			_fbga = 54
			goto _abdg
		_ead:
			_fbga = 55
			goto _abdg
		_agfa:
			_fbga = 56
			goto _abdg
		_feac:
			_fbga = 57
			goto _abdg
		_cgcf:
			_fbga = 27
			goto _abdg
		_dcg:
			_fbga = 28
			goto _abdg
		_edda:
			_fbga = 29
			goto _abdg
		_bfdc:
			_fbga = 30
			goto _abdg
		_gfg:
			_fbga = 31
			goto _abdg
		_bdd:
			_fbga = 58
			goto _abdg
		_gedef:
			_fbga = 32
			goto _abdg
		_bade:
			_fbga = 59
			goto _abdg
		_ceed:
			_fbga = 33
			goto _abdg
		_bfbc:
			_fbga = 60
			goto _abdg
		_gcad:
			_fbga = 61
			goto _abdg
		_bga:
			_fbga = 62
			goto _abdg
		_abdg:
			{
			}
			if _agf == _bcc {
				switch _fbga {
				case 35:
					goto _ebd
				case 0:
					goto _dfd
				case 36:
					goto _bdef
				case 37:
					goto _agef
				case 1:
					goto _dfd
				case 2:
					goto _dfd
				case 38:
					goto _bgd
				case 3:
					goto _bab
				case 4:
					goto _bab
				case 39:
					goto _bgd
				case 5:
					goto _bab
				case 6:
					goto _bab
				case 7:
					goto _bab
				case 8:
					goto _dfd
				case 40:
					goto _bgd
				case 9:
					goto _bab
				case 41:
					goto _bgd
				case 10:
					goto _dfd
				case 42:
					goto _bgd
				case 11:
					goto _bab
				case 43:
					goto _bgd
				case 44:
					goto _bgd
				case 45:
					goto _bgd
				case 12:
					goto _aagb
				case 46:
					goto _bbca
				case 13:
					goto _cgef
				case 14:
					goto _dfd
				case 15:
					goto _dfd
				case 16:
					goto _cgef
				case 47:
					goto _aad
				case 17:
					goto _cde
				case 48:
					goto _ddd
				case 18:
					goto _gdd
				case 19:
					goto _gdd
				case 20:
					goto _dfd
				case 49:
					goto _ebd
				case 50:
					goto _dcca
				case 21:
					goto _dfd
				case 22:
					goto _dfd
				case 23:
					goto _dfd
				case 24:
					goto _dfd
				case 25:
					goto _dfd
				case 51:
					goto _dcca
				case 26:
					goto _eggf
				case 52:
					goto _dcca
				case 53:
					goto _dcca
				case 54:
					goto _edca
				case 55:
					goto _ebd
				case 56:
					goto _ebd
				case 57:
					goto _ebd
				case 27:
					goto _fdb
				case 28:
					goto _fdb
				case 29:
					goto _fdb
				case 30:
					goto _fdb
				case 31:
					goto _fdb
				case 58:
					goto _ebd
				case 32:
					goto _dfd
				case 59:
					goto _dfd
				case 33:
					goto _fdb
				case 60:
					goto _ebd
				case 61:
					goto _aad
				case 62:
					goto _ebd
				}
			}
		}
		if _ffb > 0 {
			copy(_eebe[0:], _eebe[_ffb:])
		}
	}
	_ = _bcc
	if _fbga == _dbdb {
		_a.Log("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072")
	}
}

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte

const _ecb int = 0

func _adfc(_dccd _g.Time, _bdeg string) []byte {
	_bee := []byte{}
	_gca := 0
	for _gda := 0; _gda < len(_bdeg); _gda++ {
		var _eab string
		if _bdeg[_gda] == '/' {
			_eab = string(_bdeg[_gca:_gda])
			_gca = _gda + 1
		} else if _gda == len(_bdeg)-1 {
			_eab = string(_bdeg[_gca : _gda+1])
		} else {
			continue
		}
		switch _eab {
		case "\u0079\u0079":
			_bee = _dccd.AppendFormat(_bee, "\u0030\u0036")
		case "\u0079\u0079\u0079\u0079":
			_bee = _dccd.AppendFormat(_bee, "\u0032\u0030\u0030\u0036")
		case "\u006d":
			_bee = _dccd.AppendFormat(_bee, "\u0031")
		case "\u006d\u006d":
			_bee = _dccd.AppendFormat(_bee, "\u0030\u0031")
		case "\u006d\u006d\u006d":
			_bee = _dccd.AppendFormat(_bee, "\u004a\u0061\u006e")
		case "\u006d\u006d\u006d\u006d":
			_bee = _dccd.AppendFormat(_bee, "\u004aa\u006e\u0075\u0061\u0072\u0079")
		case "\u006d\u006d\u006dm\u006d":
			switch _dccd.Month() {
			case _g.January, _g.July, _g.June:
				_bee = append(_bee, 'J')
			case _g.February:
				_bee = append(_bee, 'M')
			case _g.March, _g.May:
				_bee = append(_bee, 'M')
			case _g.April, _g.August:
				_bee = append(_bee, 'A')
			case _g.September:
				_bee = append(_bee, 'S')
			case _g.October:
				_bee = append(_bee, 'O')
			case _g.November:
				_bee = append(_bee, 'N')
			case _g.December:
				_bee = append(_bee, 'D')
			}
		case "\u0064":
			_bee = _dccd.AppendFormat(_bee, "\u0032")
		case "\u0064\u0064":
			_bee = _dccd.AppendFormat(_bee, "\u0030\u0032")
		case "\u0064\u0064\u0064":
			_bee = _dccd.AppendFormat(_bee, "\u004d\u006f\u006e")
		case "\u0064\u0064\u0064\u0064":
			_bee = _dccd.AppendFormat(_bee, "\u004d\u006f\u006e\u0064\u0061\u0079")
		default:
			_a.Log("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073", _eab)
		}
		if _bdeg[_gda] == '/' {
			_bee = append(_bee, '/')
		}
	}
	return _bee
}

// AddToken adds a format token to the format.
func (_db *Format) AddToken(t FmtType, l []byte) {
	if _db._fb {
		_db._fb = false
		return
	}
	switch t {
	case FmtTypeDecimal:
		_db._cf = true
	case FmtTypeUnderscore:
		_db._fb = true
	case FmtTypeText:
		_db.Whole = append(_db.Whole, Token{Type: t})
	case FmtTypeDate, FmtTypeTime:
		_db.Whole = append(_db.Whole, Token{Type: t, DateTime: string(l)})
	case FmtTypePercent:
		_db._ca = true
		t = FmtTypeLiteral
		l = []byte{'%'}
		fallthrough
	case FmtTypeDigitOpt:
		fallthrough
	case FmtTypeLiteral, FmtTypeDigit, FmtTypeDollar, FmtTypeComma:
		if l == nil {
			l = []byte{0}
		}
		for _, _de := range l {
			if _db.IsExponential {
				_db.Exponent = append(_db.Exponent, Token{Type: t, Literal: _de})
			} else if !_db._cf {
				_db.Whole = append(_db.Whole, Token{Type: t, Literal: _de})
			} else {
				_db.Fractional = append(_db.Fractional, Token{Type: t, Literal: _de})
			}
		}
	case FmtTypeDigitOptThousands:
		_db._ab = true
	case FmtTypeFraction:
		_beb := _be.Split(string(l), "\u002f")
		if len(_beb) == 2 {
			_db._cc = true
			_db._af, _ = _e.ParseInt(_beb[1], 10, 64)
			for _, _da := range _beb[1] {
				if _da == '?' || _da == '0' {
					_db._ad++
				}
			}
		}
	default:
		_a.Log("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076", t)
	}
}

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric(v float64) string {
	if _df.Abs(v) >= _ag || _df.Abs(v) <= _beg && v != 0 {
		return _gedf(v)
	}
	_bba := make([]byte, 0, 15)
	_bba = _e.AppendFloat(_bba, v, 'f', -1, 64)
	if len(_bba) > 11 {
		_gce := _bba[11] - '0'
		if _gce >= 5 && _gce <= 9 {
			_bba[10]++
			_bba = _bba[0:11]
			_bba = _gd(_bba)
		}
		_bba = _bba[0:11]
	} else if len(_bba) == 11 {
		if _bba[len(_bba)-1] == '9' {
			_bba[len(_bba)-1]++
			_bba = _gd(_bba)
		}
	}
	_bba = _fed(_bba)
	return string(_bba)
}

// Format is a parsed number format.
type Format struct {
	Whole         []Token
	Fractional    []Token
	Exponent      []Token
	IsExponential bool
	_cc           bool
	_ca           bool
	_bb           bool
	_ab           bool
	_fb           bool
	_cf           bool
	_af           int64
	_ad           int
}

var _c = [...]uint8{0, 14, 26, 41, 53, 67, 81, 94, 118, 135, 146, 157, 172, 183}

const _gag int = 0

func IsNumber(data string) (_cgc bool) {
	_gdc, _gab, _gdg := 0, 0, len(data)
	_aed := len(data)
	_fegd, _gbgf, _dcf := 0, 0, 0
	_ = _gbgf
	_ = _dcf
	_ = _fegd
	{
		_gdc = _gfea
		_fegd = 0
		_gbgf = 0
		_dcf = 0
	}
	{
		if _gab == _gdg {
			goto _gef
		}
		switch _gdc {
		case 0:
			goto _dde
		case 1:
			goto _bbc
		case 2:
			goto _cag
		case 3:
			goto _cgb
		case 4:
			goto _cdb
		case 5:
			goto _ebe
		case 6:
			goto _dfa
		case 7:
			goto _cge
		}
		goto _beeg
	_ecdc:
		_gbgf = _gab
		_gab--
		{
			_cgc = false
		}
		goto _acc
	_aff:
		_gbgf = _gab
		_gab--
		{
			_cgc = _gbgf == len(data)
		}
		goto _acc
	_bea:
		_gbgf = _gab
		_gab--
		{
			_cgc = _gbgf == len(data)
		}
		goto _acc
	_eecg:
		switch _dcf {
		case 2:
			{
				_gab = (_gbgf) - 1
				_cgc = _gbgf == len(data)
			}
		case 3:
			{
				_gab = (_gbgf) - 1
				_cgc = false
			}
		}
		goto _acc
	_acc:
		_fegd = 0
		if _gab++; _gab == _gdg {
			goto _dec
		}
	_dde:
		_fegd = _gab
		switch data[_gab] {
		case 43:
			goto _def
		case 45:
			goto _def
		}
		if 48 <= data[_gab] && data[_gab] <= 57 {
			goto _cdg
		}
		goto _dgg
	_dgg:
		if _gab++; _gab == _gdg {
			goto _agd
		}
	_bbc:
		goto _dgg
	_def:
		if _gab++; _gab == _gdg {
			goto _edc
		}
	_cag:
		if 48 <= data[_gab] && data[_gab] <= 57 {
			goto _cdg
		}
		goto _dgg
	_cdg:
		if _gab++; _gab == _gdg {
			goto _gdcf
		}
	_cgb:
		if data[_gab] == 46 {
			goto _ede
		}
		if 48 <= data[_gab] && data[_gab] <= 57 {
			goto _cdg
		}
		goto _dgg
	_ede:
		if _gab++; _gab == _gdg {
			goto _ccf
		}
	_cdb:
		if 48 <= data[_gab] && data[_gab] <= 57 {
			goto _gcb
		}
		goto _dgg
	_gcb:
		if _gab++; _gab == _gdg {
			goto _ddf
		}
	_ebe:
		if data[_gab] == 69 {
			goto _egb
		}
		if 48 <= data[_gab] && data[_gab] <= 57 {
			goto _gcb
		}
		goto _dgg
	_egb:
		if _gab++; _gab == _gdg {
			goto _cae
		}
	_dfa:
		switch data[_gab] {
		case 43:
			goto _age
		case 45:
			goto _age
		}
		goto _dgg
	_age:
		_gbgf = _gab + 1
		_dcf = 3
		goto _efd
	_cbg:
		_gbgf = _gab + 1
		_dcf = 2
		goto _efd
	_efd:
		if _gab++; _gab == _gdg {
			goto _aag
		}
	_cge:
		if 48 <= data[_gab] && data[_gab] <= 57 {
			goto _cbg
		}
		goto _dgg
	_beeg:
	_dec:
		_gdc = 0
		goto _gef
	_agd:
		_gdc = 1
		goto _gef
	_edc:
		_gdc = 2
		goto _gef
	_gdcf:
		_gdc = 3
		goto _gef
	_ccf:
		_gdc = 4
		goto _gef
	_ddf:
		_gdc = 5
		goto _gef
	_cae:
		_gdc = 6
		goto _gef
	_aag:
		_gdc = 7
		goto _gef
	_gef:
		{
		}
		if _gab == _aed {
			switch _gdc {
			case 1:
				goto _ecdc
			case 2:
				goto _ecdc
			case 3:
				goto _aff
			case 4:
				goto _ecdc
			case 5:
				goto _bea
			case 6:
				goto _ecdc
			case 7:
				goto _eecg
			}
		}
	}
	if _gdc == _dbdb {
		return false
	}
	return
}

const _beg = 1e-10
