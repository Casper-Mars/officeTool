//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore

import (
	_a "encoding/hex"
	_fd "errors"
	_gd "fmt"
	_ca "github.com/Casper-Mars/officeTool/common/tempstorage"
	_g "io"
	_bd "io/ioutil"
	_f "math/rand"
	_b "sync"
)

func _df(_ea int) (string, error) {
	_ggf := make([]byte, _ea)
	if _, _gb := _f.Read(_ggf); _gb != nil {
		return "", _gb
	}
	return _a.EncodeToString(_ggf), nil
}

type memFile struct {
	_ga *memDataCell
	_ba int64
}

// Name returns the filename of the underlying memDataCell
func (_bgg *memFile) Name() string { return _bgg._ga._bab }

// Close is not applicable in this implementation
func (_ee *memFile) Close() error { return nil }

type memStorage struct{ _ae _b.Map }

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_bga *memFile) Write(p []byte) (int, error) {
	_bga._ga._ace = append(_bga._ga._ace, p...)
	_bga._ga._cb += int64(len(p))
	return len(p), nil
}

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage() { _cbd := memStorage{_ae: _b.Map{}}; _ca.SetAsStorage(&_cbd) }

// TempFile creates a new empty file in the storage and returns it
func (_baa *memStorage) TempFile(dir, pattern string) (_ca.File, error) {
	_dad := dir + "\u002f" + _dea(pattern)
	_af := &memDataCell{_bab: _dad, _ace: []byte{}}
	_bae := &memFile{_ga: _af}
	_baa._ae.Store(_dad, _af)
	return _bae, nil
}

// TempDir creates a name for a new temp directory using a pattern argument
func (_gg *memStorage) TempDir(pattern string) (string, error) { return _dea(pattern), nil }

type memDataCell struct {
	_bab string
	_ace []byte
	_cb  int64
}

// Add reads a file from a disk and adds it to the storage
func (_fde *memStorage) Add(path string) error {
	_bc, _eec := _bd.ReadFile(path)
	if _eec != nil {
		return _eec
	}
	_fde._ae.Store(path, &memDataCell{_bab: path, _ace: _bc})
	return nil
}

func _dea(_dec string) string { _ff, _ := _df(6); return _dec + _ff }

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_ac *memFile) Read(p []byte) (int, error) {
	_d := _ac._ba
	_bg := _ac._ga._cb
	_e := int64(len(p))
	if _e > _bg {
		_e = _bg
		p = p[:_e]
	}
	if _d >= _bg {
		return 0, _g.EOF
	}
	_bad := _d + _e
	if _bad >= _bg {
		_bad = _bg
	}
	_ed := copy(p, _ac._ga._ace[_d:_bad])
	_ac._ba = _bad
	return _ed, nil
}

// RemoveAll removes all files according to the dir argument prefix
func (_gac *memStorage) RemoveAll(dir string) error {
	_gac._ae.Range(func(_fb, _de interface{}) bool { _gac._ae.Delete(_fb); return true })
	return nil
}

// Open returns tempstorage File object by name
func (_baf *memStorage) Open(path string) (_ca.File, error) {
	_da, _bdb := _baf._ae.Load(path)
	if !_bdb {
		return nil, _fd.New(_gd.Sprintf("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073", path))
	}
	return &memFile{_ga: _da.(*memDataCell)}, nil
}
